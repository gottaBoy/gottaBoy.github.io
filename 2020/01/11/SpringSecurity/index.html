<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Spring Security," />





  <link rel="alternate" href="/atom.xml" title="圣女哥哥的博客" type="application/atom+xml" />






<meta name="description" content="OAuth2.0 技术 Spring Security OAuth2 keycloak Nimbus OAuth Apache Oltu vertx-auth-oauth2  https:&#x2F;&#x2F;www.felord.cn&#x2F;categories&#x2F;spring-security&#x2F;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;dywak06zI4d_LU0s9haVLghttps:&#x2F;&#x2F;mp.wei">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringSecurity">
<meta property="og:url" content="http://gottaboy.cn/2020/01/11/SpringSecurity/index.html">
<meta property="og:site_name" content="圣女哥哥的博客">
<meta property="og:description" content="OAuth2.0 技术 Spring Security OAuth2 keycloak Nimbus OAuth Apache Oltu vertx-auth-oauth2  https:&#x2F;&#x2F;www.felord.cn&#x2F;categories&#x2F;spring-security&#x2F;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;dywak06zI4d_LU0s9haVLghttps:&#x2F;&#x2F;mp.wei">
<meta property="og:image" content="http://gottaboy.cn/2020/01/11/SpringSecurity/main_callback.png">
<meta property="og:image" content="http://gottaboy.cn/2020/01/11/SpringSecurity/csrf.png">
<meta property="og:image" content="http://gottaboy.cn/2020/01/11/SpringSecurity/Basic.png">
<meta property="og:image" content="http://gottaboy.cn/2020/01/11/SpringSecurity/Digest.png">
<meta property="article:published_time" content="2020-01-11T05:31:01.000Z">
<meta property="article:modified_time" content="2020-02-25T13:56:59.674Z">
<meta property="article:author" content="gottaBoy">
<meta property="article:tag" content="Spring Security">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://gottaboy.cn/2020/01/11/SpringSecurity/main_callback.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":5},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gottaboy.cn/2020/01/11/SpringSecurity/"/>





  <title>SpringSecurity | 圣女哥哥的博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/gottaboy" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style> 
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">圣女哥哥的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">快乐生活每一天</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gottaboy.cn/2020/01/11/SpringSecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="gottaBoy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣女哥哥的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SpringSecurity</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-11T13:31:01+08:00">
                2020-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  33.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  137
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="OAuth2-0-技术"><a href="#OAuth2-0-技术" class="headerlink" title="OAuth2.0 技术"></a>OAuth2.0 技术</h2><ul>
<li>Spring Security OAuth2</li>
<li>keycloak</li>
<li>Nimbus OAuth</li>
<li>Apache Oltu</li>
<li>vertx-auth-oauth2</li>
</ul>
<h2 id="https-www-felord-cn-categories-spring-security"><a href="#https-www-felord-cn-categories-spring-security" class="headerlink" title="https://www.felord.cn/categories/spring-security/"></a><a href="https://www.felord.cn/categories/spring-security/" target="_blank" rel="noopener">https://www.felord.cn/categories/spring-security/</a></h2><p><a href="https://mp.weixin.qq.com/s/dywak06zI4d_LU0s9haVLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dywak06zI4d_LU0s9haVLg</a><br><a href="https://mp.weixin.qq.com/s/2i7K9hq7LCytlzOjCl1bXA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2i7K9hq7LCytlzOjCl1bXA</a><br><a href="https://github.com/linlinjava/litemall" target="_blank" rel="noopener">https://github.com/linlinjava/litemall</a><br><a href="https://github.com/shenzhuan/zscat-me" target="_blank" rel="noopener">https://github.com/shenzhuan/zscat-me</a><br><a href="https://github.com/Mynameisfwk/vivo-shop" target="_blank" rel="noopener">https://github.com/Mynameisfwk/vivo-shop</a><br><a href="https://github.com/paascloud" target="_blank" rel="noopener">https://github.com/paascloud</a><br><a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">https://github.com/paascloud/paascloud-master</a><br><a href="https://gitee.com/owenwangwen/open-capacity-platform" target="_blank" rel="noopener">https://gitee.com/owenwangwen/open-capacity-platform</a><br><a href="https://gitee.com/zlt2000/microservices-platform" target="_blank" rel="noopener">https://gitee.com/zlt2000/microservices-platform</a><br><a href="https://github.com/Ewall1106/mall" target="_blank" rel="noopener">https://github.com/Ewall1106/mall</a><br><a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener">https://github.com/newbee-ltd/newbee-mall</a><br><a href="https://github.com/macrozheng/mall-admin-web" target="_blank" rel="noopener">https://github.com/macrozheng/mall-admin-web</a><br><a href="https://github.com/macrozheng/mall-swarm" target="_blank" rel="noopener">https://github.com/macrozheng/mall-swarm</a><br><a href="https://github.com/macrozheng/mall-learning" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning</a><br><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a><br><a href="https://github.com/YunaiV/onemall" target="_blank" rel="noopener">https://github.com/YunaiV/onemall</a><br><a href="https://niocoder.com/" target="_blank" rel="noopener">https://niocoder.com/</a><br><a href="https://niocoder.com/2017/02/17/Spring-atomikos/" target="_blank" rel="noopener">https://niocoder.com/2017/02/17/Spring-atomikos/</a><br><a href="https://niocoder.com/categories/#Security" target="_blank" rel="noopener">https://niocoder.com/categories/#Security</a><br>kubernetes<br><a href="https://github.com/gottaBoy/sealos" target="_blank" rel="noopener">https://github.com/gottaBoy/sealos</a><br><a href="https://sealyun.com/github/" target="_blank" rel="noopener">https://sealyun.com/github/</a><br>Apache<br> Kylin<br><a href="https://mp.weixin.qq.com/s/1tlytTG63xDyZyrlyM_zpA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1tlytTG63xDyZyrlyM_zpA</a><br><a href="https://mp.weixin.qq.com/s/EgZSEpc7SHl5kg6WLSQdPQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EgZSEpc7SHl5kg6WLSQdPQ</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java web领域经常提及的两大开源框架主要有两种选择Spring Security和Apache Shiro</p>
<h3 id="Spring-Security-和-Apache-Shiro"><a href="#Spring-Security-和-Apache-Shiro" class="headerlink" title="Spring Security 和 Apache Shiro"></a>Spring Security 和 Apache Shiro</h3><p>相对于Apache Shiro，Spring Security提供了更多的诸如LDAP、OAuth2.0、ACL、Kerberos、SAML、SSO、OpenID等诸多的安全认证、鉴权协议，可以按需引用。对认证/鉴权更加灵活，粒度更细。可以结合你自己的业务场景进行更加合理的定制化开发。在最新的Spring Security 5.x中更是提供了响应式应用（reactive application）提供了安全控制支持。从语言上来讲，支持使用kotlin、groovy进行开发。</p>
<p>Spring Security因为是利用了Spring IOC 和AOP的特性而无法脱离Spring独立存在。而Apache Shiro可以独立存在。但是Java Web领域Spring可以说是事实上的J2EE规范。使用Java技术栈很少能脱离Spring。也因为功能强大Spring Security被认为非常重，这是不对的。认真学习之后会发现其实也就是那么回事。两种框架都是非常优秀的安全框架，根据实际需要做技术选型。如果你要学习这两种安全框架就必须熟悉一下一些相对专业的概念。</p>
<h3 id="认证-鉴权"><a href="#认证-鉴权" class="headerlink" title="认证/鉴权"></a>认证/鉴权</h3><p>这两个概念英文分别为authentication/authorization 。是不是特别容易混淆。无论你选择Apache Shiro 或者 Spring Security 都需要熟悉这两个概念。其实简单来说认证（authentication）就是为了证明你是谁，比如你输入账号密码证明你是用户名为iching的用户。而授权（authorization）是通过认证后的用户所绑定的角色等凭证来证明你可以做什么 。打一个现实中的例子。十一长假大家远行都要乘坐交通工具，现在坐车实名制，也就是说你坐车需要两件东西：身份证和车票 。身份证是为了证明你确实是你，这就是 authentication；而车票是为了证明你张三确实买了票可以上车，这就是 authorization。这个例子从另一方面也证明了。如果只有认证没有授权，认证就没有意义。如果没有认证，授权就无法赋予真正的可信任的用户。两者是同时存在的。</p>
<h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>对于servlet web应用来说，想要通用的安全控制最好莫过于使用Servlet Filter 。 过滤器责任链来组成一系列的过滤策略，不同的条件的请求进入不同的过滤器进行各自的处理逻辑。我们可以对这些Filter 进行排列组合以满足我们的实际业务需要。</p>
<h3 id="RBAC模型"><a href="#RBAC模型" class="headerlink" title="RBAC模型"></a>RBAC模型</h3><p>RBAC 是基于角色的访问控制（Role-Based Access Control ）的简称。在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。当你拥有某个角色以后，你自然继承了该角色的所有功能。对你的一些操作限制不需要直接与你进行沟通，只需要操作你拥有的角色。比如你在公司既是一个java程序员又是一个前端程序员，那么你不但要当sqlboy还要当页面仔。如果有一天经理说了前端负责测试工作，好了你又承担了测试任务。</p>
<h3 id="其他一些概念"><a href="#其他一些概念" class="headerlink" title="其他一些概念"></a>其他一些概念</h3><p>比如其它一些常见的安全策略、攻击方式。比如 反向代理、网关、壁垒机这种偏运维的知识；CSRF（Cross-site request forgery）跨站请求伪造 、XSS（跨站脚本攻击）也需要了解一些。对于一些上面提到的什么OAuth2.0之类的协议也最好研究一下。当然这些不是必须的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文粗略的简述了Spring Security 和Apache Shiro的一些异同。以及学习它们的一些前置条件。如果你不满足这些条件学习起来可能比较吃力。所以本文的作用是为你学习预热，做一些准备工作，避免新入门的同学陷入迷途。也希望大家多多支持，多多关注。</p>
<hr>
<h2 id="用户信息UserDetails相关入门"><a href="#用户信息UserDetails相关入门" class="headerlink" title="用户信息UserDetails相关入门"></a>用户信息UserDetails相关入门</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>前一篇介绍了 Spring Security 入门的基础准备。从今天开始我们来一步步窥探它是如何工作的。我们又该如何驾驭它。请多多关注公众号： iching 。本篇将通过 Spring Boot 2.x 来讲解 Spring Security 中的用户主体UserDetails。以及从中找点乐子。</p>
<h3 id="2-Spring-Boot-集成-Spring-Security"><a href="#2-Spring-Boot-集成-Spring-Security" class="headerlink" title="2. Spring Boot 集成 Spring Security"></a>2. Spring Boot 集成 Spring Security</h3><p>这个简直老生常谈了。不过为了照顾大多数还是说一下。集成 Spring Security 只需要引入其对应的 Starter 组件。Spring Security 不仅仅能保护Servlet Web 应用，也可以保护Reactive Web应用，本文我们讲前者。我们只需要在 Spring Security 项目引入以下依赖即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  actuator 指标监控  非必须 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--  spring security starter 必须  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- spring mvc  servlet web  必须  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--   lombok 插件 非必须       --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- 测试   --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-UserDetailsServiceAutoConfiguration"><a href="#3-UserDetailsServiceAutoConfiguration" class="headerlink" title="3. UserDetailsServiceAutoConfiguration"></a>3. UserDetailsServiceAutoConfiguration</h3><p>启动项目，访问Actuator端点<a href="http://localhost:8080/actuator会跳转到一个登录页面http://localhost:8080/login如下：" target="_blank" rel="noopener">http://localhost:8080/actuator会跳转到一个登录页面http://localhost:8080/login如下：</a><br>#TODO</p>
<p>要求你输入用户名 Username （默认值为user）和密码 Password 。密码在springboot控制台会打印出类似 Using generated security password: e1f163be-ad18-4be1-977c-88a6bcee0d37 的字样，后面的长串就是密码，当然这不是生产可用的。如果你足够细心会从控制台打印日志发现该随机密码是由UserDetailsServiceAutoConfiguration 配置类生成的，我们就从它开始顺藤摸瓜来一探究竟。</p>
<h4 id="3-1-UserDetailsService"><a href="#3-1-UserDetailsService" class="headerlink" title="3.1 UserDetailsService"></a>3.1 UserDetailsService</h4><p>UserDetailsService接口。该接口只提供了一个方法：</p>
<p>  UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;<br>该方法很容易理解：通过用户名来加载用户 。这个方法主要用于从系统数据中查询并加载具体的用户到Spring Security中。</p>
<h4 id="3-2-UserDetails"><a href="#3-2-UserDetails" class="headerlink" title="3.2 UserDetails"></a>3.2 UserDetails</h4><p>从上面UserDetailsService 可以知道最终交给Spring Security的是UserDetails 。该接口是提供用户信息的核心接口。该接口实现仅仅存储用户的信息。后续会将该接口提供的用户信息封装到认证对象Authentication中去。UserDetails 默认提供了：</p>
<p>用户的权限集， 默认需要添加ROLE_ 前缀<br>用户的加密后的密码， 不加密会使用{noop}前缀<br>应用内唯一的用户名<br>账户是否过期<br>账户是否锁定<br>凭证是否过期<br>用户是否可用<br>如果以上的信息满足不了你使用，你可以自行实现扩展以存储更多的用户信息。比如用户的邮箱、手机号等等。通常我们使用其实现类：</p>
<p>org.springframework.security.core.userdetails.User<br>该类内置一个建造器UserBuilder 会很方便地帮助我们构建UserDetails 对象，后面我们会用到它。</p>
<h4 id="3-3-UserDetailsServiceAutoConfiguration"><a href="#3-3-UserDetailsServiceAutoConfiguration" class="headerlink" title="3.3 UserDetailsServiceAutoConfiguration"></a>3.3 UserDetailsServiceAutoConfiguration</h4><p>UserDetailsServiceAutoConfiguration 全限定名为:</p>
<p>org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration<br>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(AuthenticationManager.class)</span><br><span class="line">@ConditionalOnBean(ObjectPostProcessor.class)</span><br><span class="line">@ConditionalOnMissingBean(&#123; AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class &#125;)</span><br><span class="line">public class UserDetailsServiceAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private static final String NOOP_PASSWORD_PREFIX &#x3D; &quot;&#123;noop&#125;&quot;;</span><br><span class="line"></span><br><span class="line">    private static final Pattern PASSWORD_ALGORITHM_PATTERN &#x3D; Pattern.compile(&quot;^\\&#123;.+&#125;.*$&quot;);</span><br><span class="line"></span><br><span class="line">    private static final Log logger &#x3D; LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">            type &#x3D; &quot;org.springframework.security.oauth2.client.registration.ClientRegistrationRepository&quot;)</span><br><span class="line">    @Lazy</span><br><span class="line">    public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,</span><br><span class="line">            ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder) &#123;</span><br><span class="line">        SecurityProperties.User user &#x3D; properties.getUser();</span><br><span class="line">        List&lt;String&gt; roles &#x3D; user.getRoles();</span><br><span class="line">        return new InMemoryUserDetailsManager(</span><br><span class="line">                User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))</span><br><span class="line">                        .roles(StringUtils.toStringArray(roles)).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) &#123;</span><br><span class="line">        String password &#x3D; user.getPassword();</span><br><span class="line">        if (user.isPasswordGenerated()) &#123;</span><br><span class="line">            logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (encoder !&#x3D; null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) &#123;</span><br><span class="line">            return password;</span><br><span class="line">        &#125;</span><br><span class="line">        return NOOP_PASSWORD_PREFIX + password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来简单解读一下该类，从@Conditional系列注解我们知道该类在类路径下存在AuthenticationManager、在Spring 容器中存在Bean ObjectPostProcessor并且不存在Bean AuthenticationManager, AuthenticationProvider, UserDetailsService的情况下生效。千万不要纠结这些类干嘛用的! 该类只初始化了一个UserDetailsManager 类型的Bean。UserDetailsManager 类型负责对安全用户实体抽象UserDetails的增删查改操作。同时还继承了UserDetailsService接口。</p>
<p>明白了上面这些让我们把目光再回到UserDetailsServiceAutoConfiguration 上来。该类初始化了一个名为InMemoryUserDetailsManager 的内存用户管理器。该管理器通过配置注入了一个默认的UserDetails存在内存中，就是我们上面用的那个user ，每次启动user都是动态生成的。那么问题来了如果我们定义自己的UserDetailsManager Bean是不是就可以实现我们需要的用户管理逻辑呢？</p>
<h4 id="3-4-自定义UserDetailsManager"><a href="#3-4-自定义UserDetailsManager" class="headerlink" title="3.4 自定义UserDetailsManager"></a>3.4 自定义UserDetailsManager</h4><p>我们来自定义一个UserDetailsManager 来看看能不能达到自定义用户管理的效果。首先我们针对UserDetailsManager 的所有方法进行一个代理的实现，我们依然将用户存在内存中，区别就是这是我们自定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public class UserDetailsRepository &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 替换为 抽象DAO接口可进行用户持久化操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String, UserDetails&gt; users &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create user.</span><br><span class="line">     *</span><br><span class="line">     * @param user the user</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void createUser(UserDetails user) &#123;</span><br><span class="line">        users.putIfAbsent(user.getUsername(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Update user.</span><br><span class="line">     *</span><br><span class="line">     * @param user the user</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void updateUser(UserDetails user) &#123;</span><br><span class="line">        users.put(user.getUsername(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Delete user.</span><br><span class="line">     *</span><br><span class="line">     * @param username the username</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void deleteUser(String username) &#123;</span><br><span class="line">        users.remove(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Change password.</span><br><span class="line">     *</span><br><span class="line">     * @param oldPassword the old password</span><br><span class="line">     * @param newPassword the new password</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void changePassword(String oldPassword, String newPassword) &#123;</span><br><span class="line">        Authentication currentUser &#x3D; SecurityContextHolder.getContext()</span><br><span class="line">                .getAuthentication();</span><br><span class="line"></span><br><span class="line">        if (currentUser &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; This would indicate bad coding somewhere</span><br><span class="line">            throw new AccessDeniedException(</span><br><span class="line">                    &quot;Can&#39;t change password as no Authentication object found in context &quot;</span><br><span class="line">                            + &quot;for current user.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String username &#x3D; currentUser.getName();</span><br><span class="line"></span><br><span class="line">        UserDetails user &#x3D; users.get(username);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Current user doesn&#39;t exist in database.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 实现具体的更新密码逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * User exists boolean.</span><br><span class="line">     *</span><br><span class="line">     * @param username the username</span><br><span class="line">     * @return the boolean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean userExists(String username) &#123;</span><br><span class="line"></span><br><span class="line">        return users.containsKey(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Load user by username user details.</span><br><span class="line">     *</span><br><span class="line">     * @param username the username</span><br><span class="line">     * @return the user details</span><br><span class="line">     * @throws UsernameNotFoundException the username not found exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">        return users.get(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类负责具体对UserDetails 的增删改查操作。我们将其注入Spring 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public UserDetailsRepository userDetailsRepository() &#123;</span><br><span class="line">    UserDetailsRepository userDetailsRepository &#x3D; new UserDetailsRepository();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 为了让我们的登录能够运行 这里我们初始化一个用户iching 密码采用明文 当你在密码12345上使用了前缀&#123;noop&#125; 意味着你的密码不使用加密，authorities 一定不能为空 这代表用户的角色权限集合</span><br><span class="line">    UserDetails iching &#x3D; User.withUsername(&quot;iching&quot;).password(&quot;&#123;noop&#125;123456&quot;).authorities(AuthorityUtils.NO_AUTHORITIES).build();</span><br><span class="line">    userDetailsRepository.createUser(iching);</span><br><span class="line">    return userDetailsRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便测试 我们也内置一个名称为iching 密码为12345的UserDetails用户，密码采用明文 当你在密码123456上使用了前缀{noop} 意味着你的密码不使用加密，这里我们并没有指定密码加密方式你可以使用PasswordEncoder 来指定一种加密方式。通常推荐使用Bcrypt作为加密方式。默认Spring Security使用的也是此方式。authorities 一定不能为null 这代表用户的角色权限集合。接下来我们实现一个UserDetailsManager 并注入Spring 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public UserDetailsManager userDetailsManager(UserDetailsRepository userDetailsRepository) &#123;</span><br><span class="line">    return new UserDetailsManager() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void createUser(UserDetails user) &#123;</span><br><span class="line">            userDetailsRepository.createUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void updateUser(UserDetails user) &#123;</span><br><span class="line">            userDetailsRepository.updateUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void deleteUser(String username) &#123;</span><br><span class="line">            userDetailsRepository.deleteUser(username);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void changePassword(String oldPassword, String newPassword) &#123;</span><br><span class="line">            userDetailsRepository.changePassword(oldPassword, newPassword);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean userExists(String username) &#123;</span><br><span class="line">            return userDetailsRepository.userExists(username);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">            return userDetailsRepository.loadUserByUsername(username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实际执行委托给了UserDetailsRepository 来做。我们重复 章节3. 的动作进入登陆页面分别输入iching和123456 成功进入。</p>
<h4 id="3-5-数据库管理用户"><a href="#3-5-数据库管理用户" class="headerlink" title="3.5 数据库管理用户"></a>3.5 数据库管理用户</h4><p>经过以上的配置，相信聪明的你已经知道如何使用数据库来管理用户了 。只需要将 UserDetailsRepository 中的 users 属性替代为抽象的Dao接口就行了，无论你使用Jpa还是Mybatis来实现。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>今天我们对Spring Security 中的用户信息 UserDetails 相关进行的一些解读。并自定义了用户信息处理服务。相信你已经对在Spring Security中如何加载用户信息，如何扩展用户信息有所掌握了。后面我们会由浅入深慢慢解读Spring Security。</p>
<hr>
<h2 id="Spring-Boot-中的-Spring-Security-自动配置初探"><a href="#Spring-Boot-中的-Spring-Security-自动配置初探" class="headerlink" title="Spring Boot 中的 Spring Security 自动配置初探"></a>Spring Boot 中的 Spring Security 自动配置初探</h2><ol>
<li><p>前言<br>我们在前几篇对 Spring Security 的用户信息管理机制，密码机制进行了探讨。我们发现 Spring Security Starter相关的 Servlet 自动配置都在spring-boot-autoconfigure-2.1.9.RELEASE（当前 Spring Boot 版本为2.1.9.RELEASE） 模块的路径org.springframework.boot.autoconfigure.security.servlet 之下。其实官方提供的Starter组件的自动配置你都能在spring-boot-autoconfigure-2.1.9.RELEASE下找到。今天我们进一步来解密 Spring Security 在 Spring Boot 的配置和使用。</p>
</li>
<li><p>Spring Boot 下 Spring Security 的自动配置<br>我们可以通过 org.springframework.boot.autoconfigure.security.servlet 路径下找到 Spring Security 关于Servlet的自动配置类。我们来大致了解一下。</p>
</li>
</ol>
<p>2.1 SecurityAutoConfiguration</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure.security.servlet;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.SecurityDataConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.SecurityProperties;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.context.ApplicationEventPublisher;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.Import;</span><br><span class="line">import org.springframework.security.authentication.AuthenticationEventPublisher;</span><br><span class="line">import org.springframework.security.authentication.DefaultAuthenticationEventPublisher;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* &#123;@link EnableAutoConfiguration Auto-configuration&#125; for Spring Security.</span><br><span class="line">*</span><br><span class="line">* @author Dave Syer</span><br><span class="line">* @author Andy Wilkinson</span><br><span class="line">* @author Madhura Bhave</span><br><span class="line">* @since 1.0.0</span><br><span class="line">*&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(DefaultAuthenticationEventPublisher.class)</span><br><span class="line">@EnableConfigurationProperties(SecurityProperties.class)</span><br><span class="line">@Import(&#123; SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class,</span><br><span class="line">        SecurityDataConfiguration.class &#125;)</span><br><span class="line">public class SecurityAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(AuthenticationEventPublisher.class)</span><br><span class="line">    public DefaultAuthenticationEventPublisher authenticationEventPublisher(ApplicationEventPublisher publisher) &#123;</span><br><span class="line">        return new DefaultAuthenticationEventPublisher(publisher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecurityAutoConfiguration 顾名思义安全配置类。该类引入（@import）了 SpringBootWebSecurityConfiguration、WebSecurityEnablerConfiguration 和 SecurityDataConfiguration 三个配置类。 让这三个模块的类生效。是一个复合配置，是 Spring Security 自动配置最重要的一个类之一。 Spring Boot 自动配置经常使用这种方式以达到灵活配置的目的，这也是我们研究 Spring Security 自动配置的一个重要入口 同时 SecurityAutoConfiguration 还将 DefaultAuthenticationEventPublisher 作为默认的 AuthenticationEventPublisher 注入 Spring IoC 容器。如果你熟悉 Spring 中的事件机制你就会知道该类是一个 Spring 事件发布器。该类内置了一个HashMap&lt;String, Constructor&lt;? extends AbstractAuthenticationEvent&gt;&gt;维护了认证异常处理和对应异常事件处理逻辑的映射关系，比如账户过期异常 AccountExpiredException 对应认证过期事件AuthenticationFailureExpiredEvent ，也就是说发生不同认证的异常使用不同处理策略。</p>
<p>2.2 SpringBootWebSecurityConfiguration</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnMissingBean(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)</span><br><span class="line">public class SpringBootWebSecurityConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @Order(SecurityProperties.BASIC_AUTH_ORDER)</span><br><span class="line">    static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类是Spring Security 对 Spring Boot Servlet Web 应用的默认配置。核心在于WebSecurityConfigurerAdapter 适配器。从 @ConditionalOnMissingBean(WebSecurityConfigurerAdapter.class) 我们就能看出 WebSecurityConfigurerAdapter 是安全配置的核心。 默认情况下 DefaultConfigurerAdapter 将以SecurityProperties.BASIC_AUTH_ORDER（-5） 的顺序注入 Spring IoC 容器，这是个空实现。如果我们需要个性化可以通过继承 WebSecurityConfigurerAdapter 来实现。我们会在以后的博文重点介绍该类。</p>
<p>2.3 WebSecurityEnablerConfiguration</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnBean(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnMissingBean(name &#x3D; BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityEnablerConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该配置类会在SpringBootWebSecurityConfiguration 注入 Spring IoC 容器后启用 @EnableWebSecurity 注解。也就是说 WebSecurityEnablerConfiguration 目的仅仅就是在某些条件下激活 @EnableWebSecurity 注解。那么这个注解都有什么呢？</p>
<ol start="3">
<li>@EnableWebSecurity 注解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Retention(value &#x3D; java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value &#x3D; &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123; WebSecurityConfiguration.class,</span><br><span class="line">        SpringWebMvcImportSelector.class,</span><br><span class="line">        OAuth2ImportSelector.class &#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Controls debugging support for Spring Security. Default is false.</span><br><span class="line">    * @return if true, enables debug support with Spring Security</span><br><span class="line">    *&#x2F;</span><br><span class="line">    boolean debug() default false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>@Enable* 这类注解都是带配置导入的注解。通过导入一些配置来启用一些特定功能。 @EnableWebSecurity 导入了 WebSecurityConfiguration 、SpringWebMvcImportSelector 、OAuth2ImportSelector 以及启用了 @EnableGlobalAuthentication注解。</p>
<p>3.1 WebSecurityConfiguration<br>该配置类WebSecurityConfiguration使用一个WebSecurity对象基于用户指定的或者默认的安全配置，你可以通过继承 WebSecurityConfigurerAdapter 或者实现 WebSecurityConfigurer 来定制 WebSecurity 创建一个FilterChainProxy Bean来对用户请求进行安全过滤。这个FilterChainProxy的名称就是 WebSecurityEnablerConfiguration上的 BeanIds.SPRING_SECURITY_FILTER_CHAIN 也就是 springSecurityFilterChain,它是一个Filter，最终会被作为Servlet过滤器链中的一个Filter应用到Servlet容器中。安全处理的策略主要是过滤器的调用顺序。WebSecurityConfiguration 最终会通过 @EnableWebSecurity 应用到系统。</p>
<p>源码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.security.config.annotation.web.configuration;</span><br><span class="line"></span><br><span class="line">  import java.util.Collections;</span><br><span class="line">  import java.util.List;</span><br><span class="line">  import java.util.Map;</span><br><span class="line"></span><br><span class="line">  import javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line">  import org.springframework.beans.factory.BeanClassLoaderAware;</span><br><span class="line">  import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">  import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">  import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line">  import org.springframework.context.annotation.Bean;</span><br><span class="line">  import org.springframework.context.annotation.Configuration;</span><br><span class="line">  import org.springframework.context.annotation.DependsOn;</span><br><span class="line">  import org.springframework.context.annotation.ImportAware;</span><br><span class="line">  import org.springframework.core.OrderComparator;</span><br><span class="line">  import org.springframework.core.Ordered;</span><br><span class="line">  import org.springframework.core.annotation.AnnotationAttributes;</span><br><span class="line">  import org.springframework.core.annotation.AnnotationUtils;</span><br><span class="line">  import org.springframework.core.annotation.Order;</span><br><span class="line">  import org.springframework.core.type.AnnotationMetadata;</span><br><span class="line">  import org.springframework.security.access.expression.SecurityExpressionHandler;</span><br><span class="line">  import org.springframework.security.config.annotation.ObjectPostProcessor;</span><br><span class="line">  import org.springframework.security.config.annotation.SecurityConfigurer;</span><br><span class="line">  import org.springframework.security.config.annotation.web.WebSecurityConfigurer;</span><br><span class="line">  import org.springframework.security.config.annotation.web.builders.WebSecurity;</span><br><span class="line">  import org.springframework.security.context.DelegatingApplicationListener;</span><br><span class="line">  import org.springframework.security.web.FilterChainProxy;</span><br><span class="line">  import org.springframework.security.web.FilterInvocation;</span><br><span class="line">  import org.springframework.security.web.access.WebInvocationPrivilegeEvaluator;</span><br><span class="line">  import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Spring Web Security 的配置类 : </span><br><span class="line">   *  1. 使用一个 WebSecurity 对象基于安全配置创建一个 FilterChainProxy 对象来对用户请求进行安全过滤。 </span><br><span class="line">   *  2. 也会暴露诸如 安全SpEL表达式处理器 SecurityExpressionHandler 等一些类。</span><br><span class="line">   *   </span><br><span class="line">   * @see EnableWebSecurity</span><br><span class="line">   * @see WebSecurity</span><br><span class="line">   *</span><br><span class="line">   * @author Rob Winch</span><br><span class="line">   * @author Keesun Baik</span><br><span class="line">   * @since 3.2</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Configuration</span><br><span class="line">  public class WebSecurityConfiguration implements ImportAware, BeanClassLoaderAware &#123;</span><br><span class="line">      private WebSecurity webSecurity;</span><br><span class="line">   &#x2F;&#x2F; 是否启用了调试模式，来自注解 @EnableWebSecurity 的属性 debug，缺省值 false</span><br><span class="line">      private Boolean debugEnabled;</span><br><span class="line"></span><br><span class="line">      private List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers;</span><br><span class="line"></span><br><span class="line">      private ClassLoader beanClassLoader;</span><br><span class="line"></span><br><span class="line">      @Autowired(required &#x3D; false)</span><br><span class="line">      private ObjectPostProcessor&lt;Object&gt; objectObjectPostProcessor;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 代理监听器 应该时监听 DefaultAuthenticationEventPublisher 的一些处理策略</span><br><span class="line">     *&#x2F;   </span><br><span class="line">      @Bean</span><br><span class="line">      public static DelegatingApplicationListener delegatingApplicationListener() &#123;</span><br><span class="line">          return new DelegatingApplicationListener();</span><br><span class="line">      &#125;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      *</span><br><span class="line">      * 安全SpEL表达式处理器 SecurityExpressionHandler 缺省为一个 DefaultWebSecurityExpressionHandler</span><br><span class="line">      *&#x2F;   </span><br><span class="line">      @Bean</span><br><span class="line">      @DependsOn(AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line">      public SecurityExpressionHandler&lt;FilterInvocation&gt; webSecurityExpressionHandler() &#123;</span><br><span class="line">          return webSecurity.getExpressionHandler();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">       *  Spring Security 核心过滤器  Spring Security Filter Chain  , Bean ID 为 springSecurityFilterChain</span><br><span class="line">       * @return the &#123;@link Filter&#125; that represents the security filter chain</span><br><span class="line">       * @throws Exception</span><br><span class="line">       *&#x2F;</span><br><span class="line">      @Bean(name &#x3D; AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line">      public Filter springSecurityFilterChain() throws Exception &#123;</span><br><span class="line">          boolean hasConfigurers &#x3D; webSecurityConfigurers !&#x3D; null</span><br><span class="line">                  &amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class="line">          if (!hasConfigurers) &#123;</span><br><span class="line">              WebSecurityConfigurerAdapter adapter &#x3D; objectObjectPostProcessor</span><br><span class="line">                      .postProcess(new WebSecurityConfigurerAdapter() &#123;</span><br><span class="line">                      &#125;);</span><br><span class="line">              webSecurity.apply(adapter);</span><br><span class="line">          &#125;</span><br><span class="line">          return webSecurity.build();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 用于模板 如JSP Freemarker 的一些页面标签按钮控制支持</span><br><span class="line">       * Creates the &#123;@link WebInvocationPrivilegeEvaluator&#125; that is necessary for the JSP</span><br><span class="line">       * tag support.</span><br><span class="line">       * @return the &#123;@link WebInvocationPrivilegeEvaluator&#125;</span><br><span class="line">       * @throws Exception</span><br><span class="line">       *&#x2F;</span><br><span class="line">      @Bean</span><br><span class="line">      @DependsOn(AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line">      public WebInvocationPrivilegeEvaluator privilegeEvaluator() throws Exception &#123;</span><br><span class="line">          return webSecurity.getPrivilegeEvaluator();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 用于创建web configuration的SecurityConfigurer实例，</span><br><span class="line">     * 注意该参数通过@Value(...)方式注入，对应的bean autowiredWebSecurityConfigurersIgnoreParents</span><br><span class="line">     * 也在该类中定义</span><br><span class="line">     *</span><br><span class="line">       * @param objectPostProcessor the &#123;@link ObjectPostProcessor&#125; used to create a</span><br><span class="line">       * &#123;@link WebSecurity&#125; instance</span><br><span class="line">       * @param webSecurityConfigurers the</span><br><span class="line">       * &#123;@code &lt;SecurityConfigurer&lt;FilterChainProxy, WebSecurityBuilder&gt;&#125; instances used to</span><br><span class="line">       * create the web configuration</span><br><span class="line">       * @throws Exception</span><br><span class="line">       *&#x2F;</span><br><span class="line">      @Autowired(required &#x3D; false)</span><br><span class="line">      public void setFilterChainProxySecurityConfigurer(</span><br><span class="line">              ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span><br><span class="line">              @Value(&quot;#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;&quot;) List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span><br><span class="line">              throws Exception &#123;</span><br><span class="line">          webSecurity &#x3D; objectPostProcessor</span><br><span class="line">                  .postProcess(new WebSecurity(objectPostProcessor));</span><br><span class="line">          if (debugEnabled !&#x3D; null) &#123;</span><br><span class="line">              webSecurity.debug(debugEnabled);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Collections.sort(webSecurityConfigurers, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line"></span><br><span class="line">          Integer previousOrder &#x3D; null;</span><br><span class="line">          Object previousConfig &#x3D; null;</span><br><span class="line">          for (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class="line">              Integer order &#x3D; AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class="line">              if (previousOrder !&#x3D; null &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class="line">                  throw new IllegalStateException(</span><br><span class="line">                          &quot;@Order on WebSecurityConfigurers must be unique. Order of &quot;</span><br><span class="line">                                  + order + &quot; was already used on &quot; + previousConfig + &quot;, so it cannot be used on &quot;</span><br><span class="line">                                  + config + &quot; too.&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              previousOrder &#x3D; order;</span><br><span class="line">              previousConfig &#x3D; config;</span><br><span class="line">          &#125;</span><br><span class="line">          for (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class="line">              webSecurity.apply(webSecurityConfigurer);</span><br><span class="line">          &#125;</span><br><span class="line">          this.webSecurityConfigurers &#x3D; webSecurityConfigurers;</span><br><span class="line">      &#125;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * 从当前bean容器中获取所有的WebSecurityConfigurer bean。</span><br><span class="line">      * 这些WebSecurityConfigurer通常是由开发人员实现的配置类，并且继承自WebSecurityConfigurerAdapter</span><br><span class="line">      *  </span><br><span class="line">      *&#x2F;   </span><br><span class="line">      @Bean</span><br><span class="line">      public static AutowiredWebSecurityConfigurersIgnoreParents autowiredWebSecurityConfigurersIgnoreParents(</span><br><span class="line">              ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">          return new AutowiredWebSecurityConfigurersIgnoreParents(beanFactory);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">       * A custom verision of the Spring provided AnnotationAwareOrderComparator that uses</span><br><span class="line">       * &#123;@link AnnotationUtils#findAnnotation(Class, Class)&#125; to look on super class</span><br><span class="line">       * instances for the &#123;@link Order&#125; annotation.</span><br><span class="line">       *</span><br><span class="line">       * @author Rob Winch</span><br><span class="line">       * @since 3.2</span><br><span class="line">       *&#x2F;</span><br><span class="line">      private static class AnnotationAwareOrderComparator extends OrderComparator &#123;</span><br><span class="line">          private static final AnnotationAwareOrderComparator INSTANCE &#x3D; new AnnotationAwareOrderComparator();</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected int getOrder(Object obj) &#123;</span><br><span class="line">              return lookupOrder(obj);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          private static int lookupOrder(Object obj) &#123;</span><br><span class="line">              if (obj instanceof Ordered) &#123;</span><br><span class="line">                  return ((Ordered) obj).getOrder();</span><br><span class="line">              &#125;</span><br><span class="line">              if (obj !&#x3D; null) &#123;</span><br><span class="line">                  Class&lt;?&gt; clazz &#x3D; (obj instanceof Class ? (Class&lt;?&gt;) obj : obj.getClass());</span><br><span class="line">                  Order order &#x3D; AnnotationUtils.findAnnotation(clazz, Order.class);</span><br><span class="line">                  if (order !&#x3D; null) &#123;</span><br><span class="line">                      return order.value();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">       * 要是为了获取注解 @EnableWebSecurity 的属性 debugEnabled</span><br><span class="line">       *</span><br><span class="line">       * @see org.springframework.context.annotation.ImportAware#setImportMetadata(org.</span><br><span class="line">       * springframework.core.type.AnnotationMetadata)</span><br><span class="line">       *&#x2F;</span><br><span class="line">      public void setImportMetadata(AnnotationMetadata importMetadata) &#123;</span><br><span class="line">          Map&lt;String, Object&gt; enableWebSecurityAttrMap &#x3D; importMetadata</span><br><span class="line">                  .getAnnotationAttributes(EnableWebSecurity.class.getName());</span><br><span class="line">          AnnotationAttributes enableWebSecurityAttrs &#x3D; AnnotationAttributes</span><br><span class="line">                  .fromMap(enableWebSecurityAttrMap);</span><br><span class="line">          debugEnabled &#x3D; enableWebSecurityAttrs.getBoolean(&quot;debug&quot;);</span><br><span class="line">          if (webSecurity !&#x3D; null) &#123;</span><br><span class="line">              webSecurity.debug(debugEnabled);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">       * (non-Javadoc)</span><br><span class="line">       *</span><br><span class="line">       * @see</span><br><span class="line">       * org.springframework.beans.factory.BeanClassLoaderAware#setBeanClassLoader(java.</span><br><span class="line">       * lang.ClassLoader)</span><br><span class="line">       *&#x2F;</span><br><span class="line">      public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">          this.beanClassLoader &#x3D; classLoader;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>3.2 SpringWebMvcImportSelector<br>该类是为了对 Spring Mvc 进行支持的。一旦发现应用使用 Spring Mvc 的核心前置控制器 DispatcherServlet 就会引入 WebMvcSecurityConfiguration 。主要是为了适配 Spring Mvc 。</p>
<p>3.3 OAuth2ImportSelector<br>该类是为了对 OAuth2.0 开放授权协议进行支持。ClientRegistration 如果被引用，具体点也就是 spring-security-oauth2 模块被启用（引入依赖jar）时。会启用 OAuth2 客户端配置 OAuth2ClientConfiguration 。</p>
<p>3.4 @EnableGlobalAuthentication<br>这个类主要引入了 AuthenticationConfiguration 目的主要为了构造 认证管理器 AuthenticationManager 。AuthenticationManager 十分重要后面我们会进行专门的分析。</p>
<ol start="4">
<li>SecurityFilterAutoConfiguration<br>我们在 org.springframework.boot.autoconfigure.security.servlet 路径下还发现了一个配置类 SecurityFilterAutoConfiguration 。该类用于向Servlet容器注册一个名称为securityFilterChainRegistration的bean, 实现类是DelegatingFilterProxyRegistrationBean。该 bean 的目的是注册另外一个 Servlet Filter Bean 到 Servlet 容器,实现类为 DelegatingFilterProxy 。DelegatingFilterProxy 其实是一个代理过滤器，它被 Servlet 容器用于处理请求时，会将任务委托给指定给自己另外一个Filter bean。对于 SecurityFilterAutoConfiguration,来讲，这个被代理的Filter bean的名字为 springSecurityFilterChain , 也就是我们上面提到过的 Spring Security Web提供的用于请求安全处理的Filter bean，其实现类是 FilterChainProxy。</li>
</ol>
<p>相关的源码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure.security.servlet;</span><br><span class="line"></span><br><span class="line">import java.util.EnumSet;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">import javax.servlet.DispatcherType;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.AutoConfigureAfter;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.SecurityProperties;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.boot.web.servlet.DelegatingFilterProxyRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;</span><br><span class="line">import org.springframework.security.config.http.SessionCreationPolicy;</span><br><span class="line">import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">&#x2F;&#x2F; 仅在 Servlet 环境下生效</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)</span><br><span class="line">&#x2F;&#x2F; 确保安全属性配置信息被加载并以bean形式被注册到容器</span><br><span class="line">@EnableConfigurationProperties(SecurityProperties.class)</span><br><span class="line">&#x2F;&#x2F; 仅在特定类存在于 classpath 上时才生效</span><br><span class="line">@ConditionalOnClass(&#123; AbstractSecurityWebApplicationInitializer.class,</span><br><span class="line">        SessionCreationPolicy.class &#125;)</span><br><span class="line">&#x2F;&#x2F; 指定该配置类在  SecurityAutoConfiguration 配置类应用之后应用       </span><br><span class="line">@AutoConfigureAfter(SecurityAutoConfiguration.class)</span><br><span class="line">public class SecurityFilterAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 要注册到 Servlet 容器的 DelegatingFilterProxy Filter的 </span><br><span class="line">    &#x2F;&#x2F; 目标代理Filter bean的名称 ：springSecurityFilterChain</span><br><span class="line">    private static final String DEFAULT_FILTER_NAME &#x3D; </span><br><span class="line">            AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义一个 bean securityFilterChainRegistration, </span><br><span class="line">    &#x2F;&#x2F; 该 bean 的目的是注册另外一个 bean 到 Servlet 容器 : 实现类为 DelegatingFilterProxy 的一个 Servlet Filter</span><br><span class="line">    &#x2F;&#x2F; 该 DelegatingFilterProxy Filter 其实是一个代理过滤器，它被 Servlet 容器用于匹配特定URL模式的请求，</span><br><span class="line">    &#x2F;&#x2F; 而它会将任务委托给指定给自己的名字为 springSecurityFilterChain 的 Filter, 也就是 Spring Security Web</span><br><span class="line">    &#x2F;&#x2F; 提供的用于请求安全处理的一个 Filter bean，其实现类是 FilterChainProxy</span><br><span class="line">    &#x2F;&#x2F; (可以将 1 个 FilterChainProxy 理解为 1 HttpFirewall + n SecurityFilterChain)</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnBean(name &#x3D; DEFAULT_FILTER_NAME)</span><br><span class="line">    public DelegatingFilterProxyRegistrationBean securityFilterChainRegistration(</span><br><span class="line">            SecurityProperties securityProperties) &#123;</span><br><span class="line">        DelegatingFilterProxyRegistrationBean registration &#x3D; new DelegatingFilterProxyRegistrationBean(</span><br><span class="line">                DEFAULT_FILTER_NAME);</span><br><span class="line">        registration.setOrder(securityProperties.getFilter().getOrder());</span><br><span class="line">        registration.setDispatcherTypes(getDispatcherTypes(securityProperties));</span><br><span class="line">        return registration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private EnumSet&lt;DispatcherType&gt; getDispatcherTypes(</span><br><span class="line">            SecurityProperties securityProperties) &#123;</span><br><span class="line">        if (securityProperties.getFilter().getDispatcherTypes() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return securityProperties.getFilter().getDispatcherTypes().stream()</span><br><span class="line">                .map((type) -&gt; DispatcherType.valueOf(type.name())).collect(Collectors</span><br><span class="line">                        .collectingAndThen(Collectors.toSet(), EnumSet::copyOf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="路径Uri中的-Ant-风格"><a href="#路径Uri中的-Ant-风格" class="headerlink" title="路径Uri中的 Ant 风格"></a>路径Uri中的 Ant 风格</h2><ol>
<li><p>前言<br>我们经常在读到一些文章会遇到uri 支持 Ant 风格 ，而且这个东西在 Spring MVC 和 Spring Security 中经常被提及。这到底是什么呢？今天我们来学习了解一下。这对我们学习 Spring MVC 和 Spring Security 十分必要。</p>
</li>
<li><p>Ant 风格<br>说白了 Ant 风格就是一种路径匹配表达式。主要用来对uri的匹配。其实跟正则表达式作用是一样的，只不过正则表达式适用面更加宽泛，Ant仅仅用于路径匹配。</p>
</li>
<li><p>Ant 通配符<br>Ant 中的通配符有三种：</p>
</li>
</ol>
<p>? 匹配任何单字符</p>
<ul>
<li>匹配0或者任意数量的 字符</li>
</ul>
<p>** 匹配0或者更多的 目录</p>
<p>这里注意了单个* 是在一个目录内进行匹配。 而** 是可以匹配多个目录，一定不要迷糊。</p>
<p>3.1 Ant 通配符示例<br>通配符    示例    说明<br>?    /ant/p?ttern    匹配项目根路径下 /ant/pattern 和 /ant/pXttern,但是不包括/ant/pttern</p>
<ul>
<li>/ant/*.html    匹配项目根路径下所有在ant路径下的.html文件</li>
<li>/ant/*/path    /ant/path、/ant/a/path、/ant/bxx/path 都匹配，不匹配 /ant/axx/bxx/path</li>
<li><ul>
<li>/ant/**/path    /ant/path、/ant/a/path、/ant/bxx/path 、/ant/axx/bxx/path都匹配</li>
</ul>
</li>
</ul>
<p>3.2 最长匹配原则<br>从 3.1 可以看出 * 和 <em>* 是有冲突的情况存在的。为了解决这种冲突就规定了最长匹配原则(has more characters)。 一旦一个uri 同时符合两个Ant匹配那么走匹配规则字符最多的。为什么走最长？因为字符越长信息越多就越具体。比如 /ant/a/path 同时满足 /**/path 和 /ant/</em>/path 那么走/ant/*/path</p>
<ol start="4">
<li>Spring MVC 和 Spring Security 中的 Ant 风格<br>接下来我们来看看 Spring MVC 和 Spring Security 下的 Ant风格。</li>
</ol>
<p>4.1 Spring MVC 中的 Ant 风格<br>这里也提一下在 Spring MVC 中 我们在控制器中写如下接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* ant style test.</span><br><span class="line">*</span><br><span class="line">* @return the string</span><br><span class="line">*&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;?ant&quot;)</span><br><span class="line">public String ant() &#123;</span><br><span class="line"></span><br><span class="line">    return &quot;ant&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你使用任意合法uri字符替代? 发现都可以匹配，比如/bant 。 还有Spring MVC 的一些 过滤器注册、格式化器注册都用到了 Ant 风格。</p>
<p>4.2 Spring Security 中的 Ant 风格<br>在 Spring Security 中 WebSecurityConfigurerAdapter 中的你可以通过如下配置进行路由权限访问控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void configureGlobal(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception &#123;</span><br><span class="line">        authenticationManagerBuilder.inMemoryAuthentication().withUser(&quot;admin&quot;).password(&quot;admin&quot;).roles(&quot;USER&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                &#x2F;&#x2F;放行静态资源 首页</span><br><span class="line">                .antMatchers(&quot;&#x2F;index.html&quot;,&quot;&#x2F;static&#x2F;**&quot;).permitAll()</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 Spring Security 的配置中在 antMatchers 方法中通过 Ant 通配符来控制了资源的访问权限</p>
<hr>
<h2 id="自定义配置类入口WebSecurityConfigurerAdapter"><a href="#自定义配置类入口WebSecurityConfigurerAdapter" class="headerlink" title="自定义配置类入口WebSecurityConfigurerAdapter"></a>自定义配置类入口WebSecurityConfigurerAdapter</h2><ol>
<li><p>前言<br>今天我们要进一步的的学习如何自定义配置 Spring Security 我们已经多次提到了 WebSecurityConfigurerAdapter ，而且我们知道 Spring Boot 中的自动配置实际上是通过自动配置包下的 SecurityAutoConfiguration 总配置类上导入的 Spring Boot Web 安全配置类 SpringBootWebSecurityConfiguration 来配置的。所以我们就拿它开刀。如果还是一头雾水建议通过 <a href="https://felord.cn" target="_blank" rel="noopener">https://felord.cn</a> 查看 Spring Security 实战 。</p>
</li>
<li><p>自定义 Spring Boot Web 安全配置类<br>我们使用我们最擅长的 Ctrl + C 、Ctrl + V 抄源码中的 SpringBootWebSecurityConfiguration ，命名为我们自定义的 CustomSpringBootWebSecurityConfiguration :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line">public class CustomSpringBootWebSecurityConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @Order(SecurityProperties.BASIC_AUTH_ORDER)</span><br><span class="line">    static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">            super.configure(auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">            super.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">            super.configure(http);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信已经有人注意到了上面 DefaultConfigurerAdapter 中我覆写（@Override）了三个方法，我们一般会通过自定义配置这三个方法来自定义我们的安全访问策略。</p>
</li>
</ol>
<p>2.1 认证管理器配置方法<br>void configure(AuthenticationManagerBuilder auth) 用来配置认证管理器AuthenticationManager。说白了就是所有 UserDetails 相关的它都管，包含 PasswordEncoder 密码机。如果你不清楚可以通过 Spring Security 中的 UserDetail 进行了解。本文对 AuthenticationManager 不做具体分析讲解，后面会有专门的文章来讲这个东西 。 可通过 Spring Security 实战系列 进行学习。</p>
<p>2.2 核心过滤器配置方法<br>void configure(WebSecurity web) 用来配置 WebSecurity 。而 WebSecurity 是基于 Servlet Filter 用来配置 springSecurityFilterChain 。而 springSecurityFilterChain 又被委托给了 Spring Security 核心过滤器 Bean DelegatingFilterProxy 。 相关逻辑你可以在 WebSecurityConfiguration 中找到。我们一般不会过多来自定义 WebSecurity , 使用较多的使其ignoring() 方法用来忽略 Spring Security 对静态资源的控制。</p>
<p>2.3 安全过滤器链配置方法<br>void configure(HttpSecurity http) 这个是我们使用最多的，用来配置 HttpSecurity 。 HttpSecurity 用于构建一个安全过滤器链 SecurityFilterChain 。SecurityFilterChain 最终被注入核心过滤器 。 HttpSecurity 有许多我们需要的配置。我们可以通过它来进行自定义安全访问策略。所以我们单独开一章来讲解这个东西。</p>
<ol start="3">
<li>HttpSecurity 配置<br>HttpSecurity 是后面几篇文章的重点，我们将实际操作它来实现一些实用功能。所以本文要着重介绍它。</li>
</ol>
<p>3.1 默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    logger.debug(&quot;Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).&quot;);</span><br><span class="line"></span><br><span class="line">    http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">        .formLogin().and()</span><br><span class="line">        .httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是 Spring Security 在 Spring Boot 中的默认配置。通过以上的配置，你的应用具备了一下的功能：</p>
<p>所有的请求访问都需要被授权。<br>使用 form 表单进行登陆(默认路径为/login)，也就是前几篇我们见到的登录页。<br>防止 CSRF 攻击、 XSS 攻击。<br>启用 HTTP Basic 认证<br>3.2 常用方法解读<br>HttpSecurity 使用了builder 的构建方式来灵活制定访问策略。最早基于 XML 标签对 HttpSecurity 进行配置。现在大部分使用 javaConfig方式。常用的方法解读如下：<br>方法    说明<br>openidLogin()    用于基于 OpenId 的验证<br>headers()    将安全标头添加到响应,比如说简单的 XSS 保护<br>cors()    配置跨域资源共享（ CORS ）<br>sessionManagement()    允许配置会话管理<br>portMapper()    允许配置一个PortMapper(HttpSecurity#(getSharedObject(class)))，其他提供SecurityConfigurer的对象使用 PortMapper 从 HTTP 重定向到 HTTPS 或者从 HTTPS 重定向到 HTTP。默认情况下，Spring Security使用一个PortMapperImpl映射 HTTP 端口8080到 HTTPS 端口8443，HTTP 端口80到 HTTPS 端口443<br>jee()    配置基于容器的预认证。 在这种情况下，认证由Servlet容器管理<br>x509()    配置基于x509的认证<br>rememberMe    允许配置“记住我”的验证<br>authorizeRequests()    允许基于使用HttpServletRequest限制访问<br>requestCache()    允许配置请求缓存<br>exceptionHandling()    允许配置错误处理<br>securityContext()    在HttpServletRequests之间的SecurityContextHolder上设置SecurityContext的管理。 当使用WebSecurityConfigurerAdapter时，这将自动应用<br>servletApi()    将HttpServletRequest方法与在其上找到的值集成到SecurityContext中。 当使用WebSecurityConfigurerAdapter时，这将自动应用<br>csrf()    添加 CSRF 支持，使用WebSecurityConfigurerAdapter时，默认启用<br>logout()    添加退出登录支持。当使用WebSecurityConfigurerAdapter时，这将自动应用。默认情况是，访问URL”/ logout”，使HTTP Session无效来清除用户，清除已配置的任何#rememberMe()身份验证，清除SecurityContextHolder，然后重定向到”/login?success”<br>anonymous()    允许配置匿名用户的表示方法。 当与WebSecurityConfigurerAdapter结合使用时，这将自动应用。 默认情况下，匿名用户将使用org.springframework.security.authentication.AnonymousAuthenticationToken表示，并包含角色 “ROLE_ANONYMOUS”<br>formLogin()    指定支持基于表单的身份验证。如果未指定FormLoginConfigurer#loginPage(String)，则将生成默认登录页面<br>oauth2Login()    根据外部OAuth 2.0或OpenID Connect 1.0提供程序配置身份验证<br>requiresChannel()    配置通道安全。为了使该配置有用，必须提供至少一个到所需信道的映射<br>httpBasic()    配置 Http Basic 验证<br>addFilterBefore()    在指定的Filter类之前添加过滤器<br>addFilterAt()    在指定的Filter类的位置添加过滤器<br>addFilterAfter()    在指定的Filter类的之后添加过滤器<br>and()    连接以上策略的连接器，用来组合安全策略。实际上就是”而且”的意思</p>
<hr>
<h2 id="玩转自定义登录"><a href="#玩转自定义登录" class="headerlink" title="玩转自定义登录"></a>玩转自定义登录</h2><ol>
<li><p>前言<br>前面的关于 Spring Security 相关的文章只是一个预热。为了接下来更好的实战，如果你错过了请从 Spring Security 实战系列 开始。安全访问的第一步就是认证（Authentication），认证的第一步就是登录。今天我们要通过对 Spring Security 的自定义，来设计一个可扩展，可伸缩的 form 登录功能。</p>
</li>
<li><p>form 登录的流程<br>下面是 form 登录的基本流程：<br>客户端发起请求，服务器端返回成功信息或返回失败信息<br>只要是 form 登录基本都能转化为上面的流程。接下来我们看看 Spring Security 是如何处理的。</p>
</li>
<li><p>Spring Security 中的登录<br>昨天 Spring Security 实战干货：自定义配置类入口WebSecurityConfigurerAdapter 中已经讲到了我们通常的自定义访问控制主要是通过 HttpSecurity 来构建的。默认它提供了三种登录方式：</p>
</li>
</ol>
<p>formLogin() 普通表单登录<br>oauth2Login() 基于 OAuth2.0 认证/授权协议<br>openidLogin() 基于 OpenID 身份认证规范<br>以上三种方式统统是 AbstractAuthenticationFilterConfigurer 实现的，</p>
<ol start="4">
<li>HttpSecurity 中的 form 表单登录<br>启用表单登录通过两种方式一种是通过 HttpSecurity 的 apply(C configurer) 方法自己构造一个 AbstractAuthenticationFilterConfigurer 的实现，这种是比较高级的玩法。 另一种是我们常见的使用 HttpSecurity 的 formLogin() 方法来自定义 FormLoginConfigurer 。我们先搞一下比较常规的第二种。</li>
</ol>
<p>4.1 FormLoginConfigurer<br>该类是 form 表单登录的配置类。它提供了一些我们常用的配置方法：</p>
<p>loginPage(String loginPage) : 登录 页面而并不是接口，对于前后分离模式需要我们进行改造 默认为 /login。<br>loginProcessingUrl(String loginProcessingUrl) 实际表单向后台提交用户信息的 Action，再由过滤器UsernamePasswordAuthenticationFilter 拦截处理，该 Action 其实不会处理任何逻辑。<br>usernameParameter(String usernameParameter) 用来自定义用户参数名，默认 username 。<br>passwordParameter(String passwordParameter) 用来自定义用户密码名，默认 password<br>failureUrl(String authenticationFailureUrl) 登录失败后会重定向到此路径， 一般前后分离不会使用它。<br>failureForwardUrl(String forwardUrl) 登录失败会转发到此， 一般前后分离用到它。 可定义一个 Controller （控制器）来处理返回值,但是要注意 RequestMethod。<br>defaultSuccessUrl(String defaultSuccessUrl, boolean alwaysUse) 默认登陆成功后跳转到此 ，如果 alwaysUse 为 true 只要进行认证流程而且成功，会一直跳转到此。一般推荐默认值 false<br>successForwardUrl(String forwardUrl) 效果等同于上面 defaultSuccessUrl 的 alwaysUse 为 true 但是要注意 RequestMethod。<br>successHandler(AuthenticationSuccessHandler successHandler) 自定义认证成功处理器，可替代上面所有的 success 方式<br>failureHandler(AuthenticationFailureHandler authenticationFailureHandler) 自定义失败处理器，可替代上面所有的 failure 方式<br>permitAll(boolean permitAll) form 表单登录是否放开<br>知道了这些我们就能来搞个定制化的登录了。</p>
<ol start="5">
<li>Spring Security 聚合登录 实战<br>接下来是我们最激动人心的实战登录操作。 有疑问的可认真阅读 Spring 实战 的一系列预热文章。</li>
</ol>
<p>5.1 简单需求<br>我们的接口访问都要通过认证，登陆错误后返回错误信息（json），成功后前台可以获取到对应数据库用户信息（json）（实战中记得脱敏）。</p>
<p>我们定义处理成功失败的控制器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">public class LoginController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private SysUserService sysUserService;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 登录失败返回 401 以及提示信息.</span><br><span class="line">    *</span><br><span class="line">    * @return the rest</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @PostMapping(&quot;&#x2F;failure&quot;)</span><br><span class="line">    public Rest loginFailure() &#123;</span><br><span class="line"></span><br><span class="line">        return RestBody.failure(HttpStatus.UNAUTHORIZED.value(), &quot;登录失败了，老哥&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 登录成功后拿到个人信息.</span><br><span class="line">    *</span><br><span class="line">    * @return the rest</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @PostMapping(&quot;&#x2F;success&quot;)</span><br><span class="line">    public Rest loginSuccess() &#123;</span><br><span class="line">        &#x2F;&#x2F; 登录成功后用户的认证信息 UserDetails会存在 安全上下文寄存器 SecurityContextHolder 中</span><br><span class="line">        User principal &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        String username &#x3D; principal.getUsername();</span><br><span class="line">        SysUser sysUser &#x3D; sysUserService.queryByUsername(username);</span><br><span class="line">        &#x2F;&#x2F; 脱敏</span><br><span class="line">        sysUser.setEncodePassword(&quot;[PROTECT]&quot;);</span><br><span class="line">        return RestBody.okData(sysUser,&quot;登录成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 我们自定义配置覆写 void configure(HttpSecurity http) 方法进行如下配置（这里需要禁用crsf）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line">public class CustomSpringBootWebSecurityConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @Order(SecurityProperties.BASIC_AUTH_ORDER)</span><br><span class="line">    static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">            super.configure(auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">            super.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">            http.csrf().disable()</span><br><span class="line">                    .cors()</span><br><span class="line">                    .and()</span><br><span class="line">                    .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(&quot;&#x2F;process&quot;)</span><br><span class="line">                    .successForwardUrl(&quot;&#x2F;login&#x2F;success&quot;).</span><br><span class="line">                    failureForwardUrl(&quot;&#x2F;login&#x2F;failure&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Postman 或者其它工具进行 Post 方式的表单提交 <a href="http://localhost:8080/process?username=iching&amp;password=123456" target="_blank" rel="noopener">http://localhost:8080/process?username=iching&amp;password=123456</a> 会返回用户信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;httpStatus&quot;: 200,</span><br><span class="line">      &quot;data&quot;: &#123;</span><br><span class="line">          &quot;userId&quot;: 1,</span><br><span class="line">          &quot;username&quot;: &quot;iching&quot;,</span><br><span class="line">          &quot;encodePassword&quot;: &quot;[PROTECT]&quot;,</span><br><span class="line">          &quot;age&quot;: 18</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;msg&quot;: &quot;登录成功&quot;,</span><br><span class="line">      &quot;identifier&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>把密码修改为其它值再次请求认证失败后 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;httpStatus&quot;: 401,</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;msg&quot;: &quot;登录失败了&quot;,</span><br><span class="line">    &quot;identifier&quot;: &quot;-9999&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>多种登录方式并存的实现<br>就这么完了了么？现在登录的花样繁多。常规的就有短信、邮箱、扫码 ，第三方是以后我要讲的不在今天范围之内。 如何应对想法多的产品经理？ 我们来搞一个可扩展各种姿势的登录方式。我们在上面 2. form 登录的流程 中的 用户 和 判定 之间增加一个适配器来适配即可。 我们知道这个所谓的 判定就是 UsernamePasswordAuthenticationFilter 。</li>
</ol>
<p>我们只需要保证 uri 为上面配置的/process 并且能够通过 getParameter(String name) 获取用户名和密码即可 。</p>
<p>我突然觉得可以模仿 DelegatingPasswordEncoder 的搞法， 维护一个注册表执行不同的处理策略。当然我们要实现一个 GenericFilterBean 在 UsernamePasswordAuthenticationFilter 之前执行。同时制定登录的策略。</p>
<p>6.1 登录方式定义<br>定义登录方式枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum LoginTypeEnum &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 原始登录方式.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    FORM,</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Json 提交.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    JSON,</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 验证码.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    CAPTCHA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.2 定义前置处理器接口<br>定义前置处理器接口用来处理接收的各种特色的登录参数 并处理具体的逻辑。这个借口其实有点随意 ，重要的是你要学会思路。我实现了一个 默认的 form’ 表单登录 和 通过RequestBody放入json` 的两种方式，篇幅限制这里就不展示了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface LoginPostProcessor &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 获取 登录类型</span><br><span class="line">    *</span><br><span class="line">    * @return the type</span><br><span class="line">    *&#x2F;</span><br><span class="line">    LoginTypeEnum getLoginTypeEnum();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 获取用户名</span><br><span class="line">    *</span><br><span class="line">    * @param request the request</span><br><span class="line">    * @return the string</span><br><span class="line">    *&#x2F;</span><br><span class="line">    String obtainUsername(ServletRequest request);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 获取密码</span><br><span class="line">    *</span><br><span class="line">    * @param request the request</span><br><span class="line">    * @return the string</span><br><span class="line">    *&#x2F;</span><br><span class="line">    String obtainPassword(ServletRequest request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.3 实现登录前置处理过滤器<br>该过滤器维护了 LoginPostProcessor 映射表。 通过前端来判定登录方式进行策略上的预处理，最终还是会交给 UsernamePasswordAuthenticationFilter 。通过 HttpSecurity 的 addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)方法进行前置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 预登录控制器</span><br><span class="line">*&#x2F;</span><br><span class="line">public class PreLoginFilter extends GenericFilterBean &#123;</span><br><span class="line">    private static final String LOGIN_TYPE_KEY &#x3D; &quot;login_type&quot;;</span><br><span class="line"></span><br><span class="line">    private RequestMatcher requiresAuthenticationRequestMatcher;</span><br><span class="line">    private Map&lt;LoginTypeEnum, LoginPostProcessor&gt; processors &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public PreLoginFilter(String loginProcessingUrl, Collection&lt;LoginPostProcessor&gt; loginPostProcessors) &#123;</span><br><span class="line">        Assert.notNull(loginProcessingUrl, &quot;loginProcessingUrl must not be null&quot;);</span><br><span class="line">        requiresAuthenticationRequestMatcher &#x3D; new AntPathRequestMatcher(loginProcessingUrl, &quot;POST&quot;);</span><br><span class="line">        LoginPostProcessor loginPostProcessor &#x3D; defaultLoginPostProcessor();</span><br><span class="line">        processors.put(loginPostProcessor.getLoginTypeEnum(), loginPostProcessor);</span><br><span class="line"></span><br><span class="line">        if (!CollectionUtils.isEmpty(loginPostProcessors)) &#123;</span><br><span class="line">            loginPostProcessors.forEach(element -&gt; processors.put(element.getLoginTypeEnum(), element));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LoginTypeEnum getTypeFromReq(ServletRequest request) &#123;</span><br><span class="line">        String parameter &#x3D; request.getParameter(LOGIN_TYPE_KEY);</span><br><span class="line"></span><br><span class="line">        int i &#x3D; Integer.parseInt(parameter);</span><br><span class="line">        LoginTypeEnum[] values &#x3D; LoginTypeEnum.values();</span><br><span class="line">        return values[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 默认还是Form .</span><br><span class="line">    *</span><br><span class="line">    * @return the login post processor</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private LoginPostProcessor defaultLoginPostProcessor() &#123;</span><br><span class="line">        return new LoginPostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public LoginTypeEnum getLoginTypeEnum() &#123;</span><br><span class="line"></span><br><span class="line">                return LoginTypeEnum.FORM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public String obtainUsername(ServletRequest request) &#123;</span><br><span class="line">                return request.getParameter(SPRING_SECURITY_FORM_USERNAME_KEY);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public String obtainPassword(ServletRequest request) &#123;</span><br><span class="line">                return request.getParameter(SPRING_SECURITY_FORM_PASSWORD_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        ParameterRequestWrapper parameterRequestWrapper &#x3D; new ParameterRequestWrapper((HttpServletRequest) request);</span><br><span class="line">        if (requiresAuthenticationRequestMatcher.matches((HttpServletRequest) request)) &#123;</span><br><span class="line"></span><br><span class="line">            LoginTypeEnum typeFromReq &#x3D; getTypeFromReq(request);</span><br><span class="line"></span><br><span class="line">            LoginPostProcessor loginPostProcessor &#x3D; processors.get(typeFromReq);</span><br><span class="line"></span><br><span class="line">            String username &#x3D; loginPostProcessor.obtainUsername(request);</span><br><span class="line">            String password &#x3D; loginPostProcessor.obtainPassword(request);</span><br><span class="line"></span><br><span class="line">            parameterRequestWrapper.setAttribute(SPRING_SECURITY_FORM_USERNAME_KEY, username);</span><br><span class="line">            parameterRequestWrapper.setAttribute(SPRING_SECURITY_FORM_PASSWORD_KEY, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain.doFilter(parameterRequestWrapper, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.4 验证<br>通过 POST 表单提交方式 <a href="http://localhost:8080/process?username=Felordcn&amp;password=12345&amp;login_type=0" target="_blank" rel="noopener">http://localhost:8080/process?username=Felordcn&amp;password=12345&amp;login_type=0</a> 可以请求成功<br>更多的方式 只需要实现接口 LoginPostProcessor 注入 PreLoginFilter</p>
<hr>
<h2 id="内置-Filter-全解析"><a href="#内置-Filter-全解析" class="headerlink" title="内置 Filter 全解析"></a>内置 Filter 全解析</h2><ol>
<li>前言<br>上一文我们使用 Spring Security 实现了各种登录聚合的场面。其中我们是通过在 UsernamePasswordAuthenticationFilter 之前一个自定义的过滤器实现的。我怎么知道自定义过滤器要加在 UsernamePasswordAuthenticationFilter 之前。我在这个系列开篇说了 Spring Security 权限控制的一个核心关键就是 过滤器链 ，这些过滤器如下图进行过滤传递，甚至比这个更复杂！这只是一个最小单元。<br>request handlerchain handler result</li>
</ol>
<p>Spring Security 内置了一些过滤器，他们各有各的本事。如果你掌握了这些过滤器，很多实际开发中的需求和问题都很容易解决。今天我们来见识一下这些内置的过滤器。</p>
<ol start="2">
<li>内置过滤器初始化<br>在 Spring Security 初始化核心过滤器时 HttpSecurity 会通过将 Spring Security 内置的一些过滤器以 FilterComparator 提供的规则进行比较按照比较结果进行排序注册。</li>
</ol>
<p>2.1 排序规则<br>FilterComparator 维护了一个顺序的注册表 filterToOrder</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">FilterComparator() &#123;</span><br><span class="line">    Step order &#x3D; new Step(INITIAL_ORDER, ORDER_STEP);</span><br><span class="line">    put(ChannelProcessingFilter.class, order.next());</span><br><span class="line">    put(ConcurrentSessionFilter.class, order.next());</span><br><span class="line">    put(WebAsyncManagerIntegrationFilter.class, order.next());</span><br><span class="line">    put(SecurityContextPersistenceFilter.class, order.next());</span><br><span class="line">    put(HeaderWriterFilter.class, order.next());</span><br><span class="line">    put(CorsFilter.class, order.next());</span><br><span class="line">    put(CsrfFilter.class, order.next());</span><br><span class="line">    put(LogoutFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">        &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.saml2.provider.service.servlet.filter.Saml2WebSsoAuthenticationRequestFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    put(X509AuthenticationFilter.class, order.next());</span><br><span class="line">    put(AbstractPreAuthenticatedProcessingFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">        &quot;org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.saml2.provider.service.servlet.filter.Saml2WebSsoAuthenticationFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    put(UsernamePasswordAuthenticationFilter.class, order.next());</span><br><span class="line">    put(ConcurrentSessionFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.openid.OpenIDAuthenticationFilter&quot;, order.next());</span><br><span class="line">    put(DefaultLoginPageGeneratingFilter.class, order.next());</span><br><span class="line">    put(DefaultLogoutPageGeneratingFilter.class, order.next());</span><br><span class="line">    put(ConcurrentSessionFilter.class, order.next());</span><br><span class="line">    put(DigestAuthenticationFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter&quot;, order.next());</span><br><span class="line">    put(BasicAuthenticationFilter.class, order.next());</span><br><span class="line">    put(RequestCacheAwareFilter.class, order.next());</span><br><span class="line">    put(SecurityContextHolderAwareRequestFilter.class, order.next());</span><br><span class="line">    put(JaasApiIntegrationFilter.class, order.next());</span><br><span class="line">    put(RememberMeAuthenticationFilter.class, order.next());</span><br><span class="line">    put(AnonymousAuthenticationFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">        &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationCodeGrantFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    put(SessionManagementFilter.class, order.next());</span><br><span class="line">    put(ExceptionTranslationFilter.class, order.next());</span><br><span class="line">    put(FilterSecurityInterceptor.class, order.next());</span><br><span class="line">    put(SwitchUserFilter.class, order.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些就是所有内置的过滤器。 他们是通过下面的方法获取自己的序号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Integer getOrder(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">    while (clazz !&#x3D; null) &#123;</span><br><span class="line">        Integer result &#x3D; filterToOrder.get(clazz.getName());</span><br><span class="line">        if (result !&#x3D; null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        clazz &#x3D; clazz.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过过滤器的类全限定名从注册表 filterToOrder 中获取自己的序号，如果没有直接获取到序号通过递归获取父类在注册表中的序号作为自己的序号，序号越小优先级越高。上面的过滤器并非全部会被初始化。有的需要额外引入一些功能包，有的看 HttpSecurity 的配置情况。 在上一篇文章中。我们禁用了 CSRF 功能，就意味着 CsrfFilter 不会被注册。</p>
<ol start="3">
<li>内置过滤器讲解<br>接下来我们就对这些内置过滤器进行一个系统的认识。我们将按照默认顺序进行讲解。</li>
</ol>
<p>3.1 ChannelProcessingFilter<br>ChannelProcessingFilter 通常是用来过滤哪些请求必须用 https 协议， 哪些请求必须用 http 协议， 哪些请求随便用哪个协议都行。它主要有两个属性：</p>
<p>ChannelDecisionManager 用来判断请求是否符合既定的协议规则。它维护了一个 ChannelProcessor 列表 这些ChannelProcessor 是具体用来执行 ANY_CHANNEL 策略 （任何通道都可以）, REQUIRES_SECURE_CHANNEL 策略 （只能通过https 通道）, REQUIRES_INSECURE_CHANNEL 策略 （只能通过 http 通道）。</p>
<p>FilterInvocationSecurityMetadataSource 用来存储 url 与 对应的ANY_CHANNEL、REQUIRES_SECURE_CHANNEL、REQUIRES_INSECURE_CHANNEL 的映射关系。</p>
<p>ChannelProcessingFilter 通过 HttpScurity#requiresChannel() 等相关方法引入其配置对象 ChannelSecurityConfigurer 来进行配置。</p>
<p>3.2 ConcurrentSessionFilter<br>ConcurrentSessionFilter 主要用来判断session是否过期以及更新最新的访问时间。其流程为：</p>
<p>session 检测，如果不存在直接放行去执行下一个过滤器。存在则进行下一步。<br>根据sessionid从SessionRegistry中获取SessionInformation，从SessionInformation中获取session是否过期；没有过期则更新SessionInformation中的访问日期；<br>如果过期，则执行doLogout()方法，这个方法会将session无效，并将 SecurityContext 中的Authentication中的权限置空，同时在SecurityContenxtHoloder中清除SecurityContext然后查看是否有跳转的 expiredUrl，如果有就跳转，没有就输出提示信息。<br>ConcurrentSessionFilter 通过SessionManagementConfigurer 来进行配置。</p>
<p>3.3 WebAsyncManagerIntegrationFilter<br>WebAsyncManagerIntegrationFilter用于集成SecurityContext到Spring异步执行机制中的WebAsyncManager。用来处理异步请求的安全上下文。具体逻辑为：</p>
<p>从请求属性上获取所绑定的WebAsyncManager，如果尚未绑定，先做绑定。<br>从asyncManager 中获取 key 为 CALLABLE_INTERCEPTOR_KEY 的安全上下文多线程处理器 SecurityContextCallableProcessingInterceptor, 如果获取到的为 null，<br>新建一个 SecurityContextCallableProcessingInterceptor 并绑定 CALLABLE_INTERCEPTOR_KEY 注册到 asyncManager 中。<br>这里简单说一下 SecurityContextCallableProcessingInterceptor 。它实现了接口 CallableProcessingInterceptor，<br>当它被应用于一次异步执行时，beforeConcurrentHandling() 方法会在调用者线程执行，该方法会相应地从当前线程获取SecurityContext,然后被调用者线程中执行逻辑时，会使用这个 SecurityContext，从而实现安全上下文从调用者线程到被调用者线程的传输。</p>
<p>WebAsyncManagerIntegrationFilter 通过 WebSecurityConfigurerAdapter#getHttp()方法添加到 HttpSecurity 中成为 DefaultSecurityFilterChain 的一个链节。</p>
<p>3.4 SecurityContextPersistenceFilter<br>SecurityContextPersistenceFilter 主要控制 SecurityContext 的在一次请求中的生命周期 。 请求来临时，创建SecurityContext 安全上下文信息，请求结束时清空 SecurityContextHolder。</p>
<p>SecurityContextPersistenceFilter 通过 HttpScurity#securityContext() 及相关方法引入其配置对象 SecurityContextConfigurer 来进行配置。</p>
<p>3.5 HeaderWriterFilter<br>HeaderWriterFilter 用来给 http 响应添加一些 Header,比如 X-Frame-Options, X-XSS-Protection ，X-Content-Type-Options。</p>
<p>你可以通过 HttpScurity#headers() 来定制请求Header 。</p>
<p>3.6 CorsFilter<br>跨域相关的过滤器。这是Spring MVC Java配置和XML 命名空间 CORS 配置的替代方法， 仅对依赖于spring-web的应用程序有用（不适用于spring-webmvc）或 要求在javax.servlet.Filter 级别进行CORS检查的安全约束链接。这个是目前官方的一些解读，但是我还是不太清楚实际机制。</p>
<p>你可以通过 HttpSecurity#cors() 来定制。</p>
<p>3.7 CsrfFilter<br>CsrfFilter 用于防止csrf攻击，前后端使用json交互需要注意的一个问题。</p>
<p>你可以通过 HttpSecurity.csrf() 来开启或者关闭它。在你使用 jwt 等 token 技术时，是不需要这个的。</p>
<p>3.8 LogoutFilter<br>LogoutFilter 很明显这是处理注销的过滤器。</p>
<p>你可以通过 HttpSecurity.logout() 来定制注销逻辑，非常有用。</p>
<p>3.9 OAuth2AuthorizationRequestRedirectFilter<br>和上面的有所不同，这个需要依赖 spring-scurity-oauth2 相关的模块。该过滤器是处理 OAuth2 请求首选重定向相关逻辑的。以后会我会带你们认识它，请多多关注公众号：Felordcn 。</p>
<p>3.10 Saml2WebSsoAuthenticationRequestFilter<br>这个需要用到 Spring Security SAML 模块，这是一个基于 SMAL 的 SSO 单点登录请求认证过滤器。</p>
<p>关于SAML<br>SAML 即安全断言标记语言，英文全称是 Security Assertion Markup Language。它是一个基于 XML 的标准，用于在不同的安全域（security domain）之间交换认证和授权数据。在 SAML 标准定义了身份提供者 (identity provider) 和服务提供者 (service provider)，这两者构成了前面所说的不同的安全域。 SAML 是 OASIS 组织安全服务技术委员会(Security Services Technical Committee) 的产品。</p>
<p>SAML（Security Assertion Markup Language）是一个 XML 框架，也就是一组协议，可以用来传输安全声明。比如，两台远程机器之间要通讯，为了保证安全，我们可以采用加密等措施，也可以采用 SAML 来传输，传输的数据以 XML 形式，符合 SAML 规范，这样我们就可以不要求两台机器采用什么样的系统，只要求能理解 SAML 规范即可，显然比传统的方式更好。SAML 规范是一组 Schema 定义。</p>
<p>可以这么说，在Web Service 领域，schema 就是规范，在 Java 领域，API 就是规范</p>
<p>3.11 X509AuthenticationFilter<br>X509 认证过滤器。你可以通过 HttpSecurity#X509() 来启用和配置相关功能。</p>
<p>3.12 AbstractPreAuthenticatedProcessingFilter<br>AbstractPreAuthenticatedProcessingFilter 处理处理经过预先认证的身份验证请求的过滤器的基类，其中认证主体已经由外部系统进行了身份验证。 目的只是从传入请求中提取主体上的必要信息，而不是对它们进行身份验证。</p>
<p>你可以继承该类进行具体实现并通过 HttpSecurity#addFilter 方法来添加个性化的AbstractPreAuthenticatedProcessingFilter 。</p>
<p>3.13 CasAuthenticationFilter<br>CAS 单点登录认证过滤器 。依赖 Spring Security CAS 模块</p>
<p>3.14 OAuth2LoginAuthenticationFilter<br>这个需要依赖 spring-scurity-oauth2 相关的模块。OAuth2 登录认证过滤器。处理通过 OAuth2 进行认证登录的逻辑。</p>
<p>3.15 Saml2WebSsoAuthenticationFilter<br>这个需要用到 Spring Security SAML 模块，这是一个基于 SMAL 的 SSO 单点登录认证过滤器。关于SAML</p>
<p>3.16 UsernamePasswordAuthenticationFilter<br>这个看过我相关文章的应该不陌生了。处理用户以及密码认证的核心过滤器。认证请求提交的username和 password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</p>
<p>你可以通过 HttpSecurity#formLogin() 及相关方法引入其配置对象 FormLoginConfigurer 来进行配置。 我们在 Spring Security 实战干货： 玩转自定义登录 已经对其进行过个性化的配置和魔改。</p>
<p>3.17 ConcurrentSessionFilter<br>参见 3.2 ConcurrentSessionFilter。 该过滤器可能会被多次执行。</p>
<p>3.18 OpenIDAuthenticationFilter<br>基于OpenID 认证协议的认证过滤器。 你需要在依赖中依赖额外的相关模块才能启用它。</p>
<p>3.19 DefaultLoginPageGeneratingFilter<br>生成默认的登录页。默认 /login 。</p>
<p>3.20 DefaultLogoutPageGeneratingFilter<br>生成默认的退出页。 默认 /logout 。</p>
<p>3.21 ConcurrentSessionFilter<br>参见 3.2 ConcurrentSessionFilter 。 该过滤器可能会被多次执行。</p>
<p>3.23 DigestAuthenticationFilter<br>Digest身份验证是 Web 应用程序中流行的可选的身份验证机制 。DigestAuthenticationFilter 能够处理 HTTP 头中显示的摘要式身份验证凭据。你可以通过 HttpSecurity#addFilter() 来启用和配置相关功能。</p>
<p>3.24 BasicAuthenticationFilter<br>和Digest身份验证一样都是Web 应用程序中流行的可选的身份验证机制 。 BasicAuthenticationFilter 负责处理 HTTP 头中显示的基本身份验证凭据。这个 Spring Security 的 Spring Boot 自动配置默认是启用的 。</p>
<p>BasicAuthenticationFilter 通过 HttpSecurity#httpBasic() 及相关方法引入其配置对象 HttpBasicConfigurer 来进行配置。</p>
<p>3.25 RequestCacheAwareFilter<br>用于用户认证成功后，重新恢复因为登录被打断的请求。当匿名访问一个需要授权的资源时。会跳转到认证处理逻辑，此时请求被缓存。在认证逻辑处理完毕后，从缓存中获取最开始的资源请求进行再次请求。</p>
<p>RequestCacheAwareFilter 通过 HttpScurity#requestCache() 及相关方法引入其配置对象 RequestCacheConfigurer 来进行配置。</p>
<p>3.26 SecurityContextHolderAwareRequestFilter<br>用来 实现j2ee中 Servlet Api 一些接口方法, 比如 getRemoteUser 方法、isUserInRole 方法，在使用 Spring Security 时其实就是通过这个过滤器来实现的。</p>
<p>SecurityContextHolderAwareRequestFilter 通过 HttpSecurity.servletApi() 及相关方法引入其配置对象 ServletApiConfigurer 来进行配置。</p>
<p>3.27 JaasApiIntegrationFilter<br>适用于JAAS （Java 认证授权服务）。 如果 SecurityContextHolder 中拥有的 Authentication 是一个 JaasAuthenticationToken，那么该 JaasApiIntegrationFilter 将使用包含在 JaasAuthenticationToken 中的 Subject 继续执行 FilterChain。</p>
<p>3.28 RememberMeAuthenticationFilter<br>处理 记住我 功能的过滤器。</p>
<p>RememberMeAuthenticationFilter 通过 HttpSecurity.rememberMe() 及相关方法引入其配置对象 RememberMeConfigurer 来进行配置。</p>
<p>3.29 AnonymousAuthenticationFilter<br>匿名认证过滤器。对于 Spring Security 来说，所有对资源的访问都是有 Authentication 的。对于无需登录（UsernamePasswordAuthenticationFilter ）直接可以访问的资源，会授予其匿名用户身份。</p>
<p>AnonymousAuthenticationFilter 通过 HttpSecurity.anonymous() 及相关方法引入其配置对象 AnonymousConfigurer 来进行配置。</p>
<p>3.30 SessionManagementFilter<br>Session 管理器过滤器，内部维护了一个 SessionAuthenticationStrategy 用于管理 Session 。</p>
<p>SessionManagementFilter 通过 HttpScurity#sessionManagement() 及相关方法引入其配置对象 SessionManagementConfigurer 来进行配置。</p>
<p>3.31 ExceptionTranslationFilter<br>主要来传输异常事件，还记得之前我们见过的 DefaultAuthenticationEventPublisher 吗？</p>
<p>3.32 FilterSecurityInterceptor<br>这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。如果你要实现动态权限控制就必须研究该类 。</p>
<p>3.33 SwitchUserFilter<br>SwitchUserFilter 是用来做账户切换的。默认的切换账号的url为/login/impersonate，默认注销切换账号的url为/logout/impersonate，默认的账号参数为username 。</p>
<p>你可以通过此类实现自定义的账户切换。</p>
<ol start="4">
<li>总结<br>所有内置的 31个过滤器作用都讲解完了，有一些默认已经启用。有一些需要引入特定的包并且对 HttpSecurity 进行配置才会生效,而且它们的顺序是既定的。 只有你了解这些过滤器你才能基于业务深度定制 Spring Security 。</li>
</ol>
<hr>
<h2 id="实现自定义退出登录"><a href="#实现自定义退出登录" class="headerlink" title="实现自定义退出登录"></a>实现自定义退出登录</h2><ol>
<li><p>前言<br>上一篇对 Spring Security 所有内置的 Filter 进行了介绍。今天我们来实战如何安全退出应用程序。</p>
</li>
<li><p>我们使用 Spring Security 登录后都做了什么<br>这个问题我们必须搞清楚！一般登录后，服务端会给用户发一个凭证。常见有以下的两种：</p>
</li>
</ol>
<p>基于 Session 客户端会存 cookie 来保存一个 sessionId ，服务端存一个 Session 。</p>
<p>基于 token 客户端存一个 token 串，服务端会在缓存中存一个用来校验此 token 的信息。</p>
<ol start="2">
<li>退出登录需要我们做什么<br>当前的用户登录状态失效。这就需要我们清除服务端的用户状态。<br>退出登录接口并不是 permitAll， 只有携带对应用户的凭证才退出。<br>将退出结果返回给请求方。<br>退出登录后用户可以通过重新登录来认证该用户。</li>
<li>Spring Security 中的退出登录<br>接下来我们来分析并实战 如何定制退出登录逻辑。首先我们要了解 LogoutFilter 。</li>
</ol>
<p>3.1 LogoutFilter<br>通过 Spring Security 实战干货：内置 Filter 全解析 我们知道退出登录逻辑是由过滤器 LogoutFilter 来执行的。 它持有三个接口类型的属性：</p>
<p>RequestMatcher logoutRequestMatcher 这个用来拦截退出请求的 URL<br>LogoutHandler handler 用来处理退出的具体逻辑<br>LogoutSuccessHandler logoutSuccessHandler 退出成功后执行的逻辑<br>我们通过对以上三个接口的实现就能实现我们自定义的退出逻辑。</p>
<p>3.2 LogoutConfigurer<br>我们一般不会直接操作 LogoutFilter ，而是通过 LogoutConfigurer 来配置 LogoutFilter。 你可以通过 HttpSecurity#logout() 方法来初始化一个 LogoutConfigurer 。 接下来我们来实战操作一下。</p>
<p>3.2.1 实现自定义退出登录请求URL<br>LogoutConfigurer 提供了 logoutRequestMatcher(RequestMatcher logoutRequestMatcher)、logoutUrl(Sring logoutUrl) 两种方式来定义退出登录请求的 URL 。它们作用是相同的，你选择其中一种方式即可。</p>
<p>3.2.2 处理具体的逻辑<br>默认情况下 Spring Security 是基于 Session 的。LogoutConfigurer 提供了一些直接配置来满足你的需要。如下：</p>
<p>clearAuthentication(boolean clearAuthentication) 是否在退出时清除当前用户的认证信息<br>deleteCookies(String… cookieNamesToClear) 删除指定的 cookies<br>invalidateHttpSession(boolean invalidateHttpSession) 是否移除 HttpSession<br>如果上面满足不了你的需要就需要你来定制 LogoutHandler 了。</p>
<p>3.2.3 退出成功逻辑<br>logoutSuccessUrl(String logoutSuccessUrl) 退出成功后会被重定向到此 URL ，你可以写一个Controller 来完成最终返回，但是需要支持 GET 请求和 匿名访问 。 通过 setDefaultTargetUrl 方法注入到 LogoutSuccessHandler<br>defaultLogoutSuccessHandlerFor(LogoutSuccessHandler handler, RequestMatcher preferredMatcher) 用来构造默认的 LogoutSuccessHandler 我们可以通过添加多个来实现从不同 URL 退出执行不同的逻辑。<br>LogoutSuccessHandler logoutSuccessHandler 退出成功后执行的逻辑的抽象根本接口。<br>3.3 Spring Security 退出登录实战<br>现在前后端分离比较多，退出后返回json。 而且只有用户在线才能退出登录。否则不能进行退出操作。我们采用实现 LogoutHandler 和 LogoutSuccessHandler 接口这种编程的方式来配置 。退出请求的 url 依然通过 LogoutConfigurer#logoutUrl(String logoutUrl)来定义。</p>
<p>3.3.1 自定义 LogoutHandler<br>默认情况下清除认证信息 （invalidateHttpSession），和Session 失效（invalidateHttpSession） 已经由内置的SecurityContextLogoutHandler 来完成。我们自定义的 LogoutHandler 会在SecurityContextLogoutHandler 来执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">  public class CustomLogoutHandler implements LogoutHandler &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;</span><br><span class="line">          User user &#x3D; (User) authentication.getPrincipal();</span><br><span class="line">          String username &#x3D; user.getUsername();</span><br><span class="line">          log.info(&quot;username: &#123;&#125;  is offline now&quot;, username);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上是我们实现的 LogoutHandler 。 我们可以从 logout 方法的 authentication 变量中 获取当前用户信息。你可以通过这个来实现你具体想要的业务。比如记录用户下线退出时间、IP 等等。</p>
<p>3.3.2 自定义 LogoutSuccessHandler<br>如果我们实现了自定义的 LogoutSuccessHandler 就不必要设置 LogoutConfigurer#logoutSuccessUrl(String logoutSuccessUrl) 了。该处理器处理后会响应给前端。你可以转发到其它控制器。重定向到登录页面，也可以自行实现其它 MediaType ,可以是 json 或者页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class CustomLogoutSuccessHandler implements LogoutSuccessHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">        User user &#x3D; (User) authentication.getPrincipal();</span><br><span class="line">        String username &#x3D; user.getUsername();</span><br><span class="line">        log.info(&quot;username: &#123;&#125;  is offline now&quot;, username);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        responseJsonWriter(response, RestBody.ok(&quot;退出成功&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void responseJsonWriter(HttpServletResponse response, Rest rest) throws IOException &#123;</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        String resBody &#x3D; objectMapper.writeValueAsString(rest);</span><br><span class="line">        PrintWriter printWriter &#x3D; response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.3.4 自定义退出的 Spring Security 配置<br>为了方便调试我 注释掉了我们 实现的自定义登录，你可以通过 http:localhost:8080/login 来登录，然后通过 http:localhost:8080/logout 测试退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.csrf().disable()</span><br><span class="line">    .cors()</span><br><span class="line">    .and()</span><br><span class="line">    .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    &#x2F;&#x2F;.addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">    &#x2F;&#x2F; 登录</span><br><span class="line">    .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successForwardUrl(&quot;&#x2F;login&#x2F;success&quot;).failureForwardUrl(&quot;&#x2F;login&#x2F;failure&quot;)</span><br><span class="line">    .and().logout().addLogoutHandler(new CustomLogoutHandler()).logoutSuccessHandler(new CustomLogoutSuccessHandler());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手把手教你实现JWT-Token"><a href="#手把手教你实现JWT-Token" class="headerlink" title="手把手教你实现JWT Token"></a>手把手教你实现JWT Token</h2><ol>
<li><p>前言<br>Json Web Token （JWT） 近几年是前后端分离常用的 Token 技术，是目前最流行的跨域身份验证解决方案。你可以通过文章 一文了解web无状态会话token技术JWT 来了解 JWT。今天我们来手写一个通用的 JWT 服务。DEMO 获取方式在文末，实现在 jwt 相关包下</p>
</li>
<li><p>spring-security-jwt<br>spring-security-jwt 是 Spring Security Crypto 提供的 JWT 工具包 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-security-jwt.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>核心类只有一个: org.springframework.security.jwt.JwtHelper 。它提供了两个非常有用的静态方法。</p>
</li>
<li><p>JWT 编码<br>JwtHelper 提供的第一个静态方法就是 encode(CharSequence content, Signer signer) 这个是用来生成jwt的方法 需要指定 payload 跟 signer 签名算法。payload 存放了一些可用的不敏感信息：</p>
</li>
</ol>
<p>iss jwt签发者<br>sub jwt所面向的用户<br>aud 接收jwt的一方<br>iat jwt的签发时间<br>exp jwt的过期时间，这个过期时间必须要大于签发时间 iat<br>jti jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击<br>除了以上提供的基本信息外，我们可以定义一些我们需要传递的信息，比如目标用户的权限集 等等。切记不要传递密码等敏感信息 ，因为 JWT 的前两段都是用了 BASE64 编码，几乎算是明文了。</p>
<p>3.1 构建 JWT 中的 payload<br>我们先来构建 payload :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class JwtPayloadBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, String&gt; payload &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 附加的属性</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private Map&lt;String, String&gt; additional;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt签发者</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String iss;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt所面向的用户</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String sub;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 接收jwt的一方</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String aud;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private LocalDateTime exp;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt的签发时间</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private LocalDateTime iat &#x3D; LocalDateTime.now();</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 权限集</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private Set&lt;String&gt; roles &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String jti &#x3D; IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder iss(String iss) &#123;</span><br><span class="line">        this.iss &#x3D; iss;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder sub(String sub) &#123;</span><br><span class="line">        this.sub &#x3D; sub;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder aud(String aud) &#123;</span><br><span class="line">        this.aud &#x3D; aud;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder roles(Set&lt;String&gt; roles) &#123;</span><br><span class="line">        this.roles &#x3D; roles;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder expDays(int days) &#123;</span><br><span class="line">        Assert.isTrue(days &gt; 0, &quot;jwt expireDate must after now&quot;);</span><br><span class="line">        this.exp &#x3D; this.iat.plusDays(days);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder additional(Map&lt;String, String&gt; additional) &#123;</span><br><span class="line">        this.additional &#x3D; additional;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String builder() &#123;</span><br><span class="line">        payload.put(&quot;iss&quot;, this.iss);</span><br><span class="line">        payload.put(&quot;sub&quot;, this.sub);</span><br><span class="line">        payload.put(&quot;aud&quot;, this.aud);</span><br><span class="line">        payload.put(&quot;exp&quot;, this.exp.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        payload.put(&quot;iat&quot;, this.iat.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        payload.put(&quot;jti&quot;, this.jti);</span><br><span class="line"></span><br><span class="line">        if (!CollectionUtils.isEmpty(additional)) &#123;</span><br><span class="line">            payload.putAll(additional);</span><br><span class="line">        &#125;</span><br><span class="line">        payload.put(&quot;roles&quot;, JSONUtil.toJsonStr(this.roles));</span><br><span class="line">        return JSONUtil.toJsonStr(JSONUtil.parse(payload));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过建造类 JwtClaimsBuilder 我们可以很方便来构建 JWT 所需要的 payload json 字符串传递给 encode(CharSequence content, Signer signer) 中的 content 。</p>
<p>3.2 生成 RSA 密钥并进行签名<br>为了生成 JWT Token 我们还需要使用 RSA 算法来进行签名。 这里我们使用 JDK 提供的证书管理工具 Keytool 来生成 RSA 证书 ，格式为 jks 格式。</p>
<p>生成证书命令参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias iching -keypass iching -keyalg RSA -storetype PKCS12 -keysize 1024 -validity 365 -keystore &#x2F;Users&#x2F;minyi&#x2F;web&#x2F;ideaSpace&#x2F;spring-boot-starter&#x2F;iching-auth-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;iching.jks -storepass 123456  -dname &quot;CN&#x3D;(iching), OU&#x3D;(iching), O&#x3D;(iching), L&#x3D;(zz), ST&#x3D;(hn), C&#x3D;(cn)&quot;</span><br></pre></td></tr></table></figure>

<p> 其中 -alias iching -storepass 123456 我们要作为配置使用要记下来。我们要使用下面定义的这个类来读取证书<br>查看jks文件中所有证书内容<br>keytool -list -v -keystore cert_file_name<br>修改证书文文件的加密密码<br>keytool -storepasswd -keystore cert_file_name<br>输入命令，会首先提示你输入证书原始密码；之后会继续要求你输入两次新密码。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class KeyPairFactory &#123;</span><br><span class="line"></span><br><span class="line">     private KeyStore store;</span><br><span class="line"></span><br><span class="line">     private final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">     &#x2F;**</span><br><span class="line">      * 获取公私钥.</span><br><span class="line">      *</span><br><span class="line">      * @param keyPath  jks 文件在 resources 下的classpath</span><br><span class="line">      * @param keyAlias  keytool 生成的 -alias 值  felordcn</span><br><span class="line">      * @param keyPass  keytool 生成的  -storepass 值  123456</span><br><span class="line">      * @return the key pair 公私钥对</span><br><span class="line">      *&#x2F;</span><br><span class="line">    KeyPair create(String keyPath, String keyAlias, String keyPass) &#123;</span><br><span class="line">         ClassPathResource resource &#x3D; new ClassPathResource(keyPath);</span><br><span class="line">         char[] pem &#x3D; keyPass.toCharArray();</span><br><span class="line">         try &#123;</span><br><span class="line">             synchronized (lock) &#123;</span><br><span class="line">                 if (store &#x3D;&#x3D; null) &#123;</span><br><span class="line">                     synchronized (lock) &#123;</span><br><span class="line">                         store &#x3D; KeyStore.getInstance(&quot;jks&quot;);</span><br><span class="line">                         store.load(resource.getInputStream(), pem);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             RSAPrivateCrtKey key &#x3D; (RSAPrivateCrtKey) store.getKey(keyAlias, pem);</span><br><span class="line">             RSAPublicKeySpec spec &#x3D; new RSAPublicKeySpec(key.getModulus(), key.getPublicExponent());</span><br><span class="line">             PublicKey publicKey &#x3D; KeyFactory.getInstance(&quot;RSA&quot;).generatePublic(spec);</span><br><span class="line">             return new KeyPair(publicKey, key);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">             throw new IllegalStateException(&quot;Cannot load keys from store: &quot; + resource, e);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 获取了 KeyPair 就能获取公私钥 生成 Jwt 的两个要素就完成了。我们可以和之前定义的 JwtPayloadBuilder 一起封装出生成 Jwt Token 的方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private String jwtToken(String aud, int exp, Set&lt;String&gt; roles, Map&lt;String, String&gt; additional) &#123;</span><br><span class="line">    String payload &#x3D; jwtPayloadBuilder</span><br><span class="line">            .iss(jwtProperties.getIss())</span><br><span class="line">            .sub(jwtProperties.getSub())</span><br><span class="line">            .aud(aud)</span><br><span class="line">            .additional(additional)</span><br><span class="line">            .roles(roles)</span><br><span class="line">            .expDays(exp)</span><br><span class="line">            .builder();</span><br><span class="line">    RSAPrivateKey privateKey &#x3D; (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">    RsaSigner signer &#x3D; new RsaSigner(privateKey);</span><br><span class="line">    return JwtHelper.encode(payload, signer).getEncoded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通常情况下 Jwt Token 都是成对出现的，一个为平常请求携带的 accessToken， 另一个只作为刷新 accessToken 之用的 refreshToken 。而且 refreshToken 的过期时间要相对长一些。当 accessToken 失效而refreshToken 有效时，我们可以通过 refreshToken 来获取新的 Jwt Token对 ；当两个都失效就用户就必须重新登录了。</p>
<p>生成 Jwt Token对 的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public JwtTokenPair jwtTokenPair(String aud, Set&lt;String&gt; roles, Map&lt;String, String&gt; additional) &#123;</span><br><span class="line">    String accessToken &#x3D; jwtToken(aud, jwtProperties.getAccessExpDays(), roles, additional);</span><br><span class="line">    String refreshToken &#x3D; jwtToken(aud, jwtProperties.getRefreshExpDays(), roles, additional);</span><br><span class="line"></span><br><span class="line">    JwtTokenPair jwtTokenPair &#x3D; new JwtTokenPair();</span><br><span class="line">    jwtTokenPair.setAccessToken(accessToken);</span><br><span class="line">    jwtTokenPair.setRefreshToken(refreshToken);</span><br><span class="line">    &#x2F;&#x2F; 放入缓存</span><br><span class="line">    jwtTokenStorage.put(jwtTokenPair, aud);</span><br><span class="line">    return jwtTokenPair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常 Jwt Token对 会在返回给前台的同时放入缓存中。过期策略你可以选择分开处理，也可以选择以refreshToken 的过期时间为准。</p>
<ol start="4">
<li><p>JWT 解码以及验证<br>JwtHelper 提供的第二个静态方法是Jwt decodeAndVerify(String token, SignatureVerifier verifier) 用来 验证和解码 Jwt Token 。我们获取到请求中的token后会解析出用户的一些信息。通过这些信息去缓存中对应的token ，然后比对并验证是否有效（包括是否过期）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 解码 并校验签名 过期不予解析</span><br><span class="line">*</span><br><span class="line">* @param jwtToken the jwt token</span><br><span class="line">* @return the jwt claims</span><br><span class="line">*&#x2F;</span><br><span class="line">public JSONObject decodeAndVerify(String jwtToken) &#123;</span><br><span class="line">    Assert.hasText(jwtToken, &quot;jwt token must not be bank&quot;);</span><br><span class="line">    RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) this.keyPair.getPublic();</span><br><span class="line">    SignatureVerifier rsaVerifier &#x3D; new RsaVerifier(rsaPublicKey);</span><br><span class="line">    Jwt jwt &#x3D; JwtHelper.decodeAndVerify(jwtToken, rsaVerifier);</span><br><span class="line">    String claims &#x3D; jwt.getClaims();</span><br><span class="line">    JSONObject jsonObject &#x3D; JSONUtil.parseObj(claims);</span><br><span class="line">    String exp &#x3D; jsonObject.getStr(JWT_EXP_KEY);</span><br><span class="line">    &#x2F;&#x2F; 是否过期</span><br><span class="line">    if (isExpired(exp)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;jwt token is expired&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们将有效的 Jwt Token 中的 payload 解析为 JSON对象 ，方便后续的操作。</p>
</li>
<li><p>配置<br>我们将 JWT 的可配置项抽出来放入 JwtProperties 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Jwt 在 springboot application.yml 中的配置文件</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Data</span><br><span class="line"> @ConfigurationProperties(prefix&#x3D;JWT_PREFIX)</span><br><span class="line"> public class JwtProperties &#123;</span><br><span class="line">     static final String JWT_PREFIX&#x3D; &quot;jwt.config&quot;;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * 是否可用</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private boolean enabled;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * jks 路径</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private String keyLocation;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * key alias</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private String keyAlias;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * key store pass</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private String keyPass;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * jwt签发者</span><br><span class="line">      **&#x2F;</span><br><span class="line">     private String iss;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * jwt所面向的用户</span><br><span class="line">      **&#x2F;</span><br><span class="line">     private String sub;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * access jwt token 有效天数</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private int accessExpDays;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * refresh jwt token 有效天数</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private int refreshExpDays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以配置 JWT 的 javaConfig 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@EnableConfigurationProperties(JwtProperties.class)</span><br><span class="line">@ConditionalOnProperty(prefix &#x3D; &quot;jwt.config&quot;,name &#x3D; &quot;enabled&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class JwtConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Jwt token storage .</span><br><span class="line">    *</span><br><span class="line">    * @return the jwt token storage</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtTokenStorage jwtTokenStorage() &#123;</span><br><span class="line">        return new JwtTokenCacheStorage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Jwt token generator.</span><br><span class="line">    *</span><br><span class="line">    * @param jwtTokenStorage the jwt token storage</span><br><span class="line">    * @param jwtProperties   the jwt properties</span><br><span class="line">    * @return the jwt token generator</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtTokenGenerator jwtTokenGenerator(JwtTokenStorage jwtTokenStorage, JwtProperties jwtProperties) &#123;</span><br><span class="line">        return new JwtTokenGenerator(jwtTokenStorage, jwtProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你就可以通过 JwtTokenGenerator 编码/解码验证 Jwt Token 对 ，通过 JwtTokenStorage 来处理 Jwt Token 缓存。缓存这里我用了Spring Cache Ehcache 来实现,你也可以切换到 Redis 。</p>
</li>
</ol>
<hr>
<h2 id="登录后返回-JWT-Token"><a href="#登录后返回-JWT-Token" class="headerlink" title="登录后返回 JWT Token"></a>登录后返回 JWT Token</h2><ol>
<li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章，上一文 我们实现了 JWT 工具。本篇我们将一起探讨如何将 JWT 与 Spring Security 结合起来，在认证成功后不再跳转到指定页面而是直接返回 JWT Token 。 本文的DEMO 可通过文末的方式获取</p>
</li>
<li><p>流程<br>JWT 适用于前后端分离。我们在登录成功后不在跳转到首页，将会直接返回 JWT Token 对（DEMO中为JwtTokenPair），登录失败后返回认证失败相关的信息。</p>
</li>
<li><p>实现登录成功/失败返回逻辑<br>如果你看过 Spring Security 实战干货： 玩转自定义登录 将非常容易理解下面的做法。</p>
</li>
</ol>
<p>3.1 AuthenticationSuccessHandler 返回 JWT Token<br>AuthenticationSuccessHandler 用于处理登录成功后的逻辑，我们编写实现并注入 Spring IoC 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 处理登录成功后返回 JWT Token 对.</span><br><span class="line">*</span><br><span class="line">* @param jwtTokenGenerator the jwt token generator</span><br><span class="line">* @return the authentication success handler</span><br><span class="line">*&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">public AuthenticationSuccessHandler authenticationSuccessHandler(JwtTokenGenerator jwtTokenGenerator) &#123;</span><br><span class="line">    return (request, response, authentication) -&gt; &#123;</span><br><span class="line">        if (response.isCommitted()) &#123;</span><br><span class="line">            log.debug(&quot;Response has already been committed&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;(5);</span><br><span class="line">        map.put(&quot;time&quot;, LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        map.put(&quot;flag&quot;, &quot;success_login&quot;);</span><br><span class="line">        User principal &#x3D; (User) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        String username &#x3D; principal.getUsername();</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities &#x3D; principal.getAuthorities();</span><br><span class="line">        Set&lt;String&gt; roles &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        if (CollectionUtil.isNotEmpty(authorities)) &#123;</span><br><span class="line">            for (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">                String roleName &#x3D; authority.getAuthority();</span><br><span class="line">                roles.add(roleName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JwtTokenPair jwtTokenPair &#x3D; jwtTokenGenerator.jwtTokenPair(username, roles, null);</span><br><span class="line"></span><br><span class="line">        map.put(&quot;access_token&quot;, jwtTokenPair.getAccessToken());</span><br><span class="line">        map.put(&quot;refresh_token&quot;, jwtTokenPair.getRefreshToken());</span><br><span class="line"></span><br><span class="line">        ResponseUtil.responseJsonWriter(response, RestBody.okData(map, &quot;登录成功&quot;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.2 AuthenticationFailureHandler 返回认证失败信息<br>AuthenticationFailureHandler 处理认证失败后的逻辑，前端根据此返回进行跳转处理逻辑，我们也实现它并注入 Spring IoC 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 失败登录处理器 处理登录失败后的逻辑 登录失败返回信息 以此为依据跳转</span><br><span class="line">*</span><br><span class="line">* @return the authentication failure handler</span><br><span class="line">*&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">public AuthenticationFailureHandler authenticationFailureHandler() &#123;</span><br><span class="line">    return (request, response, exception) -&gt; &#123;</span><br><span class="line">        if (response.isCommitted()) &#123;</span><br><span class="line">            log.debug(&quot;Response has already been committed&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line"></span><br><span class="line">        map.put(&quot;time&quot;, LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        map.put(&quot;flag&quot;, &quot;failure_login&quot;);</span><br><span class="line">        ResponseUtil.responseJsonWriter(response, RestBody.build(HttpStatus.UNAUTHORIZED.value(), map, &quot;认证失败&quot;,&quot;-9999&quot;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置<br>把上面写好的两个 Handler Bean 写入 登录配置，相关片断如下，详情参见文末 DEMO：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)</span><br></pre></td></tr></table></figure></li>
<li>验证<br>我们依然通过 Spring Security 实战干货： 玩转自定义登录 一文中章节 6.4 测试 来运行。结果如下：</li>
</ol>
<p>5.1 登录成功结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;httpStatus&quot;:200,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhbGwiLCJhdWQiOiJpY2hpbmciLCJyb2xlcyI6IltdIiwiaXNzIjoiaWNoaW5nIiwiZXhwIjoiMjAyMC0wMi0xMyAyMTozODo0OCIsImlhdCI6IjIwMjAtMDEtMTQgMjE6Mzg6NDgiLCJqdGkiOiIxYjAzY2E5ZGZhZTA0MWQzYTliM2I4ZGNhNmI4ZGU2NSJ9.nqDqf6RipGVS10o7_KnuvHD2nWhYhilL4fV1GxSbKagbRZV_z0saYILKGe30nNJUgFY-Kgx2yQqgOGHHAaRAG_q_3qOsGEs21NTzQz0WSIDcGI-ltOAjMQvB3DPKncwWFyeOz4BQiwFBw3wo8ARWzjGL-JsnwU4AG9pgDdExZuU&quot;,&quot;refresh_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhbGwiLCJhdWQiOiJpY2hpbmciLCJyb2xlcyI6IltdIiwiaXNzIjoiaWNoaW5nIiwiZXhwIjoiMjAyMC0wNC0xMyAyMTozODo0OCIsImlhdCI6IjIwMjAtMDEtMTQgMjE6Mzg6NDgiLCJqdGkiOiIxYjAzY2E5ZGZhZTA0MWQzYTliM2I4ZGNhNmI4ZGU2NSJ9.d43vsIO0pXRCE3jytOZPP3yKegMJlYn5o4sGMuDtC_IN0uDCZMwXTSsT63XiSUqTz3gzMwxbujyX7mS-d7FDergbH617W7OTUR1idkxtX-7GLUgCYnibBG-QNEp2ljfTF9s97hX281nAcxm7sMleaRt8xt0TJBv2LO9msZbGMDY&quot;,</span><br><span class="line">        &quot;time&quot;:&quot;2020-01-14 21:43:57&quot;,&quot;flag&quot;:&quot;success_login&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;:&quot;登录成功&quot;,</span><br><span class="line">    &quot;identifier&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们取 access_token 使用官网jwt.io 提供的解码功能进行解码如下：<br>5.2 登录失败结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;httpStatus&quot;: 401,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;time&quot;: &quot;2020-01-14 21:45:57&quot;,</span><br><span class="line">        &quot;flag&quot;: &quot;failure_login&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;: &quot;认证失败&quot;,</span><br><span class="line">    &quot;identifier&quot;: &quot;-9999&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>总结<br>今天我们将 JWT 和 Spring Security 联系了起来，实现了 登录成功后返回 JWT Token 。 这仅仅是一个开始，在下一篇我们将介绍 客户端如何使用 JWT Token 、服务端如何验证 JWT Token </li>
</ol>
<hr>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://www.felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/index.html" target="_blank" rel="noopener">https://www.felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/index.html</a><br><a href="https://docs.spring.io/spring-boot/docs/current/reference/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/</a><br><a href="https://docs.spring.io/spring-boot/docs/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/</a><br><a href="http://www.what21.com/u/10004/4895501825056762414.htm" target="_blank" rel="noopener">http://www.what21.com/u/10004/4895501825056762414.htm</a></p>
<h2 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h2><ol>
<li><p>前言<br>最近实在比较忙，很难抽出时间来继续更 Spring Security 实战干货系列。今天正好项目中 Spring Security 需要对认证授权异常的处理，就分享出来吧 。</p>
</li>
<li><p>Spring Security 中的异常<br>Spring Security 中的异常主要分为两大类：一类是认证异常，另一类是授权相关的异常。</p>
</li>
</ol>
<p>2.1 AuthenticationException<br>AuthenticationException 是在用户认证的时候出现错误时抛出的异常。主要的子类如图：<br><img src="/2020/01/11/SpringSecurity/main_callback.png" alt="SpringSecurity"></p>
<p>根据该图的信息，系统用户不存在，被锁定，凭证失效，密码错误等认证过程中出现的异常都由 AuthenticationException 处理。</p>
<p>2.2 AccessDeniedException<br>AccessDeniedException 主要是在用户在访问受保护资源时被拒绝而抛出的异常。同 AuthenticationException 一样它也提供了一些具体的子类。如下图：<br><img src="/2020/01/11/SpringSecurity/csrf.png" alt="SpringSecurity"></p>
<p>AccessDeniedException 的子类比较少，主要是 CSRF 相关的异常和授权服务异常。</p>
<ol start="3">
<li>Http 状态对认证授权的规定<br>Http 协议对认证授权的响应结果也有规定。</li>
</ol>
<p>3.1 401 未授权状态<br>HTTP 401 错误 - 未授权(Unauthorized) 一般来说该错误消息表明您首先需要登录（输入有效的用户名和密码）。 如果你刚刚输入这些信息，立刻就看到一个 401 错误，就意味着，无论出于何种原因您的用户名和密码其中之一或两者都无效（输入有误，用户名暂时停用，账户被锁定，凭证失效等） 。总之就是认证失败了。其实正好对应我们上面的 AuthenticationException 。</p>
<p>3.2 403 被拒绝状态<br>HTTP 403 错误 - 被禁止(Forbidden) 出现该错误表明您在访问受限资源时没有得到许可。服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。并且服务器想让客户端知道为什么没有权限访问特定的资源，服务器应该在返回的信息中描述拒绝的理由。一般实践中我们会比较模糊的表明原因。 该错误对应了我们上面的 AccessDeniedException 。</p>
<ol start="4">
<li>Spring Security 中的异常处理<br>我们在 Spring Security 实战干货系列文章中的 自定义配置类入口 WebSecurityConfigurerAdapter 一文中提到 HttpSecurity 提供的 exceptionHandling() 方法用来提供异常处理。该方法构造出 ExceptionHandlingConfigurer 异常处理配置类。该配置类提供了两个实用接口：</li>
</ol>
<p>AuthenticationEntryPoint 该类用来统一处理 AuthenticationException 异常<br>AccessDeniedHandler 该类用来统一处理 AccessDeniedException 异常<br>我们只要实现并配置这两个异常处理类即可实现对 Spring Security 认证授权相关的异常进行统一的自定义处理。</p>
<p>4.1 实现 AuthenticationEntryPoint<br>以 json 信息响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;todo your business</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line">        map.put(&quot;uri&quot;, request.getRequestURI());</span><br><span class="line">        map.put(&quot;msg&quot;, &quot;认证失败&quot;);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        String resBody &#x3D; objectMapper.writeValueAsString(map);</span><br><span class="line">        PrintWriter printWriter &#x3D; response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.2 实现 AccessDeniedHandler<br>同样以 json 信息响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleAccessDeniedHandler implements AccessDeniedHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;todo your business</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line">        map.put(&quot;uri&quot;, request.getRequestURI());</span><br><span class="line">        map.put(&quot;msg&quot;, &quot;认证失败&quot;);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        String resBody &#x3D; objectMapper.writeValueAsString(map);</span><br><span class="line">        PrintWriter printWriter &#x3D; response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.3 个人实践建议<br>其实我个人建议 Http 状态码 都返回 200 而将 401 状态在 元信息 Map 中返回。因为异常状态码在浏览器端会以 error 显示。我们只要能捕捉到 401 和 403 就能认定是认证问题还是授权问题。</p>
<p>4.4 配置<br>实现了上述两个接口后，我们只需要在 WebSecurityConfigurerAdapter 的 configure(HttpSecurity http) 方法中配置即可。相关的配置片段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling().accessDeniedHandler(new SimpleAccessDeniedHandler()).authenticationEntryPoint(new SimpleAuthenticationEntryPoint())</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用-JWT-认证访问接口"><a href="#使用-JWT-认证访问接口" class="headerlink" title="使用 JWT 认证访问接口"></a>使用 JWT 认证访问接口</h2><ol>
<li><p>前言<br>欢迎阅读Spring Security 实战干货系列。之前我讲解了如何编写一个自己的 Jwt 生成器以及如何在用户认证通过后返回 Json Web Token 。今天我们来看看如何在请求中使用 Jwt 访问鉴权。DEMO 获取方法在文末。</p>
</li>
<li><p>常用的 Http 认证方式<br>我们要在 Http 请求中使用 Jwt 我们就必须了解 常见的 Http 认证方式。</p>
</li>
</ol>
<p>2.1 HTTP Basic Authentication<br>HTTP Basic Authentication 又叫基础认证，它简单地使用 Base64 算法对用户名、密码进行加密，并将加密后的信息放在请求头 Header 中，本质上还是明文传输用户名、密码，并不安全，所以最好在 Https 环境下使用。其认证流程如下：</p>
<p><img src="/2020/01/11/SpringSecurity/Basic.png" alt="Basic"></p>
<p>客户端发起 GET 请求 服务端响应返回 401 Unauthorized， www-Authenticate 指定认证算法，realm 指定安全域。然后客户端一般会弹窗提示输入用户名称和密码，输入用户名密码后放入 Header 再次请求，服务端认证成功后以 200 状态码响应客户端。</p>
<p>2.2 HTTP Digest Authentication<br>为弥补 BASIC 认证存在的弱点就有了 HTTP Digest Authentication 。它又叫摘要认证。它使用随机数加上 MD5 算法来对用户名、密码进行摘要编码，流程类似 Http Basic Authentication ，但是更加复杂一些:</p>
<p><img src="/2020/01/11/SpringSecurity/Digest.png" alt="Digest"></p>
<p>步骤1：跟基础认证一样，只不过返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需要的临时咨询码（随机数，nonce）。 首部字段WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现</p>
<p>步骤2：接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。首部字段 Authorization 内必须包含username、realm、nonce、uri 和 response 的字段信息，其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。</p>
<p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则会返回包含 Request-URI 资源的响应。</p>
<p>并且这时会在首部字段 Authorization-Info 写入一些认证成功的相关信息。</p>
<p>2.3 SSL 客户端认证<br>SSL 客户端认证就是通常我们说的 HTTPS 。安全级别较高，但需要承担 CA 证书费用。SSL 认证过程中涉及到一些重要的概念，数字证书机构的公钥、证书的私钥和公钥、非对称算法（配合证书的私钥和公钥使用）、对称密钥、对称算法（配合对称密钥使用）。相对复杂一些这里不过多讲述。</p>
<p>2.4 Form 表单认证<br>Form 表单的认证方式并不是HTTP规范。所以实现方式也呈现多样化，其实我们平常的扫码登录，手机验证码登录都属于表单登录的范畴。表单认证一般都会配合 Cookie，Session 的使用，现在很多 Web 站点都使用此认证方式。用户在登录页中填写用户名和密码，服务端认证通过后会将 sessionId 返回给浏览器端，浏览器会保存 sessionId 到浏览器的 Cookie 中。因为 HTTP 是无状态的，所以浏览器使用 Cookie 来保存 sessionId。下次客户端会在发送的请求中会携带 sessionId 值，服务端发现 sessionId 存在并以此为索引获取用户存在服务端的认证信息进行认证操作。认证过则会提供资源访问。</p>
<p>我们在Spring Security 实战干货：登录后返回 JWT Token 一文其实也是通过 Form 提交来获取 Jwt 其实 Jwt 跟 sessionId 同样的作用，只不过 Jwt 天然携带了用户的一些信息，而 sessionId 需要去进一步获取用户信息。</p>
<p>2.5 Json Web Token 的认证方式 Bearer Authentication<br>我们通过表单认证获取 Json Web Token ，那么如何使用它呢? 通常我们会把 Jwt 作为令牌使用 Bearer Authentication 方式使用。Bearer Authentication 是一种基于令牌的 HTTP 身份验证方案，用户向服务器请求访问受限资源时，会携带一个 Token 作为凭证，检验通过则可以访问特定的资源。最初是在 RFC 6750 中作为 OAuth 2.0 的一部分，但有时也可以单独使用。<br>我们在使用 Bear Token 的方法是在请求头的 Authorization 字段中放入 Bearer <token> 的格式的加密串(Json Web Token)。请注意 Bearer 前缀与 Token 之间有一个空字符位，与基本身份验证类似，Bearer Authentication 只能在HTTPS（SSL）上使用。</p>
<ol start="3">
<li>Spring Security 中实现接口 Jwt 认证<br>接下来我们是我们该系列的重头戏 ———— 接口的 Jwt 认证。</li>
</ol>
<p>3.1 定义 Json Web Token 过滤器<br>无论上面提到的哪种认证方式，我们都可以使用 Spring Security 中的 Filter 来处理。 Spring Security 默认的基础配置没有提供对 Bearer Authentication 处理的过滤器， 但是提供了处理 Basic Authentication 的过滤器：</p>
<p>org.springframework.security.web.authentication.<a href="http://www.BasicAuthenticationFilter" target="_blank" rel="noopener">www.BasicAuthenticationFilter</a></p>
<p>BasicAuthenticationFilter 继承了 OncePerRequestFilter 。所以我们也模仿 BasicAuthenticationFilter 来实现自己的 JwtAuthenticationFilter 。 完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * jwt 认证拦截器 用于拦截 请求 提取jwt 认证</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Slf4j</span><br><span class="line"> public class JwtAuthenticationFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    private static final String AUTHENTICATION_PREFIX &#x3D; &quot;Bearer &quot;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 认证如果失败由该端点进行响应</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private AuthenticationEntryPoint authenticationEntryPoint &#x3D; new SimpleAuthenticationEntryPoint();</span><br><span class="line">    private JwtTokenGenerator jwtTokenGenerator;</span><br><span class="line">    private JwtTokenStorage jwtTokenStorage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public JwtAuthenticationFilter(JwtTokenGenerator jwtTokenGenerator, JwtTokenStorage jwtTokenStorage) &#123;</span><br><span class="line">        this.jwtTokenGenerator &#x3D; jwtTokenGenerator;</span><br><span class="line">        this.jwtTokenStorage &#x3D; jwtTokenStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果已经通过认证</span><br><span class="line">        if (SecurityContextHolder.getContext().getAuthentication() !&#x3D; null) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 获取 header 解析出 jwt 并进行认证 无token 直接进入下一个过滤器  因为  SecurityContext 的缘故 如果无权限并不会放行</span><br><span class="line">        String header &#x3D; request.getHeader(HttpHeaders.AUTHORIZATION);</span><br><span class="line">        if (StringUtils.hasText(header) &amp;&amp; header.startsWith(AUTHENTICATION_PREFIX)) &#123;</span><br><span class="line">            String jwtToken &#x3D; header.replace(AUTHENTICATION_PREFIX, &quot;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (StringUtils.hasText(jwtToken)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    authenticationTokenHandle(jwtToken, request);</span><br><span class="line">                &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">                    authenticationEntryPoint.commence(request, response, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 带安全头 没有带token</span><br><span class="line">                authenticationEntryPoint.commence(request, response, new AuthenticationCredentialsNotFoundException(&quot;token is not found&quot;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 具体的认证方法  匿名访问不要携带token</span><br><span class="line">    * 有些逻辑自己补充 这里只做基本功能的实现</span><br><span class="line">    *</span><br><span class="line">    * @param jwtToken jwt token</span><br><span class="line">    * @param request  request</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private void authenticationTokenHandle(String jwtToken, HttpServletRequest request) throws AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 根据我的实现 有效token才会被解析出来</span><br><span class="line">        JSONObject jsonObject &#x3D; jwtTokenGenerator.decodeAndVerify(jwtToken);</span><br><span class="line"></span><br><span class="line">        if (Objects.nonNull(jsonObject)) &#123;</span><br><span class="line">            String username &#x3D; jsonObject.getStr(&quot;aud&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 从缓存获取 token</span><br><span class="line">            JwtTokenPair jwtTokenPair &#x3D; jwtTokenStorage.get(username);</span><br><span class="line">            if (Objects.isNull(jwtTokenPair)) &#123;</span><br><span class="line">                if (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(&quot;token : &#123;&#125;  is  not in cache&quot;, jwtToken);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 缓存中不存在就算 失败了</span><br><span class="line">                throw new CredentialsExpiredException(&quot;token is not in cache&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            String accessToken &#x3D; jwtTokenPair.getAccessToken();</span><br><span class="line"></span><br><span class="line">            if (jwtToken.equals(accessToken)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 解析 权限集合  这里</span><br><span class="line">                JSONArray jsonArray &#x3D; jsonObject.getJSONArray(&quot;roles&quot;);</span><br><span class="line"></span><br><span class="line">                String roles &#x3D; jsonArray.toString();</span><br><span class="line"></span><br><span class="line">                List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(roles);</span><br><span class="line">                User user &#x3D; new User(username, &quot;[PROTECTED]&quot;, authorities);</span><br><span class="line">                &#x2F;&#x2F; 构建用户认证token</span><br><span class="line">                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken &#x3D; new UsernamePasswordAuthenticationToken(user, null, authorities);</span><br><span class="line">                usernamePasswordAuthenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                &#x2F;&#x2F; 放入安全上下文中</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; token 不匹配</span><br><span class="line">                if (log.isDebugEnabled())&#123;</span><br><span class="line">                    log.debug(&quot;token : &#123;&#125;  is  not in matched&quot;, jwtToken);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                throw new BadCredentialsException(&quot;token is not matched&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(&quot;token : &#123;&#125;  is  invalid&quot;, jwtToken);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new BadCredentialsException(&quot;token is invalid&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体看代码注释部分，逻辑有些地方根据你业务进行调整。匿名访问必然是不能带 Token 的！</p>
<p>3.2 配置 JwtAuthenticationFilter<br>首先将过滤器 JwtAuthenticationFilter 注入 Spring IoC 容器 ，然后一定要将 JwtAuthenticationFilter 顺序置于 UsernamePasswordAuthenticationFilter 之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.csrf().disable()</span><br><span class="line">    .cors()</span><br><span class="line">    .and()</span><br><span class="line">    &#x2F;&#x2F; session 生成策略用无状态策略</span><br><span class="line">    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">    .and()</span><br><span class="line">    .exceptionHandling().accessDeniedHandler(new SimpleAccessDeniedHandler()).authenticationEntryPoint(new SimpleAuthenticationEntryPoint())</span><br><span class="line">    .and()</span><br><span class="line">    .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    .addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">    &#x2F;&#x2F; jwt 必须配置于 UsernamePasswordAuthenticationFilter 之前</span><br><span class="line">    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">    &#x2F;&#x2F; 登录  成功后返回jwt token  失败后返回 错误信息</span><br><span class="line">    .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)</span><br><span class="line">    .and().logout().addLogoutHandler(new CustomLogoutHandler()).logoutSuccessHandler(new CustomLogoutSuccessHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用 Jwt 进行请求验证<br>编写一个受限接口 ，我们这里是 <a href="http://localhost:8080/foo/test" target="_blank" rel="noopener">http://localhost:8080/foo/test</a> 。直接请求会被 401 。 我们通过下图方式获取 Token :</li>
<li>刷新 Jwt Token<br>我们在 Spring Security 实战干货：手把手教你实现JWT Token 中已经实现了 Json Web Token 都是成对出现的逻辑。accessToken 用来接口请求， refreshToken 用来刷新 accessToken 。我们可以同样定义一个 Filter 可参照 上面的 JwtAuthenticationFilter 。只不过 这次请求携带的是 refreshToken，我们在过滤器中拦截 URI跟我们定义的刷新端点进行匹配。同样验证 Token ，通过后像登录成功一样返回 Token 对即可</li>
</ol>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.csdn.net/nvluco/article/details/86406324" target="_blank" rel="noopener">https://blog.csdn.net/nvluco/article/details/86406324</a><br><a href="https://blog.csdn.net/a294634473/article/details/100930212" target="_blank" rel="noopener">https://blog.csdn.net/a294634473/article/details/100930212</a><br><a href="https://blog.csdn.net/wtdemeil/article/details/98486449" target="_blank" rel="noopener">https://blog.csdn.net/wtdemeil/article/details/98486449</a><br><a href="https://blog.csdn.net/killdrsa/article/details/89147431" target="_blank" rel="noopener">https://blog.csdn.net/killdrsa/article/details/89147431</a><br><a href="https://stackoverflow.com/questions/44171633/spring-boot-oauth2-access-is-denied-user-is-anonymous-redirecting-to-authen?rq=1" target="_blank" rel="noopener">https://stackoverflow.com/questions/44171633/spring-boot-oauth2-access-is-denied-user-is-anonymous-redirecting-to-authen?rq=1</a><br><a href="https://blog.csdn.net/Amor_Leo/article/details/101751690" target="_blank" rel="noopener">https://blog.csdn.net/Amor_Leo/article/details/101751690</a><br><a href="https://github.com/SophiaLeo/sophia_scaffolding" target="_blank" rel="noopener">https://github.com/SophiaLeo/sophia_scaffolding</a></p>
<hr>
<h2 id="RBAC权限控制概念的理解"><a href="#RBAC权限控制概念的理解" class="headerlink" title="RBAC权限控制概念的理解"></a>RBAC权限控制概念的理解</h2><ol>
<li><p>前言<br>欢迎阅读 Spring Security 实战干货系列文章 。截止到上一篇我们已经能够简单做到用户主体认证到接口的访问控制了，但是依然满足不了实际生产的需要。 如果我们需要一个完整的权限管理系统就必须了解一下 RBAC (Role-Based Access Control基于角色的访问控制) 的权限控制模型。</p>
</li>
<li><p>为什么需要 RBAC？<br>在正式讨论 RBAC 模型之前，我们要思考一个问题，为什么我们要做角色权限系统？ 答案很明显，一个系统肯定具有不同访问权限的用户。比如付费用户和非付费用户的权限，如果你是 QQ音乐的会员那么你能听高音质的歌曲，如果不是就不能享受某些便利的、优质的服务。那么这是一成不变的吗？又时候为了流量增长或者拉新的需要，我们又可能把一些原来充钱才能享受的服务下放给免费用户。如果你有了会员等级那就更加复杂了，VIP1 跟 VIP2 具有的功能肯定又有所差别了。主流的权限管理系统都是 RBAC 模型的变形和运用，只是根据不同的业务和设计方案，呈现不同的显示效果。<br>下图展示了用户和角色以及资源的简单关系：</p>
</li>
</ol>
<p>rbacflow.png</p>
<p>那为什么不直接给用户分配权限，还多此一举的增加角色这一环节呢？当然直接给用户具体的资源访问控制权限也不是不可以。只是这样做的话就少了一层关系，扩展性弱了许多。如果你的系统足够简单就不要折腾 RBAC 了，怎么简单就怎么玩。如果你的系统需要考虑扩展性和权限控制的多样性就必须考虑 RBAC 。<br>如果你有多个具有相同权限的用户，再分配权限的时候你就需要重复为用户去 Query (查询) 和 Add (赋予) 权限，如果你要修改，比如上面的 VIP1 增加一个很 Cool 的功能,你就要遍历 VIP1 用户进行修改。有了角色后，我们只需要为该角色制定好权限后，将相同权限的用户都指定为同一个角色即可，便于权限管理。<br>对于批量的用户权限调整，只需调整该用户关联的角色权限，无需遍历，既大幅提升权限调整的效率，又降低了漏调权限的概率。这样用户和资源权限解除了耦合性，这就是 RBAC 模型的优势所在。</p>
<ol start="3">
<li>RBAC 模型的分类<br>RBAC 模型可以分为：RBAC0、RBAC1、RBAC2、RBAC3 四种。其中 RBAC0 是基础，其它三种都是在 RBAC0 基础上的变种。大部分情况下，使用 RBAC0 模型就可以满足常规的权限管理系统设计了。不过一定不要拘泥于模型，要以业务需要为先导。接下来简单对四种模型进行简单的介绍一下。</li>
</ol>
<p>3.1 RBAC0<br>RBAC0 是基础，定义了能构成 RBAC 权限控制系统的最小的集合，RBAC0 由四部分构成：</p>
<p>用户（User） 权限的使用主体</p>
<p>角色（Role） 包含许可的集合</p>
<p>会话（Session）绑定用户和角色关系映射的中间通道。而且用户必须通过会话才能给用户设置角色。</p>
<p>许可（Pemission） 对特定资源的特定的访问许可。</p>
<p>rbac0.png</p>
<p>3.2 RBAC1<br>RBAC1 在 RBAC0 的基础之上引入了角色继承的概念，有了继承那么角色就有了上下级或者等级关系。父角色拥有其子角色所有的许可。通俗讲就是来说： 你能干的，你的领导一定能干，反过来就不一定能行。</p>
<p>rbac1.png</p>
<p>3.3 RBAC2<br>在体育比赛中，你不可能既是运动员又是裁判员！</p>
<p>这是很有名的一句话。反应了我们经常出现的一种职务（其实也就是角色）冲突。有些角色产生的历史原因就是为了制约另一个角色，裁判员就是为了制约运动员从而让运动员按照规范去比赛。如果一个人兼任这两个角色，比赛必然容易出现不公正的情况从而违背竞技公平性准则。还有就是我们每个人在不同的场景都会充当不同的角色，在公司你就是特定岗位的员工，在家庭中你就是一名家庭成员。随着场景的切换，我们的角色也在随之变化。<br>所以 RBAC2 在 RBAC0 的基础上引入了静态职责分离（Static Separation of Duty，简称SSD）和动态职责分离（Dynamic Separation of Duty，简称DSD）两个约束概念。他们两个作用的生命周期是不同的;</p>
<p>SSD 作用于约束用户和角色绑定时。 1.互斥角色：就像上面的例子你不能既是A又是B，互斥的角色只能二选一 ; 2. 数量约束：用户的角色数量是有限的不能多于某个基数； 3. 条件约束：只能达到某个条件才能拥有某个角色。经常用于用户等级体系，只有你充钱成为VIP才能一刀999。<br>DSD 作用于会话和角色交互时。当用户持有多个角色，在用户通过会话激活角色时加以条件约束，根据不同的条件执行不同的策略。<br>图就不画了就是在 RBAC0 加了上述两个约束。</p>
<p>3.4 RBAC3<br>我全都要!</p>
<p>RBAC1 和 RBAC2 各有神通。当你拿着这两个方案给产品经理看时，他给了你一个坚定的眼神：我全都要！ 于是 RBAC3 就出现了。也就是说 RBAC3 = RBAC1 + RBAC2 。</p>
<ol start="4">
<li>RBAC 中一些概念的理解<br>四个模型说完，我们来简单对其中的一些概念进行进一步的了解。</li>
</ol>
<p>4.1 用户（User）<br>对用户的理解不应该被局限于单个用户，也可以是用户组（类似 linux 的 User Group）, 或许还有其它的名字比如部门或者公司；也可以是虚拟的账户，客户，甚至说第三方应用也可以算用户 。所以对用户的理解要宽泛一些，只要是有访问资源需求的主体都可以纳入用户范畴。</p>
<p>4.2 角色（Role）<br>角色是特定许可的集合以及载体。一个角色可以包含多个用户，一个用户同样的也可以属于多个角色；同样的一个角色可以包含多个用户组，一个用户组也可以具有多个角色，所以角色和用户是多对多的关系。角色是可以细分的，也就是可以继承、可以分组的。</p>
<p>4.3 许可（Permission）<br>许可一般称它为权限。通常我们将访问的目标统称为资源，不管是数据还是静态资源都是资源。我们访问资源基本上又通过 api 接口来访问。所以一般权限都体现在对接口的控制上。再细分的话我将其划分为菜单控制，具体数据增删改查功能控制（前台体现为按钮）。另外许可具有原子性，不可再分。我们将许可授予角色时就是粒度最小的单元。</p>
<ol start="5">
<li>总结<br>基于角色的访问控制（RBAC）已成为高级访问控制的主要方法之一。通过RBAC，您可以控制最终用户在广义和精细级别上可以做什么。您可以指定用户是管理员，专家用户还是最终用户，并使角色和访问权限与组织中员工的职位保持一致。仅根据需要为员工完成工作的足够访问权限来分配权限。通过上面的介绍相信一定会让你有所收获。对我接下来的 Spring Security 实战干货 集成 RBAC 也是提前预一下热。其实不管你使用什么安全框架， RBAC 都是必须掌握的</li>
</ol>
<hr>
<h2 id="基于配置的接口角色访问控制"><a href="#基于配置的接口角色访问控制" class="headerlink" title="基于配置的接口角色访问控制"></a>基于配置的接口角色访问控制</h2><ol>
<li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。对于受限的访问资源，并不是对所有认证通过的用户开放的。比如 A 用户的角色是会计，那么他就可以访问财务相关的资源。B 用户是人事，那么他只能访问人事相关的资源。我们在 一文中也对基于角色的访问控制的相关概念进行了探讨。在实际开发中我们如何对资源进行角色粒度的管控呢？今天我来告诉你 Spring Security 是如何来解决这个问题的。</p>
</li>
<li><p>将角色写入 UserDetails<br>我们使用 UserDetailsService 加载 UserDetails 时也会把用户的 GrantedAuthority 权限集写入其中。你可以将角色持久化并在这个点进行注入然后配置访问策略，后续的问题交给 Spring Security 。</p>
</li>
<li><p>在 HttpSecurity 中进行配置角色访问控制<br>我们可以通过配置 WebSecurityConfigurerAdapter 中的 HttpSecurity 来控制接口的角色访问。</p>
</li>
</ol>
<p>3.1 通过判断用户是否持有角色来进行访问控制<br>httpSecurity.authorizeRequests().antMatchers(“/foo/test”).hasRole(“ADMIN”)</p>
<p>表示 持有 ROLE_ADMIN 角色的用户才能访问 /foo/test 接口。注意：hasRole(String role) 方法入参不能携带前缀 ROLE_ 。我们来查看 SecurityExpressionRoot 中相关源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasRole(String role) &#123;</span><br><span class="line">    return hasAnyRole(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显 hasRole 方法源于 hasAnyRole (持有任何其中角色之一，就能满足访问条件，用于一个接口开放给多个角色访问时) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasAnyRole(String... roles) &#123;</span><br><span class="line">    return hasAnyAuthorityName(defaultRolePrefix, roles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个接口开放给多个角色，比如 /foo/test 开放给了 ROLE_APP 和 ROLE_ADMIN 可以这么写：</p>
<p>httpSecurity.authorizeRequests().antMatchers(“/foo/test”).hasAnyRole(“APP”,”ADMIN”)</p>
<p>hasAnyRole 方法最终的实现为 hasAnyAuthorityName(String prefix, String… roles):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private boolean hasAnyAuthorityName(String prefix, String... roles) &#123;</span><br><span class="line">    Set&lt;String&gt; roleSet &#x3D; getAuthoritySet();</span><br><span class="line"></span><br><span class="line">    for (String role : roles) &#123;</span><br><span class="line">        String defaultedRole &#x3D; getRoleWithDefaultPrefix(prefix, role);</span><br><span class="line">        if (roleSet.contains(defaultedRole)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面才是根本的实现, 需要一个 prefix 和每一个 role 进行拼接，然后用户的角色集合 roleSet 中包含了就返回true 放行，否则就 false 拒绝。默认的 prefix 为 defaultRolePrefix= ROLE_ 。</p>
<p>3.2 通过判断用户的 GrantedAuthority 来进行访问控制<br>我们也可以通过 hasAuthority 和 hasAnyAuthority 来判定。 其实底层实现和 hasAnyRole 方法一样，只不过 prefix 为 null 。也就是你写入的 GrantedAuthority 是什么样子的，这里传入参数的就是什么样子的，不再受 ROLE_ 前缀的制约。</p>
<p>2.1 章节的写法等同如下的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).hasAuthority(“ROLE_ADMIN”)</span><br><span class="line"></span><br><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).hasAnyAuthority(“ROLE_APP”,”ROLE_ADMIN”)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>匿名访问<br>匿名身份验证的用户和未经身份验证的用户之间没有真正的概念差异。Spring Security 的匿名身份验证只是为您提供了一种更方便的方式来配置访问控制属性。所有的匿名用户都持有角色 ROLE_ANONYMOUS 。所以你可以使用 2.1 和 2.2 章节的方法来配置匿名访问:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).hasAuthority(“ROLE_ANONYMOUS”)</span><br></pre></td></tr></table></figure>
你也可以通过以下方式进行配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).anonymous()</span><br></pre></td></tr></table></figure></li>
<li>开放请求<br>开放请求可以这么配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).permitAll()</span><br></pre></td></tr></table></figure></li>
<li>permitAll 与 anonymous 的一些探讨<br>开放请求 其实通常情况下跟 匿名请求 有交叉。它们的主要区别在于： 当前的 Authentication 为 null 时 permitAll 是放行的，而 anonymous 需要 Authentication 为 AnonymousAuthenticationToken 。这里是比较难以理解的，下面是来自 Spring 文档中的一些信息：</li>
</ol>
<p>通常，采用“默认拒绝”的做法被认为是一种良好的安全做法，在该方法中，您明确指定允许的内容，并禁止其他所有内容。定义未经身份验证的用户可以访问的内容的情况与此类似，尤其是对于Web应用程序。许多站点要求用户必须通过身份验证才能使用少数几个URL（例如，主页和登录页面）。在这种情况下，最简单的是为这些特定的URL定义访问配置属性，而不是为每个受保护的资源定义访问配置属性。换句话说，有时很高兴地说默认情况下需要ROLE_SOMETHING，并且只允许该规则的某些例外，例如应用程序的登录，注销和主页。您还可以从过滤器链中完全忽略这些页面，从而绕过访问控制检查，<br>这就是我们所说的匿名身份验证。</p>
<p>使用 permitAll() 将配置授权，以便在该特定路径上允许所有请求（来自匿名用户和已登录用户）,anonymous() 主要是指用户的状态（是否登录）。基本上，直到用户被“认证”为止，它就是“匿名用户”。就像每个人都有“默认角色”一样。</p>
<h2 id="基于注解的接口角色访问控制"><a href="#基于注解的接口角色访问控制" class="headerlink" title="基于注解的接口角色访问控制"></a>基于注解的接口角色访问控制</h2><ol>
<li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。在上一篇 基于配置的接口角色访问控制 我们讲解了如何通过 javaConfig 的方式配置接口的角色访问控制。其实还有一种更加灵活的配置方式 基于注解 。今天我们就来探讨一下。DEMO 获取方式在文末。</p>
</li>
<li><p>Spring Security 方法安全<br>Spring Security 基于注解的安全认证是通过在相关的方法上进行安全注解标记来实现的。</p>
</li>
</ol>
<p>2.1 开启全局方法安全<br>我们可以在任何 @Configuration实例上使用 @EnableGlobalMethodSecurity 注解来启用全局方法安全注解功能。该注解提供了三种不同的机制来实现同一种功能，所以我们单独开一章进行探讨。</p>
<ol start="3">
<li><p>@EnableGlobalMethodSecurity 注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Retention(value &#x3D; java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value &#x3D; &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123; GlobalMethodSecuritySelector.class &#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableGlobalMethodSecurity &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 基于表达式进行方法访问控制</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean prePostEnabled() default false;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 基于 @Secured 注解</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean securedEnabled() default false;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 基于 JSR-250 注解</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean jsr250Enabled() default false;</span><br><span class="line"></span><br><span class="line">    boolean proxyTargetClass() default false;</span><br><span class="line"></span><br><span class="line">    int order() default Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@EnableGlobalMethodSecurity 源码中提供了 prePostEnabled 、securedEnabled 和 jsr250Enabled 三种方式。当你开启全局基于注解的方法安全功能时，也就是使用 @EnableGlobalMethodSecurity 注解时我们需要选择使用这三种的一种或者其中几种。我们接下来将分别介绍它们。</p>
</li>
<li><p>使用 prePostEnabled<br>如果你在 @EnableGlobalMethodSecurity 设置 prePostEnabled 为 true ，则开启了基于表达式的方法安全控制。通过表达式运算结果的布尔值来决定是否可以访问（true 开放， false 拒绝 ）。<br>有时您可能需要执行开启 prePostEnabled 复杂的操作。对于这些实例，您可以扩展 GlobalMethodSecurityConfiguration，确保子类上存在@EnableGlobalMethodSecurity(prePostEnabled = true) 。例如，如果要提供自定义 MethodSecurityExpressionHandler :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)</span><br><span class="line">public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected MethodSecurityExpressionHandler createExpressionHandler() &#123;</span><br><span class="line">        &#x2F;&#x2F; ... create and return custom MethodSecurityExpressionHandler ...</span><br><span class="line">        return expressionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例属于高级操作，一般没有必要。无论是否继承GlobalMethodSecurityConfiguration 都将会开启四个注解。 @PreAuthorize 和 @PostAuthorize 侧重于方法调用的控制；而 @PreFilter 和 @PostFilter 侧重于数据的控制。</p>
</li>
</ol>
<p>4.1 @PreAuthorize<br>在标记的方法调用之前，通过表达式来计算是否可以授权访问。接下来我来总结以下常用的表达式。</p>
<p>基于 SecurityExpressionOperations 接口的表达式，也就是我们在上一文的 javaConfig 配置。示例： @PreAuthorize(“hasRole(‘ADMIN’)”) 必须拥有 ROLE_ADMIN 角色。<br>基于 UserDetails 的表达式，此表达式用以对当前用户的一些额外的限定操作。示例：@PreAuthorize(“principal.username.startsWith(‘Felordcn’)”) 用户名开头为 Felordcn 的用户才能访问。<br>基于对入参的 SpEL表达式处理。关于 SpEL 表达式可参考官方文档。或者通过关注公众号：Felordcn 来获取相关资料。 示例： @PreAuthorize(“#id.equals(principal.username)”) 入参 id 必须同当前的用户名相同。<br>4.2 @PostAuthorize<br>在标记的方法调用之后，通过表达式来计算是否可以授权访问。该注解是针对 @PreAuthorize 。区别在于先执行方法。而后进行表达式判断。如果方法没有返回值实际上等于开放权限控制；如果有返回值实际的结果是用户操作成功但是得不到响应。</p>
<p>4.3 @PreFilter<br>基于方法入参相关的表达式，对入参进行过滤。分页慎用！该过程发生在接口接收参数之前。 入参必须为 java.util.Collection 且支持 remove(Object) 的参数。如果有多个集合需要通过 filterTarget=&lt;参数名&gt; 来指定过滤的集合。内置保留名称 filterObject 作为集合元素的操作名来进行评估过滤。</p>
<p>样例：</p>
<p>// 入参为Collection<String> ids   测试数据 [“Felordcn”,”felord”,”jetty”]</p>
<p>// 过滤掉  felord jetty  为  Felordcn<br>@PreFilter(value = “filterObject.startsWith(‘F’)”,filterTarget = “ids”)<br>// 如果 当前用户持有 ROLE_AD 角色  参数都符合  否则 过滤掉不是 f 开头的<br>// DEMO 用户不持有 ROLE_AD 角色  故而 集合只剩下 felord<br>@PreFilter(“hasRole(‘AD’) or filterObject.startsWith(‘f’)”)<br>4.4 @PostFilter<br>和@PreFilter 不同的是， 基于返回值相关的表达式，对返回值进行过滤。分页慎用！该过程发生接口进行数据返回之前。 相关测试与 @PreFilter 相似，参见文末提供的 DEMO。</p>
<ol start="5">
<li>使用 securedEnabled<br>如果你在 @EnableGlobalMethodSecurity 设置 securedEnabled 为 true ，就开启了角色注解 @Secured ，该注解功能要简单的多，默认情况下只能基于角色（默认需要带前缀 ROLE_）集合来进行访问控制决策。</li>
</ol>
<p>该注解的机制是只要其声明的角色集合（value）中包含当前用户持有的任一角色就可以访问。也就是 用户的角色集合和 @Secured 注解的角色集合要存在非空的交集。 不支持使用 SpEL 表达式进行决策。</p>
<ol start="6">
<li>使用 jsr250Enabled<br>启用 JSR-250 安全控制注解，这属于 JavaEE 的安全规范（现为 jakarta 项目）。一共有五个安全注解。如果你在 @EnableGlobalMethodSecurity 设置 jsr250Enabled 为 true ，就开启了 JavaEE 安全注解中的以下三个：</li>
</ol>
<p>@DenyAll 拒绝所有的访问<br>@PermitAll 同意所有的访问<br>@RolesAllowed 用法和 5. 中的 @Secured 一样。<br>7. 总结<br>今天讲解了 Spring Security 另一种基于注解的静态配置。相比较基于 javaConfig 的方式要灵活一些、粒度更细、基于 SpEL 表达式可以实现更加强大的功能。但是这两种的方式还是基于编程的静态方式，具有一定的局限性。更加灵活的方式应该是动态来处理用户的角色和资源的映射关系</p>
<hr>
<h2 id="SecurityContext相关的知识"><a href="#SecurityContext相关的知识" class="headerlink" title="SecurityContext相关的知识"></a>SecurityContext相关的知识</h2><ol>
<li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。在前两篇我们讲解了 基于配置 和 基于注解 来配置访问控制。今天我们来讲一下如何在接口访问中检索当前认证用户信息。<br>我们先讲一下具体的场景。通常我们在认证后访问需要认证的资源时需要获取当前认证用户的信息。比如 “查询我的个人信息”。如果你直接在接口访问时显式的传入你的 UserID 肯定是不合适的。因为你认证通过后访问资源，系统是知道你是谁的。而且显式的暴露用户的检索接口也不安全。所以我们需要一个业务中可以检索当前认证用户的工具。 接下来我们来看看 Spring Security 是如何解决这个痛点的。</p>
</li>
<li><p>安全上下文 SecurityContext<br>不知道你有没有留意Spring Security 实战干货：使用 JWT 认证访问接口 中是如何实现 JWT 认证拦截器 JwtAuthenticationFilter 。当服务端对 JWT Token 认证通过后，会将认证用户的信息封装到 UsernamePasswordAuthenticationToken 中 并使用工具类放入安全上下文 SecurityContext 中，当服务端响应用户后又使用同一个工具类将 UsernamePasswordAuthenticationToken 从 SecurityContext 中 clear 掉。<br>我们来简单了解 SecurityContext 具体是个什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.security.core.context;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import org.springframework.security.core.Authentication;</span><br><span class="line"></span><br><span class="line">public interface SecurityContext extends Serializable &#123;</span><br><span class="line">    Authentication getAuthentication();</span><br><span class="line"></span><br><span class="line">    void setAuthentication(Authentication var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码上来看很简单就是一个 存储 Authentication 的容器。而 Authentication 是一个用户凭证接口用来作为用户认证的凭证使用，通常常用的实现有 认证用户 UsernamePasswordAuthenticationToken 和 匿名用户AnonymousAuthenticationToken。其中 UsernamePasswordAuthenticationToken 包含了 UserDetails , AnonymousAuthenticationToken 只包含了一个字符串 anonymousUser 作为匿名用户的标识。我们通过 SecurityContext 获取上下文时需要来进行类型判断。接下来我们来聊聊操作 SecurityContext 的工具类。</p>
</li>
<li><p>SecurityContextHolder<br>这个工具类就是 SecurityContextHolder 。 它提供了两个有用的方法：</p>
</li>
</ol>
<p>setContext 设置当前的 SecurityContext<br>getContext 获取当前的 SecurityContext , 进而你可以获取到当前认证用户。<br>clearContext 清除当前的 SecurityContext<br>平常我们通过这三个方法来操作安全上下文 SecurityContext 。你可以直接在代码中使用工具类 SecurityContextHolder 获取用户信息，像下面一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> public String getCurrentUser() &#123;</span><br><span class="line">    Authentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">     if (authentication instanceof AnonymousAuthenticationToken)&#123;</span><br><span class="line">         return &quot;anonymousUser&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">    UserDetails principal &#x3D; (UserDetails) authentication.getPrincipal();</span><br><span class="line">    return principal.getUsername();</span><br><span class="line"> &#125;  </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">通过上面的自定义方法就可以解析到 UserDetails 的用户信息,你可以扩展 UserDetails 使得信息符合你的业务需要。上面方法中的判断是必须的，如果是匿名用户（AnonymousAuthenticationToken）返回的 Principal 类型是一个字符串 anonymousUser 。</span><br><span class="line"></span><br><span class="line">3.1 扩展知识：SecurityContextHolder 存储策略</span><br><span class="line">这里也扩展一下知识面，简单讲一下 SecurityContextHolder 是如何存储 SecurityContext 的。SecurityContextHolder 默认有三种存储 SecurityContext 的策略：</span><br><span class="line"></span><br><span class="line">MODE_THREADLOCAL 利用ThreadLocal 机制来保存每个使用者的 SecurityContext，缺省策略，平常我们使用这个就行了。</span><br><span class="line">MODE_INHERITABLETHREADLOCAL 利用InheritableThreadLocal 机制来保存每个使用者的 SecurityContext。多用于多线程环境环境下。</span><br><span class="line">MODE_GLOBAL 静态机制，作用域为全局。目前不太常用。</span><br><span class="line">4. 总结</span><br><span class="line">SecurityContext 是 Spring Security 中的一个非常重要类，今天不但介绍 SecurityContext 是什么、有什么作用，也对以前讲过的一些知识进行回顾。</span><br><span class="line">也对如何使用 SecurityContextHolder 操作 SecurityContext 进行了讲解。最后也简单讲述了 SecurityContextHolder 三种存储 SecurityContext 的策略和使用场景 </span><br><span class="line"></span><br><span class="line">## 动态权限控制（上）思路</span><br><span class="line">1. 前言</span><br><span class="line">欢迎阅读 Spring Security 实战干货系列文章 。截止目前已经对 基于配置 和 基于注解 的角色访问控制进行了讲解。对于一些小项目来说基本是够用的。然而如果希望运营管理人员能够动态的配置和分配权限，以上两种方式显然是满足不了需求的。接下来我们来一起探讨一下思路。</span><br><span class="line"></span><br><span class="line">2. 动态的权限控制同样依赖 RBAC 模型</span><br><span class="line">我们依然应该在 RBAC 及其变种的基础上构建动态的权限控制系统。所有被访问的目标，无论是 API、静态资源都应该是关联了角色的东西统称为 资源（Resource）。我们需要建立起角色和资源之间的关系。</span><br><span class="line"></span><br><span class="line">2.1 资源映射到角色</span><br><span class="line">下面是一个资源到角色的映射关系图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模型大致如上所示，每一个资源对应一个可能无重复的角色集（Set 集合）；你可以注意到一个细节 Role 1 既指向 Resource 1 又指向 Resource 2 中，这是可以理解的，毕竟有可能对同一资源的访问权可能分散到多个角色中去；当然也可以互斥这取决于你的业务。</span><br><span class="line">我们选择资源映射到角色是因为当请求时，资源是唯一的而角色可能是多个，如果进行反转的话解析的效率低一些。</span><br><span class="line"></span><br><span class="line">3. 请求认证过程</span><br><span class="line">这里有很多搞法，但是总体的思路是我们的请求肯定是带下面两个东西（起码在走到进行访问决策这一步是必须有的）：</span><br><span class="line"></span><br><span class="line">URI 访问资源必然要用 URI 来定位，我们同样通过 URI 来和资源接口进行匹配；最好是 Ant match，因为&#x2F;user&#x2F;1 和 &#x2F;user&#x2F;2 有可能访问的是同一个资源接口。如果你想避免这种情况，要么在开发规约中禁止这种风格，这样的好处是配置人员可以不必熟悉 Ant 风格；要么必须让配置人员掌握 Ant 风格。</span><br><span class="line">Principal ，Spring Security 中为 Authentication （认证主体），之前讲过的一个比较绕的概念，Spring Security 中的用户身份有两种 一种是 认证用户 另一种是 匿名用户 ，它们都包含角色。拿到角色到角色集进行匹配。</span><br><span class="line">然后我画了一个下面的图来更加清晰的展示一下流程：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 如何结合安全框架</span><br><span class="line">虽然本文是 Spring Security 系列的，但是我们如果使用其它安全框架或者自己研发安全框架都可以依据上面的思路。如果需要用编程语言总结一下就是我们需要两个接口来协同：</span><br><span class="line"></span><br><span class="line">获取资源角色关系这些元数据的接口 这是我们动态权限控制的基石，只有将角色和资源的映射关系接口化才能动态的进行权限控制。 这里没有唯一标准，根据你的业务来设计。</span><br><span class="line">对 Request 进行解析并和提取的元数据进行匹配的接口 这是我们动态权限控制的最终逻辑实现。 这里的规则同样也没有唯一标准</span><br><span class="line">抓住了这两点之后我们就非常了然了，无非实现一个具有这两种功能的 Filter ，注入安全框架的过滤链中的合适位置中。要么你可以自己造个轮子，要么你使用现在有的轮子。那么有没有现成的轮子呢？ 我一般建议如果你在造轮子前先看看你选型的安全框架有没有现成的轮子可用。当现成有轮子可用并且能够满足你的需要时往往能够事半功倍。如果没有合适的就造一个！</span><br><span class="line"></span><br><span class="line">5. 总结</span><br><span class="line">本篇主要理清一下动态权限所需要的一些要点，并对请求认证的过程进行了分析。最后对结合安全框架定制也提供了一些个人的见解。实现也写了大部分，之所以拆分成上下篇，因为理论和实现放在一篇的话实在有点篇幅过长，分成上篇理论、下篇实践更加合适</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 动态权限控制（下）实现</span><br><span class="line"></span><br><span class="line">1. Spring Security 提供的轮子</span><br><span class="line">Spring Security 实战干货：内置 Filter 全解析 中提到的第 32 个 Filter 不知道你是否有印象。它决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？ 它就是 FilterSecurityInterceptor ，正是我们需要的那个轮子。</span><br><span class="line"></span><br><span class="line">2. FilterSecurityInterceptor</span><br><span class="line">过滤器排行榜第 32 位！肩负对接口权限认证的重要职责。我们来看它的过滤逻辑：</span><br></pre></td></tr></table></figure>
<p>public void doFilter(ServletRequest request, ServletResponse response,<br>        FilterChain chain) throws IOException, ServletException {<br>    FilterInvocation fi = new FilterInvocation(request, response, chain);<br>    invoke(fi);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化了一个 FilterInvocation 然后被 invoke 方法处理：</span><br></pre></td></tr></table></figure>
<p>public void invoke(FilterInvocation fi) throws IOException, ServletException {<br>    if ((fi.getRequest() != null)<br>            &amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != null)<br>            &amp;&amp; observeOncePerRequest) {<br>        // filter already applied to this request and user wants us to observe<br>        // once-per-request handling, so don’t re-do security checking<br>        fi.getChain().doFilter(fi.getRequest(), fi.getResponse());<br>    }<br>    else {<br>        // first time this request being called, so perform security checking<br>        if (fi.getRequest() != null &amp;&amp; observeOncePerRequest) {<br>            fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);<br>        }</p>
<pre><code>    InterceptorStatusToken token = super.beforeInvocation(fi);

    try {
        fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
    }
    finally {
        super.finallyInvocation(token);
    }

    super.afterInvocation(token, null);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">每一次请求被 Filter 过滤都会被打上标记 FILTER_APPLIED，没有被打上标记的 走了父类的 beforeInvocation 方法然后再进入过滤器链，看上去是走了一个前置的处理。那么前置处理了什么呢?</span><br><span class="line">首先会通过 this.obtainSecurityMetadataSource().getAttributes(Object object) 拿受保护对象（就是当前请求的URI）所有的映射角色（ConfigAttribute 直接理解为角色的进一步抽象） 。然后使用访问决策管理器 AccessDecisionManager 进行投票决策来确定是否放行。 我们来看一下这两个接口。</span><br><span class="line"></span><br><span class="line">安全拦截器和“安全对象”模型参考：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. FilterInvocationSecurityMetadataSource</span><br><span class="line">这个接口是 FilterSecurityInterceptor 的属性，UML图如下：</span><br><span class="line"></span><br><span class="line">FilterInvocationSecurityMetadataSource 是一个标记接口，其抽象方法继承自 SecurityMetadataSource&#96;&#96;AopInfrastructureBean 。它的作用是来获取我们上一篇文章所描述的资源角色元数据。</span><br><span class="line"></span><br><span class="line">Collection getAttributes(Object object) 根据提供的受保护对象的信息，其实就是URI，获取该URI 配置的所有角色</span><br><span class="line">Collection getAllConfigAttributes() 这个就是获取全部角色</span><br><span class="line">boolean supports(Class&lt;?&gt; clazz) 对特定的安全对象是否提供 ConfigAttribute 支持</span><br><span class="line">3.1 自定义实现 FilterInvocationSecurityMetadataSource 的思路分析</span><br><span class="line">所有的思路仅供参考，实际以你的业务为准！</span><br><span class="line"></span><br><span class="line">Collection&lt;ConfigAttribute&gt; getAttributes(Object object) 方法的实现：肯定是获取请求中的 URI 来和 所有的 资源配置中的 Ant Pattern 进行匹配以获取对应的资源配置, 这里需要将资源查询接口查询的资源配置封装为 AntPathRequestMatcher以方便进行 Ant Match 。</span><br><span class="line">这里需要特别提一下如果你使用 Restful 风格，这里 增删改查 将非常方便你来对资源的管控。参考的实现：</span><br></pre></td></tr></table></figure>
<p> @Bean<br> public RequestMatcherCreator requestMatcherCreator() {<br>   return metaResources -&gt; metaResources.stream()<br>           .map(metaResource -&gt; new AntPathRequestMatcher(metaResource.getPattern(), metaResource.getMethod()))<br>           .collect(Collectors.toSet());<br> }<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest 匹配到对应的资源配置后就能根据资源配置去取对应的角色集合。这些角色将交给访问决策管理器 AccessDecisionManager 进行投票表决以决定是否放行。</span><br><span class="line"></span><br><span class="line">4. AccessDecisionManager</span><br><span class="line">决策管理器，用来投票决定是否放行请求。</span><br></pre></td></tr></table></figure><br>  public interface AccessDecisionManager {<br>    // 决策 主要通过其持有的 AccessDecisionVoter 来进行投票决策<br>       void decide(Authentication authentication, Object object,<br>               Collection<ConfigAttribute> configAttributes) throws AccessDeniedException,<br>               InsufficientAuthenticationException;<br>   // 以确定AccessDecisionManager是否可以处理传递的ConfigAttribute<br>       boolean supports(ConfigAttribute attribute);<br>   //以确保配置的AccessDecisionManager支持安全拦截器将呈现的安全 object 类型。<br>       boolean supports(Class&lt;?&gt; clazz);<br>   }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">AccessDecisionManager 有三个默认实现：</span><br><span class="line"></span><br><span class="line">AffirmativeBased 基于肯定的决策器。 用户持有一个同意访问的角色就能通过。</span><br><span class="line">ConsensusBased 基于共识的决策器。 用户持有同意的角色数量多于禁止的角色数。</span><br><span class="line">UnanimousBased 基于一致的决策器。 用户持有的所有角色都同意访问才能放行。</span><br><span class="line">投票决策模型参考：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.1 自定义 AccessDecisionManager</span><br><span class="line">动态控制权限就需要我们实现自己的访问决策器。我们上面说了默认有三个实现，这里我选择基于肯定的决策器 AffirmativeBased，只要用户持有一个持有一个角色包含想要访问的资源就能访问该资源。接下来就是投票器 AccessDecisionVoter 的定义了，其实我们可以选择内置的</span><br><span class="line"></span><br><span class="line">5. AccessDecisionVoter</span><br><span class="line">AccessDecisionVoter 将安全配置属性 ConfigAttribute 以特定的逻辑进行解析并基于特定的策略来进行投票，投赞成票时总票数 +1 ，反对票总票数 -1 ，弃权时总票数 +0 , 然后由 AccessDecisionManager 根据具体的计票策略来决定是否放行。</span><br><span class="line"></span><br><span class="line">5.1 角色投票器 RoleVoter</span><br><span class="line">Spring Security 提供的最常用的投票器是角色投票器 RoleVoter，它将安全配置属性 ConfigAttribute 视为简单的角色名称，并在用户被分配了该角色时授予访问权限。</span><br><span class="line">如果任何 ConfigAttribute 以前缀 ROLE_ 开头，它将投票。如果有一个 GrantedAuthority 返回一个字符串(通过 getAuthority() 方法)正好等于一个或多个从前缀 ROLE_ 开始的 ConfigAttributes，它将投票授予访问权限。如果没有任何以 ROLE_开头的 ConfigAttributes匹配，则 RoleVoter 将投票拒绝访问。如果没有 ConfigAttribute 以ROLE_为前缀，将弃权。</span><br><span class="line">这正是我们想要的投票器。</span><br><span class="line"></span><br><span class="line">5.2 角色分层投票器 RoleHierarchyVoter</span><br><span class="line">通常要求应用程序中的特定角色应自动“包含”其他角色。例如，在具有 ROLE_ADMIN 和 ROLE_USER 角色概念的应用中，您可能希望管理员能够执行普通用户可以执行的所有操作。你不得不进行各种复杂的逻辑嵌套来满足这一需求。现在幸好有了 RoleHierarchyVoter 可以帮你减少这种负担。</span><br><span class="line">它由上面的 RoleVoter 派生,通过配置了一个 RoleHierarchy就可以实现 ROLE_ADMIN ⇒ ROLE_STAFF ⇒ ROLE_USER ⇒ ROLE_GUEST 这种层次包含结构，左边的一定能访问右边可以访问的资源。具体的配置规则为：角色从左到右、从高到低以 &gt; 相连（注意两个空格），以换行符 \n 为分割线。举个例子</span><br><span class="line"></span><br><span class="line">   ROLE_ADMIN &gt; ROLE_STAFF</span><br><span class="line">   ROLE_STAFF &gt; ROLE_USER</span><br><span class="line">   ROLE_USER &gt; ROLE_GUEST</span><br><span class="line">请注意动态配置中你需要自行实现角色分层的逻辑。DEMO 中并未对该风格进行实现。</span><br><span class="line"></span><br><span class="line">6. 配置</span><br><span class="line">配置需要两个方面。</span><br><span class="line"></span><br><span class="line">6.1 自定义组件的配置</span><br><span class="line">我们需要将元数据加载器 和 访问决策器注入 Spring IoC ：</span><br></pre></td></tr></table></figure>
<p> /**</p>
<ul>
<li><p>动态权限组件配置</p>
</li>
<li></li>
<li><p>@author Felordcn</p>
</li>
<li><p>/<br>@Configuration<br>public class DynamicAccessControlConfiguration {<br>  /**</p>
<ul>
<li><p>RequestMatcher 生成器</p>
</li>
<li><p>@return RequestMatcher</p>
</li>
<li><p>/<br>@Bean<br>public RequestMatcherCreator requestMatcherCreator() {<br>  return metaResources -&gt; metaResources.stream()</p>
<pre><code>.map(metaResource -&gt; new AntPathRequestMatcher(metaResource.getPattern(), metaResource.getMethod()))
.collect(Collectors.toSet());</code></pre><p>}</p>
<p>/**</p>
</li>
<li><p>元数据加载器</p>
</li>
<li></li>
<li><p>@return dynamicFilterInvocationSecurityMetadataSource</p>
</li>
<li><p>/<br>@Bean<br>public FilterInvocationSecurityMetadataSource dynamicFilterInvocationSecurityMetadataSource() {<br>  return new DynamicFilterInvocationSecurityMetadataSource();<br>}</p>
<p>/**</p>
</li>
<li><p>角色投票器</p>
</li>
<li><p>@return roleVoter</p>
</li>
<li><p>/<br>@Bean<br>public RoleVoter roleVoter() {<br>  return new RoleVoter();<br>}</p>
<p>/**</p>
</li>
<li><p>基于肯定的访问决策器</p>
</li>
<li></li>
<li><p>@param decisionVoters  AccessDecisionVoter类型的 Bean 会自动注入到 decisionVoters</p>
</li>
<li><p>@return affirmativeBased</p>
</li>
<li><p>/<br>@Bean<br>public AccessDecisionManager affirmativeBased(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters) {<br>  return new AffirmativeBased(decisionVoters);<br>}</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring Security 的 Java Configuration 不会公开它配置的每个 object 的每个 property。这简化了大多数用户的配置。</span><br><span class="line">虽然有充分的理由不直接公开每个 property，但用户可能仍需要像本文一样的取实现个性化需求。为了解决这个问题，Spring Security 引入了 ObjectPostProcessor 的概念，它可用于修改或替换 Java Configuration 创建的许多 Object 实例。 FilterSecurityInterceptor 的替换配置正是通过这种方式来进行：</span><br></pre></td></tr></table></figure>
<p>@Configuration<br>@ConditionalOnClass(WebSecurityConfigurerAdapter.class)<br>@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)<br>public class CustomSpringBootWebSecurityConfiguration {<br> private static final String LOGIN_PROCESSING_URL = “/process”;</p>
<p> /**</p>
<ul>
<li><p>Json login post processor json login post processor.</p>
</li>
<li></li>
<li><p>@return the json login post processor</p>
</li>
<li><p>/<br>@Bean<br>public JsonLoginPostProcessor jsonLoginPostProcessor() {<br>  return new JsonLoginPostProcessor();<br>}</p>
<p>/**</p>
</li>
<li><p>Pre login filter pre login filter.</p>
</li>
<li></li>
<li><p>@param loginPostProcessors the login post processors</p>
</li>
<li><p>@return the pre login filter</p>
</li>
<li><p>/<br>@Bean<br>public PreLoginFilter preLoginFilter(Collection<LoginPostProcessor> loginPostProcessors) {<br>  return new PreLoginFilter(LOGIN_PROCESSING_URL, loginPostProcessors);<br>}</p>
<p>/**</p>
</li>
<li><p>Jwt 认证过滤器.</p>
</li>
<li></li>
<li><p>@param jwtTokenGenerator jwt 工具类 负责 生成 验证 解析</p>
</li>
<li><p>@param jwtTokenStorage   jwt 缓存存储接口</p>
</li>
<li><p>@return the jwt authentication filter</p>
</li>
<li><p>/<br>@Bean<br>public JwtAuthenticationFilter jwtAuthenticationFilter(JwtTokenGenerator jwtTokenGenerator, JwtTokenStorage jwtTokenStorage) {<br>  return new JwtAuthenticationFilter(jwtTokenGenerator, jwtTokenStorage);<br>}</p>
<p>/**</p>
</li>
<li><p>The type Default configurer adapter.</p>
</li>
<li><p>/<br>@Configuration<br>@Order(SecurityProperties.BASIC_AUTH_ORDER)<br>static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter {</p>
<p>  @Autowired<br>  private JwtAuthenticationFilter jwtAuthenticationFilter;<br>  @Autowired<br>  private PreLoginFilter preLoginFilter;<br>  @Autowired<br>  private AuthenticationSuccessHandler authenticationSuccessHandler;<br>  @Autowired<br>  private AuthenticationFailureHandler authenticationFailureHandler;<br>  @Autowired<br>  private FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;<br>  @Autowired<br>  private AccessDecisionManager accessDecisionManager;</p>
<p>  @Override<br>  protected void configure(AuthenticationManagerBuilder auth) throws Exception {</p>
<pre><code>super.configure(auth);</code></pre><p>  }</p>
<p>  @Override<br>  public void configure(WebSecurity web) {</p>
<pre><code>super.configure(web);</code></pre><p>  }</p>
<p>  @Override<br>  protected void configure(HttpSecurity http) throws Exception {</p>
<pre><code>http.csrf().disable()
        .cors()
        .and()
        // session 生成策略用无状态策略
        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
        .exceptionHandling().accessDeniedHandler(new SimpleAccessDeniedHandler()).authenticationEntryPoint(new SimpleAuthenticationEntryPoint())
        .and()
        //   动态权限配置
        .authorizeRequests().anyRequest().authenticated().withObjectPostProcessor(filterSecurityInterceptorObjectPostProcessor())
        .and()
        .addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)
        // jwt 必须配置于 UsernamePasswordAuthenticationFilter 之前
        .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
        // 登录  成功后返回jwt token  失败后返回 错误信息
        .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)
        .and().logout().addLogoutHandler(new CustomLogoutHandler()).logoutSuccessHandler(new CustomLogoutSuccessHandler());</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li>自定义 FilterSecurityInterceptor  ObjectPostProcessor 以替换默认配置达到动态权限的目的</li>
<li></li>
<li>@return ObjectPostProcessor</li>
<li>/<br>private ObjectPostProcessor<FilterSecurityInterceptor> filterSecurityInterceptorObjectPostProcessor() {<br>  return new ObjectPostProcessor<FilterSecurityInterceptor>() {<pre><code>@Override
public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) {
    object.setAccessDecisionManager(accessDecisionManager);
    object.setSecurityMetadataSource(filterInvocationSecurityMetadataSource);
    return object;
}</code></pre>  };<br>}</li>
</ul>
<p>}<br>}</p>
<pre><code>然后你编写一个 Controller 方法就将其在数据库注册为一个资源进行动态的访问控制了。无须注解或者更详细的 Java Config 配置。
</code></pre></li>
</ul>
</li>
</ul>
<ol start="7">
<li>总结<br>从最开始到现在一共10个 DEMO 。我们循序渐进地从如何学习 Spring Security 到目前实现了基于 RBAC、动态的权限资源访问控制。如果你能坚持到现在那么已经能满足了一些基本开发定制的需要。当然 Spring Security 还有很多局部的一些概念，我也会在以后抽时间进行讲解</li>
</ol>
<h2 id="纠正对-JSON-Web-Token-认识的误区"><a href="#纠正对-JSON-Web-Token-认识的误区" class="headerlink" title="纠正对 JSON Web Token 认识的误区"></a>纠正对 JSON Web Token 认识的误区</h2><p>1.前言<br>JSON Web Token (JWT) 其实目前已经广为软件开发者所熟知了，但是 JOSE (Javascript Object Signing and Encryption) 却鲜有人知道，我第一次知道它是在 Spring Security 的官方文档中，它改变了我对 JWT 的一些认识。目前国内能找到相关中文资料不是太多。所以我觉得有必要归纳一下。</p>
<ol start="2">
<li>JOSE 概述<br>JOSE 是一种旨在提供在各方之间安全传递声明（claims）的方法的规范集。我们常用的 JWT 就包含了允许客户端访问特定应用下特定资源的声明。JOSE 制定了一系列的规范来达到此目的。目前该规范还在不断的发展，我们常用的包含以下几个 RFC :</li>
</ol>
<p>JWS（RFC 7515） -JSON Web签名，描述生成和处理签名消息<br>JWE（RFC 7516） -JSON Web加密，描述了保护和处理加密 消息<br>JWK（RFC 7517） -JSON Web密钥，描述 Javascript 对象签名和加密中加密密钥的 格式和处理<br>JWA（RFC 7518） -JSON Web算法，描述了 Javascript 对象签名和加密中使用的 加密 算法<br>JWT（RFC 7519） -JSON Web令牌，描述以 JSON 编码并由 JWS 或 JWE 保护的声明的表示形式<br>3. 我们都看错了 JWT<br>看了对 JWT 的描述中提到 “令牌以 JWS 或者 JWE 声明表示”。莫非我之前的认知是错误的吗？ 找了一些官方的资料研究了一番后，确实我之前的认知是不够全面的。</p>
<p>官方定义：</p>
<p>JSON Web Token (JWT) is a compact URL-safe means of representing claims to be transferred between two parties</p>
<p>直译过来：JSON Web令牌（JWT）是一种紧凑的URL安全方法，用于表示要在两方之间转移的声明。</p>
<p>也就是说我们通常说的 JWT 实际上是一个对声明进行 JOSE 处理方式的统称。我们之前用的应该叫 JWS(JSON Web Signature)，是 JWT 的一种实现，除了 JWS , JWT 还有另一种实现 JWE(JSON Web Encryption) 。它们之间的关系应该是这样的：</p>
<ol start="4">
<li>什么是 JWE<br>JWS 我们就不说了，就是通常我们所说的 JWT。包括之前我在 Spring Security 实战干货 中所涉及到的 JWT 都是 JWS。我们来说一下 JWE 。JWS 仅仅是对声明(claims)作了签名，保证了其不被篡改，但是其 payload(中段负载) 信息是暴露的。也就是 JWS 仅仅能保证数据的完整性而不能保证数据不被泄露。所以我以前也说过它不适合传递敏感数据。<br>JWE 的出现就是为了解决这个问题的。具体的可以看下图：</li>
</ol>
<p>从上面可以看出 JWE 的生成非常繁琐，作为 Token 可能比较消耗资源和耗时。用作安全的数据传输途径应该不错。</p>
<ol start="5">
<li>Spring Security jose 相关<br>这里需要简单提一下 Spring Security 提供了 JOSE 有关的类库 spring-security-oauth2-jose ，你可以使用该类库来使用 JOSE 。如果 Java 开发者要在 Spring Security 安全框架中使用 OAuth2.0 ，这个类库也是需要研究一下的。</li>
</ol>
<h2 id="简单的认识-OAuth2-0-协议"><a href="#简单的认识-OAuth2-0-协议" class="headerlink" title="简单的认识 OAuth2.0 协议"></a>简单的认识 OAuth2.0 协议</h2><p>1.前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。OAuth2.0 是近几年比较流行的授权机制，对于普通用户来说可能每天你都在用它，我们经常使用的第三方登录大都基于 OAuth2.0。随着应用的互联互通，个性化服务之间的相互调用，开放性的认证授权成为 客观的需要。</p>
<ol start="2">
<li>OAuth2.0 的简单认识<br>OAuth定义了如下角色，并明确区分了它们各自的关注点，以确保快速构建一致性的授权服务：</li>
</ol>
<p>Resource Owner 资源拥有者，通常指的是终端用户，其作用是同意或者拒绝、甚至是选择性的给第三方应用程序的授权请求。<br>User Agent 用户代理 指的的资源拥有者授权的一些渠道。一般指的是浏览器、APP<br>Client 请求授权和请求访问受限资源的客户端程序。<br>Authorization Server 对用户授权进行鉴别并根据鉴别结果进行同意或拒绝的授权响应的服务器。<br>Resource Server 能够接受和响应受保护资源请求的服务器。<br>单纯的文字性描述是不是有些难以理解。所以我这里讲一个亲身经历的事例来情景化以上的四个概念。马上又到程序员集中面试的季节了，有一年我去面试，到了地方才发现如此的“高大上”，访客需要通过验证码才能通过闸门，于是我联系了面试公司的HR ，后面的流程大概是这样的:</p>
<p>我向面试公司（HR）发送了一个进门的要求。<br>HR 给了我一个可以获取进门许可请求的链接。<br>我通过链接进行进门许可请求。<br>请求得到响应，返给我一个验证码。<br>我在闸门程序中输入验证码。<br>验证通过后放行。<br>在我学习了 OAuth2.0 协议之后我发现这次经历可以体现出 OAuth2.0 的一些设计理念。访客必须通过授权才能访问大楼。这种方式避免了闲杂人等出入办公场所，而且对访客可控（从访问时间和次数上），甚至可以实现对楼层的访问可控（当然上面的例子中没有）。<br>再结合 OAuth2.0 可以知道 访客就是 Client，公司（业主）就是 Resource Owner，物业就是 Authorization Server ，那个闸机就是 Resource Server，闸机有可能也受到物业的管控。 这是那张著名的流程图：</p>
<p>这个例子只是为了快速的来认识 OAuth2.0 ，它是一种有效的、可靠的委托授权框架。它提供了多种授权模式在不同的场景下供你选择。</p>
<ol start="3">
<li>授权模式<br>为了获得访问许可，客户端需要向授权服务器出示有效的授权凭证，也就是说客户端必须得到用户授权（authorization grant）OAuth2.0 提供了多种授权模式供开发者在不同的场景中使用，以下是授权模式的一些总结：</li>
</ol>
<p>授权方式    客户端类型/用例<br>Authorization code    旨在用于具有后端的传统Web应用程序以及本机（移动或桌面）应用程序，以利用通过系统浏览器的单点登录功能。<br>Implicit    适用于不带后端的基于浏览器的（JavaScript）应用程序。<br>Password    对于应用程序和授权服务器属于同一提供程序的受信任本机客户端。<br>Client credentials    客户端以自己的名义来获取许可，而不是以终端用户名义，或者可以说该用户端也是资源拥有者<br>Refresh token    令牌失效后使客户端可以刷新其访问令牌，而不必再次执行代码或 密码授予的步骤。<br>SAML 2.0 bearer    使拥有SAML 2.0断言（登录令牌）的客户端将其交换为OAuth 2.0访问令牌。<br>JWT bearer    拥有一个安全域中的JSON Web令牌断言的客户端将其交换为另一域中的OAuth 2.0访问令牌。<br>Device code    设备的唯一编码，一般该编码不可更改，多用于一些智能设备<br>Token exchange    使用代理模拟的方式获取令牌<br>其中前五种为我们所熟知。我们后续会详细介绍它们。</p>
<ol start="4">
<li>OAuth 2.0 的一些要点<br>摘自《OAuth 2 实战》：</li>
</ol>
<p>由于 OAuth2.0 被定义为一个框架，对于 OAuth2.0 是什么和不是什么，一直未明确。我们所说的 OAuth2.0 是指 OAuth2.0 核心规范中定义的协议，RFC 6749 核心规范详述了一系列获取访问令牌的方法；还包括其伴随规范中定义的 bearer 令牌，RFC 6750该规范规定了这种令牌的用法。获取令牌和使用令牌这两个环节是 OAuth2.0 的基本要素。正如我们将在本节中看到的，在更广泛的 OAuth2.0 生态系统中存在很多其他技术，它们配合 OAuth2.0 核心，提供更多 OAuth2.0 本身不能提供的功能。我们认为，这样的生态系统是协议健康发展的体现，但是不应与协议本身混为一谈。</p>
<p>基于以上的原则 OAuth2.0 有以下一些要点需要明确被认识到：</p>
<p>OAuth2.0 并非身份认证协议，虽然在授权的过程中涉及到身份认证，但是 OAuth2.0 协议本身并不处理用户的信息。客户端访问受保护的资源时并不关心资源的拥有者。<br>OAuth2.0 不提供一些消息签名，为了保证安全性所以不应脱离 Https 。在使用其它协议或者系统时也应该明确一个安全机制来承担 Https 所承担的任务。<br>OAuth2.0 并没有定义加密方式，虽然目前使用的较多的是 JOSE 规范<br>OAuth2.0 虽然令牌被客户端持有并使用，但是客户端并不能解析以及处理令牌。<br>5. 总结<br>OAuth2.0 其实还有个特点，它并不是单体协议。它被分成了多个定义和流程，每个定义和流程都有各自的应用场景</p>
<h2 id="OAuth2-0-技术选型参考"><a href="#OAuth2-0-技术选型参考" class="headerlink" title="OAuth2.0 技术选型参考"></a>OAuth2.0 技术选型参考</h2><ol>
<li><p>前言<br>在使用 OAuth2.0 中 Authorization Server （授权服务器）是一个回避不了的设施，在大多数情况下我们调用的是一些知名的、可靠的、可信任的第三方平台，比如 QQ、微信、微博、github 等。我们的应用只作为 Client 进行注册接入即可。也就是说我们只需要实现 OAuth2.0 客户端的逻辑就可以了，无须关心授权服务器的实现。然而有时候我们依然希望构建自己的 Authorization Server。我们应该如何实现？今天不会讨论具体的技术细节，来谈谈 OAuth2.0 的技术选型。</p>
</li>
<li><p>Spring Security OAuth2 现状<br>在做 Spring Security 相关教程 的时候首先会考虑 Spring 提供的 OAuth2.0 功能。当我去 Spring 官网了解相关的类库时发现居然 Spring 的 OAuth2.0 类库即将过期的通知，有图有真相：</p>
</li>
</ol>
<p>总结以下就是 Spring Security OAuth 的模块即将过期，后续的功能已经迁移到 Spring Security 5.2.x 中，但是不会再提供 Authorization Server 的功能。 在官方声明中还提到， 当前 Spring Security OAuth 分支是 2.3.x 和 2.4.x。2.3.x版本将于2020年3月达到停产期。我们将在达到功能均等后至少一年支持2.4.x版本。因此鼓励用户开始将其旧版 OAuth 2.0 客户端和资源服务器应用程序迁移到Spring Security 5.2 中的新支持。详细参见 官方博客.</p>
<ol start="3">
<li>对 OAuth2.0 的技术选型<br>从上面的信息看来， Spring Security 未来依然提供 OAuth2 的 客户端支持 和 资源服务器支持。授权服务器 将逐渐退出 Spring Security 的生态环境。所以如果没有授权服务器需求的情况下选择 Spring Security 依然是没有问题的，一旦有这个需求我们该如何选择？我这里调研了几个开源免费的项目。</li>
</ol>
<p>3.1 keycloak<br>keycloak是 RedHat 公司出品。是一个致力于解决应用和服务身份验证与访问管理的开源工具。可以通过简单的配置达到保护应用和服务的目的。它提供了身份和访问管理的有用功能：</p>
<p>单点登录（SSO），身份代理和第三方登录。</p>
<p>支持 OpenID Connect，OAuth 2.0 和 SAML 2.0 等标准协议。</p>
<p>用户集中管理。</p>
<p>客户端适配器，轻松保护应用程序和服务。</p>
<p>可视化管理控制台和帐户管理控制台。</p>
<p>可扩展性、高性能、快速实现落地。</p>
<p>文档比较完毕，而且是一个成熟的、免费的商业级产品。</p>
<p>3.2 Nimbus SDK<br>全称是 Nimbus OAuth 2.0 / OpenID Connect SDK，这是一个类库。Spring 官方在博客中提到可以使用该类库构建 Authorization Server，它同时支持 OAuth2.0 和 OpenID Connect，比较完整地实现了这两个协议，而且针对补充协议也在积极的跟进。缺点在于中文教程不多而且是一个类库性质的。不过官方提供了 DEMO ，有能力的同学入门也不算难事。</p>
<p>3.3 Apache Oltu<br>Apache Oltu 是 Apache 基金会旗下的一个毕业项目。提供了 OAuth2.0 的常用实现，根据文档提供的信息来看上手还是比较简单的，模块化的提供了对 Authorization Server、Resource Server、Client、JOSE、 的支持。中文教程网上还是有不少的，缺点在于项目维护比较滞后，最新的版本是 2016 年发布的。</p>
<p>3.4 Vertx-auth-oauth2<br>vertx-auth-oauth2 属于 Vert.x 生态，提供了比较完整的 OAuth2.0 实现，而且项目维护比较活跃，唯一的缺点在于有技术栈的局限性。</p>
<h2 id="https-gitee-com-felord"><a href="#https-gitee-com-felord" class="headerlink" title="https://gitee.com/felord"></a><a href="https://gitee.com/felord" target="_blank" rel="noopener">https://gitee.com/felord</a></h2><h2 id="https-github-com-Kong-kong"><a href="#https-github-com-Kong-kong" class="headerlink" title="https://github.com/Kong/kong"></a><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a></h2>
      
    </div>
    
    
    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      </div>
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    gottaBoy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://gottaboy.cn/2020/01/11/SpringSecurity/" title="SpringSecurity">http://gottaboy.cn/2020/01/11/SpringSecurity/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring-Security/" rel="tag"><i class="fa fa-tag"></i> Spring Security</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/09/JavaIO/" rel="next" title="JavaIO">
                <i class="fa fa-chevron-left"></i> JavaIO
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/11/Disconf/" rel="prev" title="Disconf">
                Disconf <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">gottaBoy</p>
              <p class="site-description motion-element" itemprop="description">爱生活，爱分享</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">102</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/gottaboy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:gottaboy@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          
<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="https://music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66">
    </iframe>
</div>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth2-0-技术"><span class="nav-number">1.</span> <span class="nav-text">OAuth2.0 技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#https-www-felord-cn-categories-spring-security"><span class="nav-number">2.</span> <span class="nav-text">https:&#x2F;&#x2F;www.felord.cn&#x2F;categories&#x2F;spring-security&#x2F;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">3.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Security-和-Apache-Shiro"><span class="nav-number">3.1.</span> <span class="nav-text">Spring Security 和 Apache Shiro</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#认证-鉴权"><span class="nav-number">3.2.</span> <span class="nav-text">认证&#x2F;鉴权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤器链"><span class="nav-number">3.3.</span> <span class="nav-text">过滤器链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RBAC模型"><span class="nav-number">3.4.</span> <span class="nav-text">RBAC模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他一些概念"><span class="nav-number">3.5.</span> <span class="nav-text">其他一些概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户信息UserDetails相关入门"><span class="nav-number">4.</span> <span class="nav-text">用户信息UserDetails相关入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-前言"><span class="nav-number">4.1.</span> <span class="nav-text">1. 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Spring-Boot-集成-Spring-Security"><span class="nav-number">4.2.</span> <span class="nav-text">2. Spring Boot 集成 Spring Security</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-UserDetailsServiceAutoConfiguration"><span class="nav-number">4.3.</span> <span class="nav-text">3. UserDetailsServiceAutoConfiguration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-UserDetailsService"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.1 UserDetailsService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-UserDetails"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.2 UserDetails</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-UserDetailsServiceAutoConfiguration"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.3 UserDetailsServiceAutoConfiguration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-自定义UserDetailsManager"><span class="nav-number">4.3.4.</span> <span class="nav-text">3.4 自定义UserDetailsManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-数据库管理用户"><span class="nav-number">4.3.5.</span> <span class="nav-text">3.5 数据库管理用户</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-总结"><span class="nav-number">4.4.</span> <span class="nav-text">4. 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Boot-中的-Spring-Security-自动配置初探"><span class="nav-number">5.</span> <span class="nav-text">Spring Boot 中的 Spring Security 自动配置初探</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径Uri中的-Ant-风格"><span class="nav-number">6.</span> <span class="nav-text">路径Uri中的 Ant 风格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义配置类入口WebSecurityConfigurerAdapter"><span class="nav-number">7.</span> <span class="nav-text">自定义配置类入口WebSecurityConfigurerAdapter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#玩转自定义登录"><span class="nav-number">8.</span> <span class="nav-text">玩转自定义登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内置-Filter-全解析"><span class="nav-number">9.</span> <span class="nav-text">内置 Filter 全解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现自定义退出登录"><span class="nav-number">10.</span> <span class="nav-text">实现自定义退出登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手把手教你实现JWT-Token"><span class="nav-number">11.</span> <span class="nav-text">手把手教你实现JWT Token</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#登录后返回-JWT-Token"><span class="nav-number">12.</span> <span class="nav-text">登录后返回 JWT Token</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档"><span class="nav-number">13.</span> <span class="nav-text">文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义异常处理"><span class="nav-number">14.</span> <span class="nav-text">自定义异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-JWT-认证访问接口"><span class="nav-number">15.</span> <span class="nav-text">使用 JWT 认证访问接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接"><span class="nav-number">16.</span> <span class="nav-text">链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RBAC权限控制概念的理解"><span class="nav-number">17.</span> <span class="nav-text">RBAC权限控制概念的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于配置的接口角色访问控制"><span class="nav-number">18.</span> <span class="nav-text">基于配置的接口角色访问控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于注解的接口角色访问控制"><span class="nav-number">19.</span> <span class="nav-text">基于注解的接口角色访问控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SecurityContext相关的知识"><span class="nav-number">20.</span> <span class="nav-text">SecurityContext相关的知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纠正对-JSON-Web-Token-认识的误区"><span class="nav-number">21.</span> <span class="nav-text">纠正对 JSON Web Token 认识的误区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的认识-OAuth2-0-协议"><span class="nav-number">22.</span> <span class="nav-text">简单的认识 OAuth2.0 协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth2-0-技术选型参考"><span class="nav-number">23.</span> <span class="nav-text">OAuth2.0 技术选型参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#https-gitee-com-felord"><span class="nav-number">24.</span> <span class="nav-text">https:&#x2F;&#x2F;gitee.com&#x2F;felord</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#https-github-com-Kong-kong"><span class="nav-number">25.</span> <span class="nav-text">https:&#x2F;&#x2F;github.com&#x2F;Kong&#x2F;kong</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gottaBoy</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">195k</span>
  
</div>

<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>
  

  undefined
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
