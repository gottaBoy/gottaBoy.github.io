<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>圣女果果的博客</title>
  
  <subtitle>快乐生活每一天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gottaboy.cn/"/>
  <updated>2020-02-29T04:45:52.000Z</updated>
  <id>http://gottaboy.cn/</id>
  
  <author>
    <name>gottaBoy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>圣女果果读Kafka</title>
    <link href="http://gottaboy.cn/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/"/>
    <id>http://gottaboy.cn/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/</id>
    <published>2020-02-29T03:59:56.000Z</published>
    <updated>2020-02-29T04:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="Kafka-2-4-Documentation"><a href="#Kafka-2-4-Documentation" class="headerlink" title="Kafka 2.4 Documentation"></a>Kafka 2.4 Documentation</h2><h2 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>消息队列的性能好坏，其文件存储机制设计是衡量一个消息队列服务技术水平和最关键指标之一。下面将从Kafka文件存储机制和物理结构角度，分析Kafka是如何实现高效文件存储，及实际应用效果。</p><h4 id="1-1-Kafka的特性"><a href="#1-1-Kafka的特性" class="headerlink" title="1.1 Kafka的特性:"></a>1.1 Kafka的特性:</h4><p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</p><p>可扩展性：kafka集群支持热扩展</p><p>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p><p>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p><p>高并发：支持数千个客户端同时读写</p><h4 id="1-2-Kafka的使用场景："><a href="#1-2-Kafka的使用场景：" class="headerlink" title="1.2 Kafka的使用场景："></a>1.2 Kafka的使用场景：</h4><p>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p><p>消息系统：解耦和生产者和消费者、缓存消息等。</p><p>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p><p>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p><p>流式处理：比如spark streaming和storm</p><p>事件源</p><h4 id="1-3-Kakfa的设计思想"><a href="#1-3-Kakfa的设计思想" class="headerlink" title="1.3 Kakfa的设计思想"></a>1.3 Kakfa的设计思想</h4><h5 id="Kakfa-Broker-Leader的选举："><a href="#Kakfa-Broker-Leader的选举：" class="headerlink" title="Kakfa Broker Leader的选举："></a>Kakfa Broker Leader的选举：</h5><p>Kakfa Broker集群受Zookeeper管理。所有的Kafka Broker节点一起去Zookeeper上注册一个临时节点，因为只有一个Kafka Broker会注册成功，其他的都会失败，所以这个成功在Zookeeper上注册临时节点的这个Kafka Broker会成为Kafka Broker Controller，其他的Kafka broker叫Kafka Broker follower。（这个过程叫Controller在ZooKeeper注册Watch）。这个Controller会监听其他的Kafka Broker的所有信息，如果这个kafka broker controller宕机了，在zookeeper上面的那个临时节点就会消失，此时所有的kafka broker又会一起去Zookeeper上注册一个临时节点，因为只有一个Kafka Broker会注册成功，其他的都会失败，所以这个成功在Zookeeper上注册临时节点的这个Kafka Broker会成为Kafka Broker Controller，其他的Kafka broker叫Kafka Broker follower。例如：一旦有一个broker宕机了，这个kafka broker controller会读取该宕机broker上所有的partition在zookeeper上的状态，并选取ISR列表中的一个replica作为partition leader（如果ISR列表中的replica全挂，选一个幸存的replica作为leader; 如果该partition的所有的replica都宕机了，则将新的leader设置为-1，等待恢复，等待ISR中的任一个Replica“活”过来，并且选它作为Leader；或选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader），这个broker宕机的事情，kafka controller也会通知zookeeper，zookeeper就会通知其他的kafka broker。<br>这里曾经发生过一个bug，TalkingData使用Kafka0.8.1的时候，kafka controller在Zookeeper上注册成功后，它和Zookeeper通信的timeout时间是6s，也就是如果kafka controller如果有6s中没有和Zookeeper做心跳，那么Zookeeper就认为这个kafka controller已经死了，就会在Zookeeper上把这个临时节点删掉，那么其他Kafka就会认为controller已经没了，就会再次抢着注册临时节点，注册成功的那个kafka broker成为controller，然后，之前的那个kafka controller就需要各种shut down去关闭各种节点和事件的监听。但是当kafka的读写流量都非常巨大的时候，TalkingData的一个bug是，由于网络等原因，kafka controller和Zookeeper有6s中没有通信，于是重新选举出了一个新的kafka controller，但是原来的controller在shut down的时候总是不成功，这个时候producer进来的message由于Kafka集群中存在两个kafka controller而无法落地。导致数据淤积。</p><p>这里曾经还有一个bug，TalkingData使用Kafka0.8.1的时候，当ack=0的时候，表示producer发送出去message，只要对应的kafka broker topic partition leader接收到的这条message，producer就返回成功，不管partition leader 是否真的成功把message真正存到kafka。当ack=1的时候，表示producer发送出去message，同步的把message存到对应topic的partition的leader上，然后producer就返回成功，partition leader异步的把message同步到其他partition replica上。当ack=all或-1，表示producer发送出去message，同步的把message存到对应topic的partition的leader和对应的replica上之后，才返回成功。但是如果某个kafka controller 切换的时候，会导致partition leader的切换（老的 kafka controller上面的partition leader会选举到其他的kafka broker上）,但是这样就会导致丢数据。</p><h5 id="Consumergroup："><a href="#Consumergroup：" class="headerlink" title="Consumergroup："></a>Consumergroup：</h5><p>各个consumer（consumer 线程）可以组成一个组（Consumer group ），partition中的每个message只能被组（Consumer group ）中的一个consumer（consumer 线程）消费，如果一个message可以被多个consumer（consumer 线程）消费的话，那么这些consumer必须在不同的组。Kafka不支持一个partition中的message由两个或两个以上的同一个consumer group下的consumer thread来处理，除非再启动一个新的consumer group。所以如果想同时对一个topic做消费的话，启动多个consumer group就可以了，但是要注意的是，这里的多个consumer的消费都必须是顺序读取partition里面的message，新启动的consumer默认从partition队列最头端最新的地方开始阻塞的读message。它不能像AMQ那样可以多个BET作为consumer去互斥的（for update悲观锁）并发处理message，这是因为多个BET去消费一个Queue中的数据的时候，由于要保证不能多个线程拿同一条message，所以就需要行级别悲观所（for update）,这就导致了consume的性能下降，吞吐量不够。而kafka为了保证吞吐量，只允许同一个consumer group下的一个consumer线程去访问一个partition。如果觉得效率不高的时候，可以加partition的数量来横向扩展，那么再加新的consumer thread去消费。如果想多个不同的业务都需要这个topic的数据，起多个consumer group就好了，大家都是顺序的读取message，offsite的值互不影响。这样没有锁竞争，充分发挥了横向的扩展性，吞吐量极高。这也就形成了分布式消费的概念。</p><p>当启动一个consumer group去消费一个topic的时候，无论topic里面有多个少个partition，无论我们consumer group里面配置了多少个consumer thread，这个consumer group下面的所有consumer thread一定会消费全部的partition；即便这个consumer group下只有一个consumer thread，那么这个consumer thread也会去消费所有的partition。因此，最优的设计就是，consumer group下的consumer thread的数量等于partition数量，这样效率是最高的。</p><p>同一partition的一条message只能被同一个Consumer Group内的一个Consumer消费。不能够一个consumer group的多个consumer同时消费一个partition。</p><p>一个consumer group下，无论有多少个consumer，这个consumer group一定回去把这个topic下所有的partition都消费了。当consumer group里面的consumer数量小于这个topic下的partition数量的时候，如下图groupA,groupB，就会出现一个conusmer thread消费多个partition的情况，总之是这个topic下的partition都会被消费。如果consumer group里面的consumer数量等于这个topic下的partition数量的时候，如下图groupC，此时效率是最高的，每个partition都有一个consumer thread去消费。当consumer group里面的consumer数量大于这个topic下的partition数量的时候，如下图GroupD，就会有一个consumer thread空闲。因此，我们在设定consumer group的时候，只需要指明里面有几个consumer数量即可，无需指定对应的消费partition序号，consumer会自动进行rebalance。</p><p>多个Consumer Group下的consumer可以消费同一条message，但是这种消费也是以o（1）的方式顺序的读取message去消费,，所以一定会重复消费这批message的，不能向AMQ那样多个BET作为consumer消费（对message加锁，消费的时候不能重复消费message）</p><p>Consumer Rebalance的触发条件：（1）Consumer增加或删除会触发 Consumer Group的Rebalance（2）Broker的增加或者减少都会触发 Consumer Rebalance</p><h5 id="Consumer："><a href="#Consumer：" class="headerlink" title="Consumer："></a>Consumer：</h5><p> Consumer处理partition里面的message的时候是o（1）顺序读取的。所以必须维护着上一次读到哪里的offsite信息。high level API,offset存于Zookeeper中，low level API的offset由自己维护。一般来说都是使用high level api的。Consumer的delivery gurarantee，默认是读完message先commmit再处理message，autocommit默认是true，这时候先commit就会更新offsite+1，一旦处理失败，offsite已经+1，这个时候就会丢message；也可以配置成读完消息处理再commit，这种情况下consumer端的响应就会比较慢的，需要等处理完才行。</p><p>一般情况下，一定是一个consumer group处理一个topic的message。Best Practice是这个consumer group里面consumer的数量等于topic里面partition的数量，这样效率是最高的，一个consumer thread处理一个partition。如果这个consumer group里面consumer的数量小于topic里面partition的数量，就会有consumer thread同时处理多个partition（这个是kafka自动的机制，我们不用指定），但是总之这个topic里面的所有partition都会被处理到的。。如果这个consumer group里面consumer的数量大于topic里面partition的数量，多出的consumer thread就会闲着啥也不干，剩下的是一个consumer thread处理一个partition，这就造成了资源的浪费，因为一个partition不可能被两个consumer thread去处理。所以我们线上的分布式多个service服务，每个service里面的kafka consumer数量都小于对应的topic的partition数量，但是所有服务的consumer数量只和等于partition的数量，这是因为分布式service服务的所有consumer都来自一个consumer group，如果来自不同的consumer group就会处理重复的message了（同一个consumer group下的consumer不能处理同一个partition，不同的consumer group可以处理同一个topic，那么都是顺序处理message，一定会处理重复的。一般这种情况都是两个不同的业务逻辑，才会启动两个consumer group来处理一个topic）。</p><p>如果producer的流量增大，当前的topic的parition数量=consumer数量，这时候的应对方式就是很想扩展：增加topic下的partition，同时增加这个consumer group下的consumer。</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229110003637.png" alt="image-20200229110003637"></p><h5 id="Delivery-Mode"><a href="#Delivery-Mode" class="headerlink" title="Delivery Mode :"></a>Delivery Mode :</h5><p>Kafka producer 发送message不用维护message的offsite信息，因为这个时候，offsite就相当于一个自增id，producer就尽管发送message就好了。而且Kafka与AMQ不同，AMQ大都用在处理业务逻辑上，而Kafka大都是日志，所以Kafka的producer一般都是大批量的batch发送message，向这个topic一次性发送一大批message，load balance到一个partition上，一起插进去，offsite作为自增id自己增加就好。但是Consumer端是需要维护这个partition当前消费到哪个message的offsite信息的，这个offsite信息，high level api是维护在Zookeeper上，low level api是自己的程序维护。（Kafka管理界面上只能显示high level api的consumer部分，因为low level api的partition offsite信息是程序自己维护，kafka是不知道的，无法在管理界面上展示 ）当使用high level api的时候，先拿message处理，再定时自动commit offsite+1（也可以改成手动）, 并且kakfa处理message是没有锁操作的。因此如果处理message失败，此时还没有commit offsite+1，当consumer thread重启后会重复消费这个message。但是作为高吞吐量高并发的实时处理系统，at least once的情况下，至少一次会被处理到，是可以容忍的。如果无法容忍，就得使用low level api来自己程序维护这个offsite信息，那么想什么时候commit offsite+1就自己搞定了。</p><h5 id="Topic-amp-Partition："><a href="#Topic-amp-Partition：" class="headerlink" title="Topic &amp; Partition："></a>Topic &amp; Partition：</h5><p>Topic相当于传统消息系统MQ中的一个队列queue，producer端发送的message必须指定是发送到哪个topic，但是不需要指定topic下的哪个partition，因为kafka会把收到的message进行load balance，均匀的分布在这个topic下的不同的partition上（ hash(message) % [broker数量] ）。物理上存储上，这个topic会分成一个或多个partition，每个partiton相当于是一个子queue。在物理结构上，每个partition对应一个物理的目录（文件夹），文件夹命名是[topicname][partition][序号]，一个topic可以有无数多的partition，根据业务需求和数据量来设置。在kafka配置文件中可随时更高num.partitions参数来配置更改topic的partition数量，在创建Topic时通过参数指定parittion数量。Topic创建之后通过Kafka提供的工具也可以修改partiton数量。</p><p>一般来说，（1）一个Topic的Partition数量大于等于Broker的数量，可以提高吞吐率。（2）同一个Partition的Replica尽量分散到不同的机器，高可用。</p><p>当add a new partition的时候，partition里面的message不会重新进行分配，原来的partition里面的message数据不会变，新加的这个partition刚开始是空的，随后进入这个topic的message就会重新参与所有partition的load balance</p><h5 id="Partition-Replica："><a href="#Partition-Replica：" class="headerlink" title="Partition Replica："></a>Partition Replica：</h5><p>每个partition可以在其他的kafka broker节点上存副本，以便某个kafka broker节点宕机不会影响这个kafka集群。存replica副本的方式是按照kafka broker的顺序存。例如有5个kafka broker节点，某个topic有3个partition，每个partition存2个副本，那么partition1存broker1,broker2，partition2存broker2,broker3。。。以此类推（replica副本数目不能大于kafka broker节点的数目，否则报错。这里的replica数其实就是partition的副本总数，其中包括一个leader，其他的就是copy副本）。这样如果某个broker宕机，其实整个kafka内数据依然是完整的。但是，replica副本数越高，系统虽然越稳定，但是回来带资源和性能上的下降；replica副本少的话，也会造成系统丢数据的风险。</p><p>（1）怎样传送消息：producer先把message发送到partition leader，再由leader发送给其他partition follower。（如果让producer发送给每个replica那就太慢了）</p><p>（2）在向Producer发送ACK前需要保证有多少个Replica已经收到该消息：根据ack配的个数而定</p><p>（3）怎样处理某个Replica不工作的情况：如果这个部工作的partition replica不在ack列表中，就是producer在发送消息到partition leader上，partition leader向partition follower发送message没有响应而已，这个不会影响整个系统，也不会有什么问题。如果这个不工作的partition replica在ack列表中的话，producer发送的message的时候会等待这个不工作的partition replca写message成功，但是会等到time out，然后返回失败因为某个ack列表中的partition replica没有响应，此时kafka会自动的把这个部工作的partition replica从ack列表中移除，以后的producer发送message的时候就不会有这个ack列表下的这个部工作的partition replica了。</p><p>（4）怎样处理Failed Replica恢复回来的情况：如果这个partition replica之前不在ack列表中，那么启动后重新受Zookeeper管理即可，之后producer发送message的时候，partition leader会继续发送message到这个partition follower上。如果这个partition replica之前在ack列表中，此时重启后，需要把这个partition replica再手动加到ack列表中。（ack列表是手动添加的，出现某个部工作的partition replica的时候自动从ack列表中移除的）</p><h5 id="Partition-leader与follower："><a href="#Partition-leader与follower：" class="headerlink" title="Partition leader与follower："></a>Partition leader与follower：</h5><p>partition也有leader和follower之分。leader是主partition，producer写kafka的时候先写partition leader，再由partition leader push给其他的partition follower。partition leader与follower的信息受Zookeeper控制，一旦partition leader所在的broker节点宕机，zookeeper会冲其他的broker的partition follower上选择follower变为parition leader。</p><h5 id="Topic分配partition和partition-replica的算法："><a href="#Topic分配partition和partition-replica的算法：" class="headerlink" title="Topic分配partition和partition replica的算法："></a>Topic分配partition和partition replica的算法：</h5><p>（1）将Broker（size=n）和待分配的Partition排序。（2）将第i个Partition分配到第（i%n）个Broker上。（3）将第i个Partition的第j个Replica分配到第（(i + j) % n）个Broker上</p><h4 id="1-4-消息投递可靠性"><a href="#1-4-消息投递可靠性" class="headerlink" title="1.4 消息投递可靠性"></a>1.4 消息投递可靠性</h4><p>一个消息如何算投递成功，Kafka提供了三种模式：</p><p>第一种是啥都不管，发送出去就当作成功，这种情况当然不能保证消息成功投递到broker；</p><p>第二种是Master-Slave模型，只有当Master和所有Slave都接收到消息时，才算投递成功，这种模型提供了最高的投递可靠性，但是损伤了性能；</p><p>第三种模型，即只要Master确认收到消息就算投递成功；实际使用时，根据应用特性选择，绝大多数情况下都会中和可靠性和性能选择第三种模型</p><p>消息在broker上的可靠性，因为消息会持久化到磁盘上，所以如果正常stop一个broker，其上的数据不会丢失；但是如果不正常stop，可能会使存在页面缓存来不及写入磁盘的消息丢失，这可以通过配置flush页面缓存的周期、阈值缓解，但是同样会频繁的写磁盘会影响性能，又是一个选择题，根据实际情况配置。</p><p>消息消费的可靠性，Kafka提供的是“At least once”模型，因为消息的读取进度由offset提供，offset可以由消费者自己维护也可以维护在zookeeper里，但是当消息消费后consumer挂掉，offset没有即时写回，就有可能发生重复读的情况，这种情况同样可以通过调整commit offset周期、阈值缓解，甚至消费者自己把消费和commit offset做成一个事务解决，但是如果你的应用不在乎重复消费，那就干脆不要解决，以换取最大的性能。</p><p>Partition ack：当ack=1，表示producer写partition leader成功后，broker就返回成功，无论其他的partition follower是否写成功。当ack=2，表示producer写partition leader和其他一个follower成功的时候，broker就返回成功，无论其他的partition follower是否写成功。当ack=-1[parition的数量]的时候，表示只有producer全部写成功的时候，才算成功，kafka broker才返回成功信息。这里需要注意的是，如果ack=1的时候，一旦有个broker宕机导致partition的follower和leader切换，会导致丢数据。</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229110102218.png" alt="image-20200229110102218"></p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229110124493.png" alt="image-20200229110124493"></p><h5 id="message状态："><a href="#message状态：" class="headerlink" title="message状态："></a>message状态：</h5><p>在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</p><h5 id="message持久化："><a href="#message持久化：" class="headerlink" title="message持久化："></a>message持久化：</h5><p>Kafka中会把消息持久化到本地文件系统中，并且保持o(1)极高的效率。我们众所周知IO读取是非常耗资源的性能也是最慢的，这就是为了数据库的瓶颈经常在IO上，需要换SSD硬盘的原因。但是Kafka作为吞吐量极高的MQ，却可以非常高效的message持久化到文件。这是因为Kafka是顺序写入o（1）的时间复杂度，速度非常快。也是高吞吐量的原因。由于message的写入持久化是顺序写入的，因此message在被消费的时候也是按顺序被消费的，保证partition的message是顺序消费的。一般的机器,单机每秒100k条数据。</p><h5 id="message有效期："><a href="#message有效期：" class="headerlink" title="message有效期："></a>message有效期：</h5><p>Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。</p><p>Produer : Producer向Topic发送message，不需要指定partition，直接发送就好了。kafka通过partition ack来控制是否发送成功并把信息返回给producer，producer可以有任意多的thread，这些kafka服务器端是不care的。Producer端的delivery guarantee默认是At least once的。也可以设置Producer异步发送实现At most once。Producer可以用主键幂等性实现Exactly once</p><h5 id="Kafka高吞吐量："><a href="#Kafka高吞吐量：" class="headerlink" title="Kafka高吞吐量："></a>Kafka高吞吐量：</h5><p> Kafka的高吞吐量体现在读写上，分布式并发的读和写都非常快，写的性能体现在以o(1)的时间复杂度进行顺序写入。读的性能体现在以o(1)的时间复杂度进行顺序读取， 对topic进行partition分区，consume group中的consume线程可以以很高能性能进行顺序读。</p><p>Kafka delivery guarantee(message传送保证)：（1）At most once消息可能会丢，绝对不会重复传输；（2）At least once 消息绝对不会丢，但是可能会重复传输；（3）Exactly once每条信息肯定会被传输一次且仅传输一次，这是用户想要的。</p><h5 id="批量发送："><a href="#批量发送：" class="headerlink" title="批量发送："></a>批量发送：</h5><p>Kafka支持以消息集合为单位进行批量发送，以提高push效率。</p><p>push-and-pull : Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</p><p>Kafka集群中broker之间的关系：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</p><h5 id="负载均衡方面："><a href="#负载均衡方面：" class="headerlink" title="负载均衡方面："></a>负载均衡方面：</h5><p> Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</p><p>同步异步：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</p><h5 id="分区机制partition："><a href="#分区机制partition：" class="headerlink" title="分区机制partition："></a>分区机制partition：</h5><p>Kafka的broker端支持消息分区partition，Producer可以决定把消息发到哪个partition，在一个partition 中message的顺序就是Producer发送消息的顺序，一个topic中可以有多个partition，具体partition的数量是可配置的。partition的概念使得kafka作为MQ可以横向扩展，吞吐量巨大。partition可以设置replica副本，replica副本存在不同的kafka broker节点上，第一个partition是leader,其他的是follower，message先写到partition leader上，再由partition leader push到parition follower上。所以说kafka可以水平扩展，也就是扩展partition。</p><h5 id="离线数据装载："><a href="#离线数据装载：" class="headerlink" title="离线数据装载："></a>离线数据装载：</h5><p>Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</p><h5 id="实时数据与离线数据："><a href="#实时数据与离线数据：" class="headerlink" title="实时数据与离线数据："></a>实时数据与离线数据：</h5><p>kafka既支持离线数据也支持实时数据，因为kafka的message持久化到文件，并可以设置有效期，因此可以把kafka作为一个高效的存储来使用，可以作为离线数据供后面的分析。当然作为分布式实时消息系统，大多数情况下还是用于实时的数据处理的，但是当cosumer消费能力下降的时候可以通过message的持久化在淤积数据在kafka。</p><h5 id="插件支持："><a href="#插件支持：" class="headerlink" title="插件支持："></a>插件支持：</h5><p>现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</p><h5 id="解耦"><a href="#解耦" class="headerlink" title="解耦:"></a>解耦:</h5><p>相当于一个MQ，使得Producer和Consumer之间异步的操作，系统之间解耦</p><h5 id="冗余"><a href="#冗余" class="headerlink" title="冗余:"></a>冗余:</h5><p>replica有多个副本，保证一个broker node宕机后不会影响整个服务</p><h5 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性:"></a>扩展性:</h5><p>broker节点可以水平扩展，partition也可以水平增加，partition replica也可以水平增加</p><h5 id="峰值"><a href="#峰值" class="headerlink" title="峰值:"></a>峰值:</h5><p>在访问量剧增的情况下，kafka水平扩展, 应用仍然需要继续发挥作用</p><h5 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性:"></a>可恢复性:</h5><p>系统的一部分组件失效时，由于有partition的replica副本，不会影响到整个系统。</p><h5 id="顺序保证性："><a href="#顺序保证性：" class="headerlink" title="顺序保证性："></a>顺序保证性：</h5><p>由于kafka的producer的写message与consumer去读message都是顺序的读写，保证了高效的性能。</p><h5 id="缓冲："><a href="#缓冲：" class="headerlink" title="缓冲："></a>缓冲：</h5><p>由于producer那面可能业务很简单，而后端consumer业务会很复杂并有数据库的操作，因此肯定是producer会比consumer处理速度快，如果没有kafka，producer直接调用consumer，那么就会造成整个系统的处理速度慢，加一层kafka作为MQ，可以起到缓冲的作用。</p><h5 id="异步通信："><a href="#异步通信：" class="headerlink" title="异步通信："></a>异步通信：</h5><p>作为MQ，Producer与Consumer异步通信</p><h3 id="2-Kafka文件存储机制"><a href="#2-Kafka文件存储机制" class="headerlink" title="2.Kafka文件存储机制"></a>2.Kafka文件存储机制</h3><h4 id="2-1-Kafka部分名词解释如下："><a href="#2-1-Kafka部分名词解释如下：" class="headerlink" title="2.1 Kafka部分名词解释如下："></a>2.1 Kafka部分名词解释如下：</h4><p> Kafka中发布订阅的对象是topic。我们可以为每类数据创建一个topic，把向topic发布消息的客户端称作producer，从topic订阅消息的客户端称作consumer。Producers和consumers可以同时从多个topic读写数据。一个kafka集群由一个或多个broker服务器组成，它负责持久化和备份具体的kafka消息。<br>Broker：Kafka节点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。<br>Topic：一类消息，消息存放的目录即主题，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。<br>Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列<br>Segment：partition物理上由多个segment组成，每个Segment存着message信息<br>Producer : 生产message发送到topic<br>Consumer : 订阅topic消费message, consumer作为一个线程来消费<br>Consumer Group：一个Consumer Group包含多个consumer, 这个是预先在配置文件中配置好的。各个consumer（consumer 线程）可以组成一个组（Consumer group ），partition中的每个message只能被组（Consumer group ） 中的一个consumer（consumer 线程 ）消费，如果一个message可以被多个consumer（consumer 线程 ） 消费的话，那么这些consumer必须在不同的组。Kafka不支持一个partition中的message由两个或两个以上的consumer thread来处理，即便是来自不同的consumer group的也不行。它不能像AMQ那样可以多个BET作为consumer去处理message，这是因为多个BET去消费一个Queue中的数据的时候，由于要保证不能多个线程拿同一条message，所以就需要行级别悲观所（for update）,这就导致了consume的性能下降，吞吐量不够。而kafka为了保证吞吐量，只允许一个consumer线程去访问一个partition。如果觉得效率不高的时候，可以加partition的数量来横向扩展，那么再加新的consumer thread去消费。这样没有锁竞争，充分发挥了横向的扩展性，吞吐量极高。这也就形成了分布式消费的概念。</p><h4 id="2-2-kafka一些原理概念"><a href="#2-2-kafka一些原理概念" class="headerlink" title="2.2 kafka一些原理概念"></a>2.2 kafka一些原理概念</h4><h5 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1.持久化"></a>1.持久化</h5><p>kafka使用文件存储消息(append only log),这就直接决定kafka在性能上严重依赖文件系统的本身特性.且无论任何OS下,对文件系统本身的优化是非常艰难的.文件缓存/直接内存映射等是常用的手段.因为kafka是对日志文件进行append操作,因此磁盘检索的开支是较小的;同时为了减少磁盘写入的次数,broker会将消息暂时buffer起来,当消息的个数(或尺寸)达到一定阀值时,再flush到磁盘,这样减少了磁盘IO调用的次数.对于kafka而言,较高性能的磁盘,将会带来更加直接的性能提升.</p><h5 id="2-性能"><a href="#2-性能" class="headerlink" title="2.性能"></a>2.性能</h5><p>除磁盘IO之外,我们还需要考虑网络IO,这直接关系到kafka的吞吐量问题.kafka并没有提供太多高超的技巧;对于producer端,可以将消息buffer起来,当消息的条数达到一定阀值时,批量发送给broker;对于consumer端也是一样,批量fetch多条消息.不过消息量的大小可以通过配置文件来指定.对于kafka broker端,似乎有个sendfile系统调用可以潜在的提升网络IO的性能:将文件的数据映射到系统内存中,socket直接读取相应的内存区域即可,而无需进程再次copy和交换(这里涉及到”磁盘IO数据”/“内核内存”/“进程内存”/“网络缓冲区”,多者之间的数据copy).</p><p>其实对于producer/consumer/broker三者而言,CPU的开支应该都不大,因此启用消息压缩机制是一个良好的策略;压缩需要消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑.可以将任何在网络上传输的消息都经过压缩.kafka支持gzip/snappy等多种压缩方式.</p><h5 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3.负载均衡"></a>3.负载均衡</h5><p>kafka集群中的任何一个broker,都可以向producer提供metadata信息,这些metadata中包含”集群中存活的servers列表”/“partitions leader列表”等信息(请参看zookeeper中的节点信息). 当producer获取到metadata信息之后, producer将会和Topic下所有partition leader保持socket连接;消息由producer直接通过socket发送到broker,中间不会经过任何”路由层”.</p><p>异步发送，将多条消息暂且在客户端buffer起来,并将他们批量发送到broker;小数据IO太多,会拖慢整体的网络延迟,批量延迟发送事实上提升了网络效率;不过这也有一定的隐患,比如当producer失效时,那些尚未发送的消息将会丢失。</p><h5 id="4-Topic模型"><a href="#4-Topic模型" class="headerlink" title="4.Topic模型"></a>4.Topic模型</h5><p>其他JMS实现,消息消费的位置是有prodiver保留,以便避免重复发送消息或者将没有消费成功的消息重发等,同时还要控制消息的状态.这就要求JMS broker需要太多额外的工作.在kafka中,partition中的消息只有一个consumer在消费,且不存在消息状态的控制,也没有复杂的消息确认机制,可见kafka broker端是相当轻量级的.当消息被consumer接收之后,consumer可以在本地保存最后消息的offset,并间歇性的向zookeeper注册offset.由此可见,consumer客户端也很轻量级。</p><p>kafka中consumer负责维护消息的消费记录,而broker则不关心这些,这种设计不仅提高了consumer端的灵活性,也适度的减轻了broker端设计的复杂度;这是和众多JMS prodiver的区别.此外,kafka中消息ACK的设计也和JMS有很大不同,kafka中的消息是批量(通常以消息的条数或者chunk的尺寸为单位)发送给consumer,当消息消费成功后,向zookeeper提交消息的offset,而不会向broker交付ACK.或许你已经意识到,这种”宽松”的设计,将会有”丢失”消息/“消息重发”的危险.</p><h5 id="5-消息传输一致"><a href="#5-消息传输一致" class="headerlink" title="5.消息传输一致"></a>5.消息传输一致</h5><p>Kafka提供3种消息传输一致性语义：最多1次，最少1次，恰好1次。</p><p>最少1次：可能会重传数据，有可能出现数据被重复处理的情况;</p><p>最多1次：可能会出现数据丢失情况;</p><p>恰好1次：并不是指真正只传输1次，只不过有一个机制。确保不会出现“数据被重复处理”和“数据丢失”的情况。</p><p>at most once: 消费者fetch消息,然后保存offset,然后处理消息;当client保存offset之后,但是在消息处理过程中consumer进程失效(crash),导致部分消息未能继续处理.那么此后可能其他consumer会接管,但是因为offset已经提前保存,那么新的consumer将不能fetch到offset之前的消息(尽管它们尚没有被处理),这就是”at most once”.</p><p>at least once: 消费者fetch消息,然后处理消息,然后保存offset.如果消息处理成功之后,但是在保存offset阶段zookeeper异常或者consumer失效,导致保存offset操作未能执行成功,这就导致接下来再次fetch时可能获得上次已经处理过的消息,这就是”at least once”.</p><p>“Kafka Cluster”到消费者的场景中可以采取以下方案来得到“恰好1次”的一致性语义：</p><p>最少1次＋消费者的输出中额外增加已处理消息最大编号：由于已处理消息最大编号的存在，不会出现重复处理消息的情况。</p><h5 id="6-副本"><a href="#6-副本" class="headerlink" title="6.副本"></a>6.副本</h5><p>kafka中,replication策略是基于partition,而不是topic;kafka将每个partition数据复制到多个server上,任何一个partition有一个leader和多个follower(可以没有);备份的个数可以通过broker配置文件来设定。leader处理所有的read-write请求,follower需要和leader保持同步.Follower就像一个”consumer”,消费消息并保存在本地日志中;leader负责跟踪所有的follower状态,如果follower”落后”太多或者失效,leader将会把它从replicas同步列表中删除.当所有的follower都将一条消息保存成功,此消息才被认为是”committed”,那么此时consumer才能消费它,这种同步策略,就要求follower和leader之间必须具有良好的网络环境.即使只有一个replicas实例存活,仍然可以保证消息的正常发送和接收,只要zookeeper集群存活即可.</p><p>选择follower时需要兼顾一个问题,就是新leader server上所已经承载的partition leader的个数,如果一个server上有过多的partition leader,意味着此server将承受着更多的IO压力.在选举新leader,需要考虑到”负载均衡”,partition leader较少的broker将会更有可能成为新的leader.</p><h5 id="7-log"><a href="#7-log" class="headerlink" title="7.log"></a>7.log</h5><p>每个log entry格式为”4个字节的数字N表示消息的长度” + “N个字节的消息内容”;每个日志都有一个offset来唯一的标记一条消息,offset的值为8个字节的数字,表示此消息在此partition中所处的起始位置..每个partition在物理存储层面,有多个log file组成(称为segment).segment file的命名为”最小offset”.kafka.例如”00000000000.kafka”;其中”最小offset”表示此segment中起始消息的offset.</p><p>获取消息时,需要指定offset和最大chunk尺寸,offset用来表示消息的起始位置,chunk size用来表示最大获取消息的总长度(间接的表示消息的条数).根据offset,可以找到此消息所在segment文件,然后根据segment的最小offset取差值,得到它在file中的相对位置,直接读取输出即可.</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229110228546.png" alt="image-20200229110228546"></p><h5 id="8-分布式"><a href="#8-分布式" class="headerlink" title="8.分布式"></a>8.分布式</h5><p>kafka使用zookeeper来存储一些meta信息,并使用了zookeeper watch机制来发现meta信息的变更并作出相应的动作(比如consumer失效,触发负载均衡等)</p><p>Broker node registry: 当一个kafka broker启动后,首先会向zookeeper注册自己的节点信息(临时znode),同时当broker和zookeeper断开连接时,此znode也会被删除.</p><p>Broker Topic Registry: 当一个broker启动时,会向zookeeper注册自己持有的topic和partitions信息,仍然是一个临时znode.</p><p>Consumer and Consumer group: 每个consumer客户端被创建时,会向zookeeper注册自己的信息;此作用主要是为了”负载均衡”.一个group中的多个consumer可以交错的消费一个topic的所有partitions;简而言之,保证此topic的所有partitions都能被此group所消费,且消费时为了性能考虑,让partition相对均衡的分散到每个consumer上.</p><p>Consumer id Registry: 每个consumer都有一个唯一的ID(host:uuid,可以通过配置文件指定,也可以由系统生成),此id用来标记消费者信息.</p><p>Consumer offset Tracking: 用来跟踪每个consumer目前所消费的partition中最大的offset.此znode为持久节点,可以看出offset跟group_id有关,以表明当group中一个消费者失效,其他consumer可以继续消费.</p><p>Partition Owner registry: 用来标记partition正在被哪个consumer消费.临时znode。此节点表达了”一个partition”只能被group下一个consumer消费,同时当group下某个consumer失效,那么将会触发负载均衡(即:让partitions在多个consumer间均衡消费,接管那些”游离”的partitions)</p><p>当consumer启动时,所触发的操作:</p><p>A) 首先进行”Consumer id Registry”;</p><p>B) 然后在”Consumer id Registry”节点下注册一个watch用来监听当前group中其他consumer的”leave”和”join”;只要此znode path下节点列表变更,都会触发此group下consumer的负载均衡.(比如一个consumer失效,那么其他consumer接管partitions).</p><p>C) 在”Broker id registry”节点下,注册一个watch用来监听broker的存活情况;如果broker列表变更,将会触发所有的groups下的consumer重新balance.</p><p>总结:</p><p>Producer端使用zookeeper用来”发现”broker列表,以及和Topic下每个partition leader建立socket连接并发送消息.</p><p>Broker端使用zookeeper用来注册broker信息,已经监测partition leader存活性.</p><p>Consumer端使用zookeeper用来注册consumer信息,其中包括consumer消费的partition列表等,同时也用来发现broker列表,并和partition leader建立socket连接,并获取消息。</p><h5 id="9-Leader的选择"><a href="#9-Leader的选择" class="headerlink" title="9.Leader的选择"></a>9.Leader的选择</h5><p>Kafka的核心是日志文件，日志文件在集群中的同步是分布式数据系统最基础的要素。</p><p>如果leaders永远不会down的话我们就不需要followers了！一旦leader down掉了，需要在followers中选择一个新的leader.但是followers本身有可能延时太久或者crash，所以必须选择高质量的follower作为leader.必须保证，一旦一个消息被提交了，但是leader down掉了，新选出的leader必须可以提供这条消息。大部分的分布式系统采用了多数投票法则选择新的leader,对于多数投票法则，就是根据所有副本节点的状况动态的选择最适合的作为leader.Kafka并不是使用这种方法。</p><p>Kafka动态维护了一个同步状态的副本的集合（a set of in-sync replicas），简称ISR，在这个集合中的节点都是和leader保持高度一致的，任何一条消息必须被这个集合中的每个节点读取并追加到日志中了，才回通知外部这个消息已经被提交了。因此这个集合中的任何一个节点随时都可以被选为leader.ISR在ZooKeeper中维护。ISR中有f+1个节点，就可以允许在f个节点down掉的情况下不会丢失消息并正常提供服。ISR的成员是动态的，如果一个节点被淘汰了，当它重新达到“同步中”的状态时，他可以重新加入ISR.这种leader的选择方式是非常快速的，适合kafka的应用场景。</p><p>一个邪恶的想法：如果所有节点都down掉了怎么办？Kafka对于数据不会丢失的保证，是基于至少一个节点是存活的，一旦所有节点都down了，这个就不能保证了。</p><p>实际应用中，当所有的副本都down掉时，必须及时作出反应。可以有以下两种选择:</p><ol><li><p>等待ISR中的任何一个节点恢复并担任leader。</p></li><li><p>选择所有节点中（不只是ISR）第一个恢复的节点作为leader.</p></li></ol><p>这是一个在可用性和连续性之间的权衡。如果等待ISR中的节点恢复，一旦ISR中的节点起不起来或者数据都是了，那集群就永远恢复不了了。如果等待ISR意外的节点恢复，这个节点的数据就会被作为线上数据，有可能和真实的数据有所出入，因为有些数据它可能还没同步到。Kafka目前选择了第二种策略，在未来的版本中将使这个策略的选择可配置，可以根据场景灵活的选择。</p><p>这种窘境不只Kafka会遇到，几乎所有的分布式数据系统都会遇到。</p><h5 id="10-副本管理"><a href="#10-副本管理" class="headerlink" title="10.副本管理"></a>10.副本管理</h5><p>以上仅仅以一个topic一个分区为例子进行了讨论，但实际上一个Kafka将会管理成千上万的topic分区.Kafka尽量的使所有分区均匀的分布到集群所有的节点上而不是集中在某些节点上，另外主从关系也尽量均衡这样每个几点都会担任一定比例的分区的leader.</p><p>优化leader的选择过程也是很重要的，它决定了系统发生故障时的空窗期有多久。Kafka选择一个节点作为“controller”,当发现有节点down掉的时候它负责在游泳分区的所有节点中选择新的leader,这使得Kafka可以批量的高效的管理所有分区节点的主从关系。如果controller down掉了，活着的节点中的一个会备切换为新的controller.</p><h5 id="11-Leader与副本同步"><a href="#11-Leader与副本同步" class="headerlink" title="11.Leader与副本同步"></a>11.Leader与副本同步</h5><p>对于某个分区来说，保存正分区的”broker”为该分区的”leader”，保存备份分区的”broker”为该分区的”follower”。备份分区会完全复制正分区的消息，包括消息的编号等附加属性值。为了保持正分区和备份分区的内容一致，Kafka采取的方案是在保存备份分区的”broker”上开启一个消费者进程进行消费，从而使得正分区的内容与备份分区的内容保持一致。一般情况下，一个分区有一个“正分区”和零到多个“备份分区”。可以配置“正分区+备份分区”的总数量，关于这个配置，不同主题可以有不同的配置值。注意，生产者，消费者只与保存正分区的”leader”进行通信。</p><p>Kafka允许topic的分区拥有若干副本，这个数量是可以配置的，你可以为每个topic配置副本的数量。Kafka会自动在每个副本上备份数据，所以当一个节点down掉时数据依然是可用的。</p><p>Kafka的副本功能不是必须的，你可以配置只有一个副本，这样其实就相当于只有一份数据。</p><p>创建副本的单位是topic的分区，每个分区都有一个leader和零或多个followers.所有的读写操作都由leader处理，一般分区的数量都比broker的数量多的多，各分区的leader均匀的分布在brokers中。所有的followers都复制leader的日志，日志中的消息和顺序都和leader中的一致。followers向普通的consumer那样从leader那里拉取消息并保存在自己的日志文件中。</p><p>许多分布式的消息系统自动的处理失败的请求，它们对一个节点是否着（alive）”有着清晰的定义。Kafka判断一个节点是否活着有两个条件：</p><ol><li><p>节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接。</p></li><li><p>如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久。</p></li></ol><p>符合以上条件的节点准确的说应该是“同步中的（in sync）”，而不是模糊的说是“活着的”或是“失败的”。Leader会追踪所有“同步中”的节点，一旦一个down掉了，或是卡住了，或是延时太久，leader就会把它移除。至于延时多久算是“太久”，是由参数replica.lag.max.messages决定的，怎样算是卡住了，怎是由参数replica.lag.time.max.ms决定的。</p><p>只有当消息被所有的副本加入到日志中时，才算是“committed”，只有committed的消息才会发送给consumer，这样就不用担心一旦leader down掉了消息会丢失。Producer也可以选择是否等待消息被提交的通知，这个是由参数acks决定的。</p><p>Kafka保证只要有一个“同步中”的节点，“committed”的消息就不会丢失。</p><p>kafka拓扑结构</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200228175857012.png" alt="image-20200228175857012"></p><p>   一个典型的Kafka集群中包含若干Producer（可以是web前端FET，或者是服务器日志等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干ConsumerGroup，以及一个Zookeeper集群。Kafka通过Zookeeper管理Kafka集群配置：选举Kafka broker的leader，以及在Consumer Group发生变化时进行rebalance，因为consumer消费kafka topic的partition的offsite信息是存在Zookeeper的。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。<br>分析过程分为以下4个步骤：</p><p>topic中partition存储分布<br>partiton中文件存储方式 (partition在linux服务器上就是一个目录（文件夹）)<br>partiton中segment文件存储结构<br>在partition中如何通过offset查找message<br>通过上述4过程详细分析，我们就可以清楚认识到kafka文件存储机制的奥秘。</p><h4 id="2-3-topic中partition存储分布"><a href="#2-3-topic中partition存储分布" class="headerlink" title="2.3 topic中partition存储分布"></a>2.3 topic中partition存储分布</h4><p>假设实验环境中Kafka集群只有一个broker，xxx/message-folder为数据文件存储根目录，在Kafka broker中server.properties文件配置(参数log.dirs=xxx/message-folder)，例如创建2个topic名 称分别为report_push、launch_info, partitions数量都为partitions=4</p><p>存储路径和目录规则为：</p><p>xxx/message-folder</p><p>|–report_push-0<br>|–report_push-1<br>|–report_push-2<br>|–report_push-3<br>|–launch_info-0<br>|–launch_info-1<br>|–launch_info-2<br>|–launch_info-3</p><p>在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。</p><p>消息发送时都被发送到一个topic，其本质就是一个目录，而topic由是由一些Partition组成,其组织结构如下图所示：</p><p>我们可以看到，Partition是一个Queue的结构，每个Partition中的消息都是有序的，生产的消息被不断追加到Partition上，其中的每一个消息都被赋予了一个唯一的offset值。</p><p>Kafka集群会保存所有的消息，不管消息有没有被消费；我们可以设定消息的过期时间，只有过期的数据才会被自动清除以释放磁盘空间。比如我们设置消息过期时间为2天，那么这2天内的所有消息都会被保存到集群中，数据只有超过了两天才会被清除。</p><p>Kafka只维护在Partition中的offset值，因为这个offsite标识着这个partition的message消费到哪条了。Consumer每消费一个消息，offset就会加1。其实消息的状态完全是由Consumer控制的，Consumer可以跟踪和重设这个offset值，这样的话Consumer就可以读取任意位置的消息。</p><p>把消息日志以Partition的形式存放有多重考虑，第一，方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；第二就是可以提高并发，因为可以以Partition为单位读写了。</p><p>通过上面介绍的我们可以知道，kafka中的数据是持久化的并且能够容错的。Kafka允许用户为每个topic设置副本数量，副本数量决定了有几个broker来存放写入的数据。如果你的副本数量设置为3，那么一份数据就会被存放在3台不同的机器上，那么就允许有2个机器失败。一般推荐副本数量至少为2，这样就可以保证增减、重启机器时不会影响到数据消费。如果对数据持久化有更高的要求，可以把副本数量设置为3或者更多。</p><p>Kafka中的topic是以partition的形式存放的，每一个topic都可以设置它的partition数量，Partition的数量决定了组成topic的message的数量。Producer在生产数据时，会按照一定规则（这个规则是可以自定义的）把消息发布到topic的各个partition中。上面将的副本都是以partition为单位的，不过只有一个partition的副本会被选举成leader作为读写用。</p><p>关于如何设置partition值需要考虑的因素。一个partition只能被一个消费者消费（一个消费者可以同时消费多个partition），因此，如果设置的partition的数量小于consumer的数量，就会有消费者消费不到数据。所以，推荐partition的数量一定要大于同时运行的consumer的数量。另外一方面，建议partition的数量大于集群broker的数量，这样leader partition就可以均匀的分布在各个broker中，最终使得集群负载均衡。在Cloudera,每个topic都有上百个partition。需要注意的是，kafka需要为每个partition分配一些内存来缓存消息数据，如果partition数量越大，就要为kafka分配更大的heap space。</p><h4 id="2-4-partiton中文件存储方式"><a href="#2-4-partiton中文件存储方式" class="headerlink" title="2.4 partiton中文件存储方式"></a>2.4 partiton中文件存储方式</h4><p>每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。<br>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。<br>这样做的好处就是能快速删除无用文件，有效提高磁盘利用率。</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/30191582944914_.pic_hd.jpg" alt="30191582944914_.pic_hd"></p><h4 id="2-5-partiton中segment文件存储结构"><a href="#2-5-partiton中segment文件存储结构" class="headerlink" title="2.5 partiton中segment文件存储结构"></a>2.5 partiton中segment文件存储结构</h4><p>producer发message到某个topic，message会被均匀的分布到多个partition上（随机或根据用户指定的回调函数进行分布），kafka broker收到message往对应partition的最后一个segment上添加该消息，当某个segment上的消息条数达到配置值或消息发布时间超过阈值时，segment上的消息会被flush到磁盘，只有flush到磁盘上的消息consumer才能消费，segment达到一定的大小后将不会再往该segment写数据，broker会创建新的segment。</p><p>每个part在内存中对应一个index，记录每个segment中的第一条消息偏移。</p><p>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件.<br>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个全局partion的最大offset(偏移message数)。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。<br>每个segment中存储很多条消息，消息id由其逻辑位置决定，即从消息id可直接定位到消息的存储位置，避免id到位置的额外映射。</p><p>下面文件列表是笔者在Kafka broker上做的一个实验，创建一个topicXXX包含1 partition，设置每个segment大小为500MB,并启动producer向Kafka broker写入大量数据,如下图2所示segment文件列表形象说明了上述2个规则：</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229105610652.png" alt="image-20200229105610652"><br>以上述图2中一对segment file文件为例，说明segment中index&lt;—-&gt;data file对应关系物理结构如下：</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229105649120.png" alt="image-20200229105649120"><br>上述图3中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。其中以索引文件中 元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移 地址为497。</p><p>从上述图3了解到segment data file由许多message组成，下面详细说明message物理结构如下：</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/30221582945041_.pic.jpg" alt="30221582945041_.pic"></p><p>参数说明：<br>关键字    解释说明<br>8 byte offset    在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message<br>4 byte message size    message大小<br>4 byte CRC32    用crc32校验message<br>1 byte “magic”    表示本次发布Kafka服务程序协议版本号<br>1 byte “attributes”    表示为独立版本、或标识压缩类型、或编码类型。<br>4 byte key length    表示key的长度,当key为-1时，K byte key字段不填<br>K byte key    可选<br>value bytes payload    表示实际消息数据。</p><h4 id="2-6-在partition中如何通过offset查找message"><a href="#2-6-在partition中如何通过offset查找message" class="headerlink" title="2.6 在partition中如何通过offset查找message"></a>2.6 在partition中如何通过offset查找message</h4><p>例如读取offset=368776的message，需要通过下面2个步骤查找。</p><p>第一步查找segment file</p><p>上述图2为例，其中00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件 00000000000000368769.index的消息量起始偏移量为368770 = 368769 + 1.同样，第三个文件00000000000000737337.index的起始偏移量为737338=737337 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset 二分查找文件列表，就可以快速定位到具体文件。</p><p>当offset=368776时定位到00000000000000368769.index|log</p><p>第二步通过segment file查找message通过第一步定位到segment file，当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和 00000000000000368769.log的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到 offset=368776为止。</p><p>segment index file采取稀疏索引存储方式，它减少索引文件大小，通过mmap可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针,它 比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p><p>kafka会记录offset到zk中。但是，zk client api对zk的频繁写入是一个低效的操作。0.8.2 kafka引入了native offset storage，将offset管理从zk移出，并且可以做到水平扩展。其原理就是利用了kafka的compacted topic，offset以consumer group,topic与partion的组合作为key直接提交到compacted topic中。同时Kafka又在内存中维护了的三元组来维护最新的offset信息，consumer来取最新offset信息的时候直接内存里拿即可。当然，kafka允许你快速的checkpoint最新的offset信息到磁盘上。</p><h3 id="3-Partition-Replication原则"><a href="#3-Partition-Replication原则" class="headerlink" title="3.Partition Replication原则"></a>3.Partition Replication原则</h3><p><strong>Kafka高效文件存储设计特点</strong></p><ul><li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</li><li>通过索引信息可以快速定位message和确定response的最大大小。</li><li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。</li><li>通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。</li></ul><ol><li>Kafka集群partition replication默认自动分配分析</li></ol><p>下面以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示：</p><p>(1)</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229111104070.png" alt="image-20200229111104070"></p><p>(2)当集群中新增2节点，Partition增加到6个时分布情况如下：</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229111118450.png" alt="image-20200229111118450"></p><p>副本分配逻辑规则如下：</p><ul><li>在Kafka集群中，每个Broker都有均等分配Partition的Leader机会。</li><li>上述图Broker Partition中，箭头指向为副本，以Partition-0为例:broker1中parition-0为Leader，Broker2中Partition-0为副本。</li><li>上述图种每个Broker(按照BrokerId有序)依次分配主Partition,下一个Broker为副本，如此循环迭代分配，多副本都遵循此规则。</li></ul><p>副本分配算法如下：</p><ul><li>将所有N Broker和待分配的i个Partition排序.</li><li>将第i个Partition分配到第(i mod n)个Broker上.</li><li>将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上.</li></ul><h3 id="4-Kafka-Broker一些特性"><a href="#4-Kafka-Broker一些特性" class="headerlink" title="4.Kafka Broker一些特性"></a>4.Kafka Broker一些特性</h3><h4 id="4-1-无状态的Kafka-Broker"><a href="#4-1-无状态的Kafka-Broker" class="headerlink" title="4.1 无状态的Kafka Broker :"></a>4.1 无状态的Kafka Broker :</h4><ol><li><p>Broker没有副本机制，一旦broker宕机，该broker的消息将都不可用。</p></li><li><p>Broker不保存订阅者的状态，由订阅者自己保存。</p></li><li><p>无状态导致消息的删除成为难题（可能删除的消息正在被订阅），kafka采用基于时间的SLA(服务水平保证)，消息保存一定时间（通常为7天）后会被删除。</p></li><li><p>消息订阅者可以rewind back到任意位置重新进行消费，当订阅者故障时，可以选择最小的offset进行重新读取消费消息。</p></li></ol><h4 id="4-2-message的交付与生命周期-："><a href="#4-2-message的交付与生命周期-：" class="headerlink" title="4.2 message的交付与生命周期 ："></a>4.2 message的交付与生命周期 ：</h4><ol><li><p>不是严格的JMS， 因此kafka对消息的重复、丢失、错误以及顺序型没有严格的要求。（这是与AMQ最大的区别）</p></li><li><p>kafka提供at-least-once delivery,即当consumer宕机后，有些消息可能会被重复delivery。</p></li><li><p>因每个partition只会被consumer group内的一个consumer消费，故kafka保证每个partition内的消息会被顺序的订阅。</p></li><li><p>Kafka为每条消息为每条消息计算CRC校验，用于错误检测，crc校验不通过的消息会直接被丢弃掉。</p></li></ol><h4 id="4-3-压缩"><a href="#4-3-压缩" class="headerlink" title="4.3 压缩"></a>4.3 压缩</h4><p>Kafka支持以集合（batch）为单位发送消息，在此基础上，Kafka还支持对消息集合进行压缩，Producer端可以通过GZIP或Snappy格式对消息集合进行压缩。Producer端进行压缩之后，在Consumer端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是CPU。</p><p>那么如何区分消息是压缩的还是未压缩的呢，Kafka在消息头部添加了一个描述压缩属性字节，这个字节的后两位表示消息的压缩采用的编码，如果后两位为0，则表示消息未被压缩。</p><h4 id="4-4-消息可靠性"><a href="#4-4-消息可靠性" class="headerlink" title="4.4 消息可靠性"></a>4.4 消息可靠性</h4><p>在消息系统中，保证消息在生产和消费过程中的可靠性是十分重要的，在实际消息传递过程中，可能会出现如下三中情况：</p><ul><li>一个消息发送失败</li><li>一个消息被发送多次</li><li>最理想的情况：exactly-once ,一个消息发送成功且仅发送了一次</li></ul><p>有许多系统声称它们实现了exactly-once，但是它们其实忽略了生产者或消费者在生产和消费过程中有可能失败的情况。比如虽然一个Producer成功发送一个消息，但是消息在发送途中丢失，或者成功发送到broker，也被consumer成功取走，但是这个consumer在处理取过来的消息时失败了。</p><p>从Producer端看：Kafka是这么处理的，当一个消息被发送后，Producer会等待broker成功接收到消息的反馈（可通过参数控制等待时间），如果消息在途中丢失或是其中一个broker挂掉，Producer会重新发送（我们知道Kafka有备份机制，可以通过参数控制是否等待所有备份节点都收到消息）。</p><p>从Consumer端看：前面讲到过partition，broker端记录了partition中的一个offset值，这个值指向Consumer下一个即将消费message。当Consumer收到了消息，但却在处理过程中挂掉，此时Consumer可以通过这个offset值重新找到上一个消息再进行处理。Consumer还有权限控制这个offset值，对持久化到broker端的消息做任意处理。</p><h4 id="4-5-备份机制"><a href="#4-5-备份机制" class="headerlink" title="4.5 备份机制"></a>4.5 备份机制</h4><p>备份机制是Kafka0.8版本的新特性，备份机制的出现大大提高了Kafka集群的可靠性、稳定性。有了备份机制后，Kafka允许集群中的节点挂掉后而不影响整个集群工作。一个备份数量为n的集群允许n-1个节点失败。在所有备份节点中，有一个节点作为lead节点，这个节点保存了其它备份节点列表，并维持各个备份间的状体同步。下面这幅图解释了Kafka的备份机制:</p><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229111139935.png" alt="image-20200229111139935"></p><h4 id="4-6-Kafka高效性相关设计"><a href="#4-6-Kafka高效性相关设计" class="headerlink" title="4.6 Kafka高效性相关设计"></a>4.6 Kafka高效性相关设计</h4><h5 id="4-6-1-消息的持久化"><a href="#4-6-1-消息的持久化" class="headerlink" title="4.6.1 消息的持久化"></a><strong>4.6.1 消息的持久化</strong></h5><p>Kafka高度依赖文件系统来存储和缓存消息(AMQ的nessage是持久化到mysql数据库中的)，因为一般的人认为磁盘是缓慢的，这导致人们对持久化结构具有竞争性持怀疑态度。其实，磁盘的快或者慢，这决定于我们如何使用磁盘。因为磁盘线性写的速度远远大于随机写。线性读写在大多数应用场景下是可以预测的。</p><h5 id="4-6-2-常数时间性能保证"><a href="#4-6-2-常数时间性能保证" class="headerlink" title="4.6.2 常数时间性能保证"></a><strong>4.6.2 常数时间性能保证</strong></h5><p>每个Topic的Partition的是一个大文件夹，里面有无数个小文件夹segment，但partition是一个队列，队列中的元素是segment,消费的时候先从第0个segment开始消费，新来message存在最后一个消息队列中。对于segment也是对队列，队列元素是message,有对应的offsite标识是哪个message。消费的时候先从这个segment的第一个message开始消费，新来的message存在segment的最后。</p><p>消息系统的持久化队列可以构建在对一个文件的读和追加上，就像一般情况下的日志解决方案。它有一个优点，所有的操作都是常数时间，并且读写之间不会相互阻塞。这种设计具有极大的性能优势：最终系统性能和数据大小完全无关，服务器可以充分利用廉价的硬盘来提供高效的消息服务。</p><p>事实上还有一点，磁盘空间的无限增大而不影响性能这点，意味着我们可以提供一般消息系统无法提供的特性。比如说，消息被消费后不是立马被删除，我们可以将这些消息保留一段相对比较长的时间（比如一个星期）。</p><h3 id="5-Kafka-生产者-消费者"><a href="#5-Kafka-生产者-消费者" class="headerlink" title="5.Kafka 生产者-消费者"></a>5.Kafka 生产者-消费者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息系统通常都会由生产者，消费者，Broker三大部分组成，生产者会将消息写入到Broker，消费者会从Broker中读取出消息，不同的MQ实现的Broker实现会有所不同，不过Broker的本质都是要负责将消息落地到服务端的存储系统中。具体步骤如下：</span><br></pre></td></tr></table></figure><ol><li><p>生产者客户端应用程序产生消息：</p><ol><li>客户端连接对象将消息包装到请求中发送到服务端</li><li>服务端的入口也有一个连接对象负责接收请求，并将消息以文件的形式存储起来</li><li>服务端返回响应结果给生产者客户端</li></ol></li><li><p>消费者客户端应用程序消费消息：</p><ol><li><p>客户端连接对象将消费信息也包装到请求中发送给服务端</p></li><li><p>服务端从文件存储系统中取出消息</p></li><li><p>服务端返回响应结果给消费者客户端</p></li><li><p>客户端将响应结果还原成消息并开始处理消息</p></li></ol></li></ol><h4 id="5-1-Producers"><a href="#5-1-Producers" class="headerlink" title="5.1  Producers"></a><strong>5.1  Producers</strong></h4><p>Producers直接发送消息到broker上的leader partition，不需要经过任何中介或其他路由转发。为了实现这个特性，kafka集群中的每个broker都可以响应producer的请求，并返回topic的一些元信息，这些元信息包括哪些机器是存活的，topic的leader partition都在哪，现阶段哪些leader partition是可以直接被访问的。</p><p>Producer客户端自己控制着消息被推送到哪些partition。实现的方式可以是随机分配、实现一类随机负载均衡算法，或者指定一些分区算法。Kafka提供了接口供用户实现自定义的partition，用户可以为每个消息指定一个partitionKey，通过这个key来实现一些hash分区算法。比如，把userid作为partitionkey的话，相同userid的消息将会被推送到同一个partition。</p><p>以Batch的方式推送数据可以极大的提高处理效率，kafka Producer 可以将消息在内存中累计到一定数量后作为一个batch发送请求。Batch的数量大小可以通过Producer的参数控制，参数值可以设置为累计的消息的数量（如500条）、累计的时间间隔（如100ms）或者累计的数据大小(64KB)。通过增加batch的大小，可以减少网络请求和磁盘IO的次数，当然具体参数设置需要在效率和时效性方面做一个权衡。</p><p>Producers可以异步的并行的向kafka发送消息，但是通常producer在发送完消息之后会得到一个future响应，返回的是offset值或者发送过程中遇到的错误。这其中有个非常重要的参数“acks”,这个参数决定了producer要求leader partition 收到确认的副本个数，如果acks设置数量为0，表示producer不会等待broker的响应，所以，producer无法知道消息是否发送成功，这样有可能会导致数据丢失，但同时，acks值为0会得到最大的系统吞吐量。</p><p>若acks设置为1，表示producer会在leader partition收到消息时得到broker的一个确认，这样会有更好的可靠性，因为客户端会等待直到broker确认收到消息。若设置为-1，producer会在所有备份的partition收到消息时得到broker的确认，这个设置可以得到最高的可靠性保证。</p><p>Kafka 消息有一个定长的header和变长的字节数组组成。因为kafka消息支持字节数组，也就使得kafka可以支持任何用户自定义的序列号格式或者其它已有的格式如Apache Avro、protobuf等。Kafka没有限定单个消息的大小，但我们推荐消息大小不要超过1MB,通常一般消息大小都在1~10kB之前。</p><p>发布消息时，kafka client先构造一条消息，将消息加入到消息集set中（kafka支持批量发布，可以往消息集合中添加多条消息，一次行发布），send消息时，producer client需指定消息所属的topic。</p><h4 id="5-2-Consumers"><a href="#5-2-Consumers" class="headerlink" title="5.2  Consumers"></a><strong>5.2  Consumers</strong></h4><p>Kafka提供了两套consumer api，分为high-level api和sample-api。Sample-api 是一个底层的API，它维持了一个和单一broker的连接，并且这个API是完全无状态的，每次请求都需要指定offset值，因此，这套API也是最灵活的。</p><p>在kafka中，当前读到哪条消息的offset值是由consumer来维护的，因此，consumer可以自己决定如何读取kafka中的数据。比如，consumer可以通过重设offset值来重新消费已消费过的数据。不管有没有被消费，kafka会保存数据一段时间，这个时间周期是可配置的，只有到了过期时间，kafka才会删除这些数据。（这一点与AMQ不一样，AMQ的message一般来说都是持久化到mysql中的，消费完的message会被delete掉）</p><p>High-level API封装了对集群中一系列broker的访问，可以透明的消费一个topic。它自己维持了已消费消息的状态，即每次消费的都是下一个消息。</p><p>High-level API还支持以组的形式消费topic，如果consumers有同一个组名，那么kafka就相当于一个队列消息服务，而各个consumer均衡的消费相应partition中的数据。若consumers有不同的组名，那么此时kafka就相当与一个广播服务，会把topic中的所有消息广播到每个consumer。</p><p>High level api和Low level api是针对consumer而言的，和producer无关。</p><p>High level api是consumer读的partition的offsite是存在zookeeper上。High level api 会启动另外一个线程去每隔一段时间，offsite自动同步到zookeeper上。换句话说，如果使用了High level api， 每个message只能被读一次，一旦读了这条message之后，无论我consumer的处理是否ok。High level api的另外一个线程会自动的把offiste+1同步到zookeeper上。如果consumer读取数据出了问题，offsite也会在zookeeper上同步。因此，如果consumer处理失败了，会继续执行下一条。这往往是不对的行为。因此，Best Practice是一旦consumer处理失败，直接让整个conusmer group抛Exception终止，但是最后读的这一条数据是丢失了，因为在zookeeper里面的offsite已经+1了。等再次启动conusmer group的时候，已经从下一条开始读取处理了。</p><p>Low level api是consumer读的partition的offsite在consumer自己的程序中维护。不会同步到zookeeper上。但是为了kafka manager能够方便的监控，一般也会手动的同步到zookeeper上。这样的好处是一旦读取某个message的consumer失败了，这条message的offsite我们自己维护，我们不会+1。下次再启动的时候，还会从这个offsite开始读。这样可以做到exactly once对于数据的准确性有保证。</p><p>对于Consumer group：</p><ol><li><p>允许consumer group（包含多个consumer，如一个集群同时消费）对一个topic进行消费，不同的consumer group之间独立消费。</p></li><li><p>为了对减小一个consumer group中不同consumer之间的分布式协调开销，指定partition为最小的并行消费单位，即一个group内的consumer只能消费不同的partition。</p></li></ol><p><img src="/2020/02/29/%E5%9C%A3%E5%A5%B3%E6%9E%9C%E6%9E%9C%E8%AF%BBKafka/image-20200229111212115.png" alt="image-20200229111212115"></p><p>Consumer与Partition的关系：</p><ul><li>如果consumer比partition多，是浪费，因为kafka的设计是在一个partition上是不允许并发的，所以consumer数不要大于partition数</li><li>如果consumer比partition少，一个consumer会对应于多个partitions，这里主要合理分配consumer数和partition数，否则会导致partition里面的数据被取的不均匀</li><li>如果consumer从多个partition读到数据，不保证数据间的顺序性，kafka只保证在一个partition上数据是有序的，但多个partition，根据你读的顺序会有不同</li><li>增减consumer，broker，partition会导致rebalance，所以rebalance后consumer对应的partition会发生变化</li><li>High-level接口中获取不到数据的时候是会block的</li></ul><p>负载低的情况下可以每个线程消费多个partition。但负载高的情况下，Consumer 线程数最好和Partition数量保持一致。如果还是消费不过来，应该再开 Consumer 进程，进程内线程数同样和分区数一致。</p><p>消费消息时，kafka client需指定topic以及partition number（每个partition对应一个逻辑日志流，如topic代表某个产品线，partition代表产品线的日志按天切分的结果），consumer client订阅后，就可迭代读取消息，如果没有消息，consumer client会阻塞直到有新的消息发布。consumer可以累积确认接收到的消息，当其确认了某个offset的消息，意味着之前的消息也都已成功接收到，此时broker会更新zookeeper上地offset registry。</p><h4 id="5-3-高效的数据传输"><a href="#5-3-高效的数据传输" class="headerlink" title="5.3  高效的数据传输"></a><strong>5.3  高效的数据传输</strong></h4><ol><li>发布者每次可发布多条消息（将消息加到一个消息集合中发布）， consumer每次迭代消费一条消息。</li><li>不创建单独的cache，使用系统的page cache。发布者顺序发布，订阅者通常比发布者滞后一点点，直接使用<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>的page cache效果也比较后，同时减少了cache管理及垃圾收集的开销。</li><li>使用sendfile优化网络传输，减少一次内存拷贝。</li></ol><h3 id="6-Kafka-与-Zookeeper"><a href="#6-Kafka-与-Zookeeper" class="headerlink" title="6.Kafka 与 Zookeeper"></a>6.Kafka 与 Zookeeper</h3><h4 id="6-1-Zookeeper-协调控制"><a href="#6-1-Zookeeper-协调控制" class="headerlink" title="6.1 Zookeeper 协调控制"></a>6.1 Zookeeper 协调控制</h4><ol><li><p>管理broker与consumer的动态加入与离开。(Producer不需要管理，随便一台计算机都可以作为Producer向Kakfa Broker发消息)</p></li><li><p>触发负载均衡，当broker或consumer加入或离开时会触发负载均衡算法，使得一</p><p>个consumer group内的多个consumer的消费负载平衡。（因为一个comsumer消费一个或多个partition，一个partition只能被一个consumer消费）</p></li><li><p>维护消费关系及每个partition的消费信息。</p></li></ol><p>6.2 Zookeeper上的细节：</p><ol><li>每个broker启动后会在zookeeper上注册一个临时的broker registry，包含broker的ip地址和端口号，所存储的topics和partitions信息。</li><li>每个consumer启动后会在zookeeper上注册一个临时的consumer registry：包含consumer所属的consumer group以及订阅的topics。</li><li>每个consumer group关联一个临时的owner registry和一个持久的offset registry。对于被订阅的每个partition包含一个owner registry，内容为订阅这个partition的consumer id；同时包含一个offset registry，内容为上一次订阅的offset。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kafka&quot;&gt;&lt;a href=&quot;#Kafka&quot; class=&quot;headerlink&quot; title=&quot;Kafka&quot;&gt;&lt;/a&gt;Kafka&lt;/h1&gt;&lt;h2 id=&quot;Kafka-2-4-Documentation&quot;&gt;&lt;a href=&quot;#Kafka-2-4-Document
      
    
    </summary>
    
    
      <category term="kafka" scheme="http://gottaboy.cn/categories/kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>confluent</title>
    <link href="http://gottaboy.cn/2020/02/28/confluent/"/>
    <id>http://gottaboy.cn/2020/02/28/confluent/</id>
    <published>2020-02-28T04:12:34.000Z</published>
    <updated>2020-02-28T05:44:57.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="confluent"><a href="#confluent" class="headerlink" title="confluent"></a>confluent</h2><p><a href="http://www.matools.com/" target="_blank" rel="noopener">http://www.matools.com/</a><br><a href="http://kafka.apache.org/events" target="_blank" rel="noopener">http://kafka.apache.org/events</a><br><a href="https://docs.confluent.io/current/streams/kafka-streams-examples/docs/index.html" target="_blank" rel="noopener">https://docs.confluent.io/current/streams/kafka-streams-examples/docs/index.html</a><br><a href="https://github.com/confluentinc/kafka-streams-examples" target="_blank" rel="noopener">https://github.com/confluentinc/kafka-streams-examples</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;confluent&quot;&gt;&lt;a href=&quot;#confluent&quot; class=&quot;headerlink&quot; title=&quot;confluent&quot;&gt;&lt;/a&gt;confluent&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.matools.com/&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="kafka" scheme="http://gottaboy.cn/categories/kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>GoStudy</title>
    <link href="http://gottaboy.cn/2020/01/28/GoStudy/"/>
    <id>http://gottaboy.cn/2020/01/28/GoStudy/</id>
    <published>2020-01-28T15:03:37.000Z</published>
    <updated>2020-01-28T15:03:58.678Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/8f2aab4f66bd" target="_blank" rel="noopener">https://www.jianshu.com/p/8f2aab4f66bd</a><br><a href="https://github.com/coldnight/go-memory-allocator-visual-guide" target="_blank" rel="noopener">https://github.com/coldnight/go-memory-allocator-visual-guide</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/8f2aab4f66bd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/8f2aab4f66bd&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>RedisStudy</title>
    <link href="http://gottaboy.cn/2020/01/28/RedisStudy/"/>
    <id>http://gottaboy.cn/2020/01/28/RedisStudy/</id>
    <published>2020-01-28T14:54:46.000Z</published>
    <updated>2020-01-29T11:00:51.154Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a><br><a href="https://www.jianshu.com/p/ad4fe7848030" target="_blank" rel="noopener">https://www.jianshu.com/p/ad4fe7848030</a><br><a href="https://www.jianshu.com/p/ad4fe7848030" target="_blank" rel="noopener">https://www.jianshu.com/p/ad4fe7848030</a><br><a href="https://stor.51cto.com/art/201910/605032.htm" target="_blank" rel="noopener">https://stor.51cto.com/art/201910/605032.htm</a><br><a href="https://www.cnblogs.com/breka/articles/9914787.html" target="_blank" rel="noopener">https://www.cnblogs.com/breka/articles/9914787.html</a><br><a href="https://www.jianshu.com/p/cf6f4df80509" target="_blank" rel="noopener">https://www.jianshu.com/p/cf6f4df80509</a><br><a href="https://zcheng.ren/categories/redis/" target="_blank" rel="noopener">https://zcheng.ren/categories/redis/</a><br><a href="https://blog.csdn.net/sinat_35261315/category_7380418.html" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35261315/category_7380418.html</a><br><a href="https://blog.csdn.net/men_wen/article/details/75668345" target="_blank" rel="noopener">https://blog.csdn.net/men_wen/article/details/75668345</a><br><a href="https://blog.csdn.net/kkwant/article/details/81668871" target="_blank" rel="noopener">https://blog.csdn.net/kkwant/article/details/81668871</a><br><a href="http://cmsblogs.com/?s=redis" target="_blank" rel="noopener">http://cmsblogs.com/?s=redis</a></p><p><a href="https://www.cnblogs.com/aflyun/" target="_blank" rel="noopener">https://www.cnblogs.com/aflyun/</a><br><a href="https://gitee.com/log4j" target="_blank" rel="noopener">https://gitee.com/log4j</a><br><a href="https://gitee.com/log4j/pig-ui" target="_blank" rel="noopener">https://gitee.com/log4j/pig-ui</a><br><a href="https://blog.csdn.net/u010648555/article/details/79471034" target="_blank" rel="noopener">https://blog.csdn.net/u010648555/article/details/79471034</a><br><a href="https://blog.csdn.net/alexyanglei/article/details/78895247" target="_blank" rel="noopener">https://blog.csdn.net/alexyanglei/article/details/78895247</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://doc.redisfans.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://doc.redisfans.com/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/ad
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Asciidoctor</title>
    <link href="http://gottaboy.cn/2020/01/28/Asciidoctor/"/>
    <id>http://gottaboy.cn/2020/01/28/Asciidoctor/</id>
    <published>2020-01-28T13:36:21.000Z</published>
    <updated>2020-01-29T11:00:51.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Asciidoctor"><a href="#Asciidoctor" class="headerlink" title="Asciidoctor"></a>Asciidoctor</h2><p><a href="https://github.com/asciidoctor/asciidoctor" target="_blank" rel="noopener">https://github.com/asciidoctor/asciidoctor</a><br><a href="https://www.jianshu.com/p/9b88feca33c0" target="_blank" rel="noopener">https://www.jianshu.com/p/9b88feca33c0</a><br><a href="http://www.what21.com/u/10004/4895501825056762414.htm" target="_blank" rel="noopener">http://www.what21.com/u/10004/4895501825056762414.htm</a><br><a href="https://www.jianshu.com/p/3a5679736dc0" target="_blank" rel="noopener">https://www.jianshu.com/p/3a5679736dc0</a><br><a href="https://blog.csdn.net/cy22201222/article/details/83692608" target="_blank" rel="noopener">https://blog.csdn.net/cy22201222/article/details/83692608</a><br><a href="https://blog.csdn.net/daisy_xiu/article/details/52368920" target="_blank" rel="noopener">https://blog.csdn.net/daisy_xiu/article/details/52368920</a><br><a href="https://www.cnblogs.com/zouqimeng/p/9062330.html" target="_blank" rel="noopener">https://www.cnblogs.com/zouqimeng/p/9062330.html</a><br><a href="https://blog.csdn.net/u013719669/article/details/80998225" target="_blank" rel="noopener">https://blog.csdn.net/u013719669/article/details/80998225</a><br><a href="https://github.com/Swagger2Markup/spring-swagger2markup-demo" target="_blank" rel="noopener">https://github.com/Swagger2Markup/spring-swagger2markup-demo</a><br><a href="https://github.com/nitianziluli/swagger2pdf" target="_blank" rel="noopener">https://github.com/nitianziluli/swagger2pdf</a><br><a href="https://github.com/woshihoujinxin/swagger-gendoc" target="_blank" rel="noopener">https://github.com/woshihoujinxin/swagger-gendoc</a><br><a href="https://blog.csdn.net/java_collect/article/details/84480588" target="_blank" rel="noopener">https://blog.csdn.net/java_collect/article/details/84480588</a><br><a href="https://github.com/spiritn/spring-swagger2markup-demo" target="_blank" rel="noopener">https://github.com/spiritn/spring-swagger2markup-demo</a><br><a href="https://blog.csdn.net/gongxsh00/article/details/80508963" target="_blank" rel="noopener">https://blog.csdn.net/gongxsh00/article/details/80508963</a><br><a href="https://leongfeng.github.io/2017/02/20/springboot-springfox-swagger2markup-spring-restdoc/" target="_blank" rel="noopener">https://leongfeng.github.io/2017/02/20/springboot-springfox-swagger2markup-spring-restdoc/</a><br><a href="https://leongfeng.github.io/2017/09/25/DFS-BFS/" target="_blank" rel="noopener">https://leongfeng.github.io/2017/09/25/DFS-BFS/</a><br><a href="http://www.what21.com/u/10004/4895501825056762414.htm" target="_blank" rel="noopener">http://www.what21.com/u/10004/4895501825056762414.htm</a><br>[酷 壳 – COOLSHELL] <a href="https://coolshell.cn/articles/10975.html" target="_blank" rel="noopener">https://coolshell.cn/articles/10975.html</a> 酷 壳 – COOLSHELL<br><a href="https://niocoder.com" target="_blank" rel="noopener">https://niocoder.com</a><br><a href="https://github.com/longfeizheng/blockchain-java" target="_blank" rel="noopener">https://github.com/longfeizheng/blockchain-java</a><br><a href="https://github.com/longfeizheng/sso-merryyou" target="_blank" rel="noopener">https://github.com/longfeizheng/sso-merryyou</a><br><a href="http://www.iocoder.cn/?vip" target="_blank" rel="noopener">http://www.iocoder.cn/?vip</a><br><a href="http://beautyboss.me/" target="_blank" rel="noopener">http://beautyboss.me/</a><br><a href="https://sunznx.com/redis/redis-source-debug-with-clion.html" target="_blank" rel="noopener">https://sunznx.com/redis/redis-source-debug-with-clion.html</a><br><a href="https://sunznx.com/redis/redis-source-reading-stream.html" target="_blank" rel="noopener">https://sunznx.com/redis/redis-source-reading-stream.html</a></p><p>mall<br><a href="https://gitee.com/catshen/zscat_sw" target="_blank" rel="noopener">https://gitee.com/catshen/zscat_sw</a><br><a href="https://gitee.com/macrozheng/mall-admin-web" target="_blank" rel="noopener">https://gitee.com/macrozheng/mall-admin-web</a><br><a href="http://yjlive.cn:8084/#/" target="_blank" rel="noopener">http://yjlive.cn:8084/#/</a><br><a href="https://www.felord.cn/spring-boot-log4j2.html" target="_blank" rel="noopener">https://www.felord.cn/spring-boot-log4j2.html</a></p><p><a href="https://github.com/macrozheng/mall-learning" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning</a><br><a href="https://github.com/macrozheng/mall-swarm" target="_blank" rel="noopener">https://github.com/macrozheng/mall-swarm</a><br><a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener">https://github.com/newbee-ltd/newbee-mall</a><br><a href="https://gitee.com/catshen" target="_blank" rel="noopener">https://gitee.com/catshen</a><br><a href="https://gitee.com/owenwangwen/open-capacity-platform" target="_blank" rel="noopener">https://gitee.com/owenwangwen/open-capacity-platform</a><br><a href="https://gitee.com/zlt2000/microservices-platform" target="_blank" rel="noopener">https://gitee.com/zlt2000/microservices-platform</a><br><a href="https://github.com/Mynameisfwk/vivo-shop" target="_blank" rel="noopener">https://github.com/Mynameisfwk/vivo-shop</a></p><p><a href="https://github.com/YunaiV/onemall" target="_blank" rel="noopener">https://github.com/YunaiV/onemall</a><br><a href="http://blog.didispace.com/tags/Sentinel/" target="_blank" rel="noopener">http://blog.didispace.com/tags/Sentinel/</a></p><p><a href="https://gitee.com/catshen/zscat_sw" target="_blank" rel="noopener">https://gitee.com/catshen/zscat_sw</a><br><a href="https://gitee.com/zscat/zscat-platform" target="_blank" rel="noopener">https://gitee.com/zscat/zscat-platform</a></p><p><a href="https://github.com/wuyouzhuguli/FEBS-Vue" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/FEBS-Vue</a><br><a href="https://github.com/wuyouzhuguli/FEBS-Shiro" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/FEBS-Shiro</a><br><a href="https://github.com/wuyouzhuguli/FEBS-Security" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/FEBS-Security</a><br><a href="https://security.mrbird.cc/deploy.html" target="_blank" rel="noopener">https://security.mrbird.cc/deploy.html</a><br><a href="https://github.com/codecentric/spring-boot-admin" target="_blank" rel="noopener">https://github.com/codecentric/spring-boot-admin</a><br><a href="https://codecentric.github.io/spring-boot-admin/2.1.6/" target="_blank" rel="noopener">https://codecentric.github.io/spring-boot-admin/2.1.6/</a><br><a href="https://blog.csdn.net/Dream_xun/article/details/82743762" target="_blank" rel="noopener">https://blog.csdn.net/Dream_xun/article/details/82743762</a><br><a href="https://www.cnblogs.com/qinxu/p/9504412.html" target="_blank" rel="noopener">https://www.cnblogs.com/qinxu/p/9504412.html</a><br><a href="https://segmentfault.com/a/1190000013950461" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013950461</a><br><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a><br><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a><br><a href="https://www.redis.net.cn/order/3564.html" target="_blank" rel="noopener">https://www.redis.net.cn/order/3564.html</a><br><a href="https://github.com/wuyouzhuguli/FEBS-Cloud-Web" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/FEBS-Cloud-Web</a><br><a href="https://github.com/wuyouzhuguli/FEBS-Cloud" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/FEBS-Cloud</a></p><p><a href="https://www.felord.cn/categories/spring-security/" target="_blank" rel="noopener">https://www.felord.cn/categories/spring-security/</a><br><a href="https://www.felord.cn/spring-security-crypt.html" target="_blank" rel="noopener">https://www.felord.cn/spring-security-crypt.html</a><br><a href="https://www.felord.cn/spring-boot-mock-test.html" target="_blank" rel="noopener">https://www.felord.cn/spring-boot-mock-test.html</a><br><a href="https://www.felord.cn/spring-cloud-nacos-discovery.html" target="_blank" rel="noopener">https://www.felord.cn/spring-cloud-nacos-discovery.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Asciidoctor&quot;&gt;&lt;a href=&quot;#Asciidoctor&quot; class=&quot;headerlink&quot; title=&quot;Asciidoctor&quot;&gt;&lt;/a&gt;Asciidoctor&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/asciid
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IchingCloud</title>
    <link href="http://gottaboy.cn/2020/01/28/IchingCloud/"/>
    <id>http://gottaboy.cn/2020/01/28/IchingCloud/</id>
    <published>2020-01-28T13:35:09.000Z</published>
    <updated>2020-02-03T04:07:12.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IchingSource"><a href="#IchingSource" class="headerlink" title="IchingSource"></a>IchingSource</h2><p><a href="https://github.com/ityouknow/awesome-spring-cloud" target="_blank" rel="noopener">https://github.com/ityouknow/awesome-spring-cloud</a><br><a href="https://gitee.com/mirrors/Tekton" target="_blank" rel="noopener">https://gitee.com/mirrors/Tekton</a><br><a href="https://segmentfault.com/a/1190000020182215" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020182215</a><br><a href="https://cd.foundation/projects/" target="_blank" rel="noopener">https://cd.foundation/projects/</a><br><a href="https://mp.weixin.qq.com/s/fbAD3F-X6RUsaJ95671QiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fbAD3F-X6RUsaJ95671QiA</a><br><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou" target="_blank" rel="noopener">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a><br><a href="https://mp.weixin.qq.com/s/wD1DU6ZOnhmTYCZYs5F8Dw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wD1DU6ZOnhmTYCZYs5F8Dw</a><br><a href="https://github.com/kevinfaguiar/cool-emoji-picker" target="_blank" rel="noopener">https://github.com/kevinfaguiar/cool-emoji-picker</a><br><a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">https://github.com/vuejs/awesome-vue</a><br><a href="https://github.com/codesandbox/codesandbox-client" target="_blank" rel="noopener">https://github.com/codesandbox/codesandbox-client</a><br><a href="https://codesandbox.io/s/4xxxkznk74" target="_blank" rel="noopener">https://codesandbox.io/s/4xxxkznk74</a><br><a href="https://github.com/shershen08/vue-terminal-ui" target="_blank" rel="noopener">https://github.com/shershen08/vue-terminal-ui</a><br><a href="https://github.com/BrockReece/vue-kanban" target="_blank" rel="noopener">https://github.com/BrockReece/vue-kanban</a><br><a href="https://github.com/ndabAP/vue-command" target="_blank" rel="noopener">https://github.com/ndabAP/vue-command</a><br><a href="https://ndabap.github.io/vue-command/" target="_blank" rel="noopener">https://ndabap.github.io/vue-command/</a><br><a href="https://kevinfaguiar.github.io/cool-emoji-picker/#home" target="_blank" rel="noopener">https://kevinfaguiar.github.io/cool-emoji-picker/#home</a><br><a href="https://github.com/SevenOutman/vue-aplayer" target="_blank" rel="noopener">https://github.com/SevenOutman/vue-aplayer</a><br><a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">https://github.com/MoePlayer/APlayer</a><br><a href="https://github.com/MoePlayer/vue-aplayer" target="_blank" rel="noopener">https://github.com/MoePlayer/vue-aplayer</a><br><a href="https://github.com/SevenOutman/vue-aplayer" target="_blank" rel="noopener">https://github.com/SevenOutman/vue-aplayer</a><br><a href="https://github.com/gruhn/vue-qrcode-reader" target="_blank" rel="noopener">https://github.com/gruhn/vue-qrcode-reader</a><br><a href="https://github.com/superman66/vue-qart" target="_blank" rel="noopener">https://github.com/superman66/vue-qart</a><br><a href="https://github.com/theomessin/vue-qriously" target="_blank" rel="noopener">https://github.com/theomessin/vue-qriously</a><br><a href="https://github.com/appbaseio/reactivesearch" target="_blank" rel="noopener">https://github.com/appbaseio/reactivesearch</a><br><a href="https://mp.weixin.qq.com/s/aLLIVa_swKyU7rhYVjzg5w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aLLIVa_swKyU7rhYVjzg5w</a><br><a href="https://mp.weixin.qq.com/s/Oj3DWvAHXD17NQsllzBVJQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Oj3DWvAHXD17NQsllzBVJQ</a></p><p>cloud native 12要素<br><a href="https://12factor.net/" target="_blank" rel="noopener">https://12factor.net/</a><br><a href="https://github.com/adamwiggins/12factor" target="_blank" rel="noopener">https://github.com/adamwiggins/12factor</a><br><a href="https://github.com/heroku/12factor" target="_blank" rel="noopener">https://github.com/heroku/12factor</a><br><a href="https://github.com/heroku" target="_blank" rel="noopener">https://github.com/heroku</a><br><a href="https://github.com/adamwiggins" target="_blank" rel="noopener">https://github.com/adamwiggins</a><br><a href="https://github.com/autodidaddict" target="_blank" rel="noopener">https://github.com/autodidaddict</a><br><a href="https://github.com/autodidaddict/go-shopping" target="_blank" rel="noopener">https://github.com/autodidaddict/go-shopping</a><br><a href="https://github.com/dnem" target="_blank" rel="noopener">https://github.com/dnem</a><br><a href="http://play.golang.org" target="_blank" rel="noopener">http://play.golang.org</a></p><p>brew install git<br>brew install go<br>brew install mercurial<br>brew install bazaar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line"></span><br><span class="line">yarn global add vuepress # 或者：npm install -g vuepress</span><br><span class="line"></span><br><span class="line"># 新建一个 markdown 文件</span><br><span class="line">echo &#39;# Hello VuePress!&#39; &gt; README.md</span><br><span class="line"></span><br><span class="line"># 开始写作</span><br><span class="line">vuepress dev .</span><br><span class="line"></span><br><span class="line"># 构建静态文件</span><br><span class="line">vuepress build .</span><br><span class="line"></span><br><span class="line">yarn add -D vuepress-theme-onen</span><br><span class="line"># or npm install -D vuepress-theme-onen</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/pangguoming/p/10510665.html" target="_blank" rel="noopener">https://www.cnblogs.com/pangguoming/p/10510665.html</a></p><p>blog<br><a href="https://github.com/docsifyjs/docsify" target="_blank" rel="noopener">https://github.com/docsifyjs/docsify</a><br><a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">https://github.com/vuejs/vuex</a><br><a href="https://www.vuepress.cn/" target="_blank" rel="noopener">https://www.vuepress.cn/</a><br><a href="https://vuepress-theme-reco.recoluan.com/" target="_blank" rel="noopener">https://vuepress-theme-reco.recoluan.com/</a><br>vuepress-theme-onen<br><a href="https://www.cnblogs.com/pangguoming/p/10350730.html" target="_blank" rel="noopener">https://www.cnblogs.com/pangguoming/p/10350730.html</a><br><a href="https://www.recoluan.com/" target="_blank" rel="noopener">https://www.recoluan.com/</a><br><a href="https://vuepress-theme-reco.recoluan.com/views/other/theme-example.html" target="_blank" rel="noopener">https://vuepress-theme-reco.recoluan.com/views/other/theme-example.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">npx @vuepress-reco&#x2F;theme-cli init my-blog</span><br><span class="line"></span><br><span class="line"># init</span><br><span class="line">npm install @vuepress-reco&#x2F;theme-cli -g</span><br><span class="line">theme-cli init my-blog</span><br><span class="line"></span><br><span class="line"># install</span><br><span class="line">cd my-blog</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"># run</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"># build</span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"># init</span><br><span class="line">yarn global add @vuepress-reco&#x2F;theme-cli</span><br><span class="line">theme-cli init my-blog</span><br><span class="line"></span><br><span class="line"># install</span><br><span class="line">cd my-blog</span><br><span class="line">yarn install</span><br><span class="line"></span><br><span class="line"># run</span><br><span class="line">yarn dev</span><br><span class="line"></span><br><span class="line"># build</span><br><span class="line">yarn build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;</span><br><span class="line">https:&#x2F;&#x2F;snailclimb.gitee.io&#x2F;javaguide&#x2F;#&#x2F;docs&#x2F;data&#x2F;spring-boot-practical-projects</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Snailclimb&#x2F;JavaGuide&#x2F;blob&#x2F;master&#x2F;docs&#x2F;dataStructures-algorithms&#x2F;data-structure&#x2F;bloom-filter.md</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Snailclimb&#x2F;JavaGuide</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rmetcalf9&#x2F;dockJob</span><br><span class="line">https:&#x2F;&#x2F;konghq.com&#x2F;ebooks&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kong&#x2F;kong</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kong&#x2F;docs.konghq.com</span><br><span class="line">https:&#x2F;&#x2F;docs.konghq.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quasarframework&#x2F;quasar-awesome</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quasarframework&#x2F;quasar</span><br><span class="line">https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;api&#x2F;#beforeCreate</span><br><span class="line">https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;ssr.html</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.iocoder.cn&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;www.ityouknow.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.cnkirito.moe&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;www.tianxiaobo.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ityouknow&#x2F;awesome-spring-cloud</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;jmdhappy&#x2F;xxpay-master</span><br><span class="line">http:&#x2F;&#x2F;docs.xxpay.org&#x2F;docs&#x2F;deploy</span><br><span class="line">https:&#x2F;&#x2F;edu.csdn.net&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;wells2333&#x2F;spring-microservice-exa</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;log4j&#x2F;pig</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ityouknow</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;xfdm_admin&#x2F;Angular-SpringCloud-Oauth2</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;xfdm&#x2F;FCat</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;wells2333&#x2F;spring-cloud-online-exam</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;wells2333</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ityouknow&#x2F;diagram</span><br><span class="line">http:&#x2F;&#x2F;ehedgehog.net&#x2F;2019&#x2F;04&#x2F;22&#x2F;%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9FV2.0%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E3%80%81%E6%8E%A8%E9%80%81%E3%80%81%E9%83%A8%E7%BD%B2&#x2F;</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;konghq.com&#x2F;ebooks&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;eyFbqjznHH3kJNlThq5SVg</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;nazrTU_bduepk6G7mAZ5RQ</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;mmuNB5M_4P7ao4q_ei9EuQ</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;4ENJop72fxOzsoRJilO9YA</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;asyncins&#x2F;acrust</span><br><span class="line">https:&#x2F;&#x2F;webpack.docschina.org&#x2F;configuration&#x2F;plugins&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.javaboy.org&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lenve&#x2F;VBlog</span><br><span class="line">https:&#x2F;&#x2F;www.processon.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.kancloud.cn&#x2F;mrbird&#x2F;spring-cloud&#x2F;1263718</span><br><span class="line">http:&#x2F;&#x2F;es6.ruanyifeng.com&#x2F;#docs&#x2F;module</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ruanyf&#x2F;es6tutorial</span><br><span class="line">https:&#x2F;&#x2F;wangdoc.com&#x2F;javascript&#x2F;bom&#x2F;webworker.html</span><br><span class="line">https:&#x2F;&#x2F;mrbird.cc&#x2F;page&#x2F;33&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;mrbird.cc&#x2F;WireMock-mock-RESTful.html</span><br><span class="line">https:&#x2F;&#x2F;www.kancloud.cn&#x2F;lengleng&#x2F;pig-guide</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;macrozheng&#x2F;mall</span><br><span class="line">https:&#x2F;&#x2F;easy-mock.com&#x2F;login</span><br><span class="line">https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1493505</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;mirrors&#x2F;Tekton</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;javaguide.cn&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;snailclimb.gitee.io&#x2F;javaguide&#x2F;#&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;gMaYGAfVhYtXFpOEOKBqiQ</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dc99aafaf953</span><br><span class="line">https:&#x2F;&#x2F;www.hollischuang.com&#x2F;archives&#x2F;4255</span><br></pre></td></tr></table></figure><p>public class GiraffeService implements   ApplicationContextAware,<br>        ApplicationEventPublisherAware, BeanClassLoaderAware, BeanFactoryAware,<br>        BeanNameAware, EnvironmentAware, ImportAware, ResourceLoaderAware{<br>         @Override<br>    public void setBeanClassLoader(ClassLoader classLoader) {<br>        System.out.println(“执行setBeanClassLoader,ClassLoader Name = “ + classLoader.getClass().getName());<br>    }<br>    @Override<br>    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {<br>        System.out.println(“执行setBeanFactory,setBeanFactory:: giraffe bean singleton=” +  beanFactory.isSingleton(“giraffeService”));<br>    }<br>    @Override<br>    public void setBeanName(String s) {<br>        System.out.println(“执行setBeanName:: Bean Name defined in context=”<br>                + s);<br>    }<br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {<br>        System.out.println(“执行setApplicationContext:: Bean Definition Names=”<br>                + Arrays.toString(applicationContext.getBeanDefinitionNames()));<br>    }<br>    @Override<br>    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {<br>        System.out.println(“执行setApplicationEventPublisher”);<br>    }<br>    @Override<br>    public void setEnvironment(Environment environment) {<br>        System.out.println(“执行setEnvironment”);<br>    }<br>    @Override<br>    public void setResourceLoader(ResourceLoader resourceLoader) {<br>        Resource resource = resourceLoader.getResource(“classpath:spring-beans.xml”);<br>        System.out.println(“执行setResourceLoader:: Resource File Name=”<br>                + resource.getFilename());<br>    }<br>    @Override<br>    public void setImportMetadata(AnnotationMetadata annotationMetadata) {<br>        System.out.println(“执行setImportMetadata”);<br>    }<br>}</p><p>public class GiraffeService implements InitializingBean,DisposableBean {<br>    @Override<br>    public void afterPropertiesSet() throws Exception {<br>        System.out.println(“执行InitializingBean接口的afterPropertiesSet方法”);<br>    }<br>    @Override<br>    public void destroy() throws Exception {<br>        System.out.println(“执行DisposableBean接口的destroy方法”);<br>    }<br>}</p><bean name="giraffeService" class="com.giraffe.spring.service.GiraffeService" init-method="initMethod" destroy-method="destroyMethod"></bean>public class GiraffeService {    //通过<bean>的destroy-method属性指定的销毁方法    public void destroyMethod() throws Exception {        System.out.println("执行配置的destroy-method");    }    //通过<bean>的init-method属性指定的初始化方法    public void initMethod() throws Exception {        System.out.println("执行配置的init-method");    }}<bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor" />public class GiraffeService {    @PostConstruct    public void initPostConstruct(){        System.out.println("执行PostConstruct注解标注的方法");    }    @PreDestroy    public void preDestroy(){        System.out.println("执行preDestroy注解标注的方法");    }}<bean class="com.giraffe.spring.service.CustomerBeanPostProcessor"/>public class CustomerBeanPostProcessor implements BeanPostProcessor {    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println("执行BeanPostProcessor的postProcessBeforeInitialization方法,beanName=" + beanName);        return bean;    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println("执行BeanPostProcessor的postProcessAfterInitialization方法,beanName=" + beanName);        return bean;    }}```<h1 id="Spring容器初始化"><a href="#Spring容器初始化" class="headerlink" title="Spring容器初始化"></a>Spring容器初始化</h1><p>调用GiraffeService无参构造函数<br>GiraffeService中利用set方法设置属性值<br>调用setBeanName:: Bean Name defined in context=giraffeService<br>调用setBeanClassLoader,ClassLoader Name = sun.misc.Launcher$AppClassLoader<br>调用setBeanFactory,setBeanFactory:: giraffe bean singleton=true<br>调用setEnvironment<br>调用setResourceLoader:: Resource File Name=spring-beans.xml<br>调用setApplicationEventPublisher<br>调用setApplicationContext:: Bean Definition Names=[giraffeService, org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#0, com.giraffe.spring.service.GiraffeServicePostProcessor#0]<br>执行BeanPostProcessor的postProcessBeforeInitialization方法,beanName=giraffeService<br>调用PostConstruct注解标注的方法<br>执行InitializingBean接口的afterPropertiesSet方法<br>执行配置的init-method<br>执行BeanPostProcessor的postProcessAfterInitialization方法,beanName=giraffeService<br>Spring容器初始化完毕<br>=====================================<br>从容器中获取Bean<br>giraffe Name=李光洙<br>=====================================<br>调用preDestroy注解标注的方法<br>执行DisposableBean接口的destroy方法<br>执行配置的destroy-method<br>Spring容器关闭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IchingSource&quot;&gt;&lt;a href=&quot;#IchingSource&quot; class=&quot;headerlink&quot; title=&quot;IchingSource&quot;&gt;&lt;/a&gt;IchingSource&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/it
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nacos</title>
    <link href="http://gottaboy.cn/2020/01/14/Nacos/"/>
    <id>http://gottaboy.cn/2020/01/14/Nacos/</id>
    <published>2020-01-14T02:38:56.000Z</published>
    <updated>2020-01-20T10:41:45.027Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/forezp/p/10136433.html" target="_blank" rel="noopener">https://www.cnblogs.com/forezp/p/10136433.html</a><br><a href="https://mp.weixin.qq.com/s/L9VN1mH-bqEdxUcz9Wk-Aw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/L9VN1mH-bqEdxUcz9Wk-Aw</a><br><a href="https://blog.csdn.net/ejinxian/article/details/82014240" target="_blank" rel="noopener">https://blog.csdn.net/ejinxian/article/details/82014240</a><br><a href="https://gitee.com/fuhoujun/e" target="_blank" rel="noopener">https://gitee.com/fuhoujun/e</a></p><p>Nacos Server<br>在使用 Nacos 之前，需要先下载 Nacos 并启动 Nacos Server。</p><p>Nacos Server 有两种运行模式：</p><p>standalone<br>cluster<br>不论哪种方式吧，都需要先去 <a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a> 下载最新的 release 包，然后解压，以 nacos-server-0.4.0.zip 为例</p><p>unzip nacos-server-0.4.0.zip<br>cd nacos<br>standalone 模式<br>此模式一般用于 demo 和测试，不用改任何配置，直接敲以下命令执行</p><p>sh bin/startup.sh -m standalone<br>Windows 的话就是</p><p>cmd bin/startup.cmd -m standalone<br>然后从 <a href="http://localhost:8848/nacos/index.html" target="_blank" rel="noopener">http://localhost:8848/nacos/index.html</a> 进入控制台就能看到如下界面了</p><h2 id="https-mp-weixin-qq-com-s-7UlQ0gp6PDWiFuyevxjW-A"><a href="#https-mp-weixin-qq-com-s-7UlQ0gp6PDWiFuyevxjW-A" class="headerlink" title="https://mp.weixin.qq.com/s/7UlQ0gp6PDWiFuyevxjW_A"></a><a href="https://mp.weixin.qq.com/s/7UlQ0gp6PDWiFuyevxjW_A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7UlQ0gp6PDWiFuyevxjW_A</a></h2><p>1.Redis 面试题</p><p>1、什么是 Redis?.<br>2、Redis 的数据类型？<br>3、使用 Redis 有哪些好处？<br>4、Redis 相比 Memcached 有哪些优势？<br>5、Memcache 与 Redis 的区别都有哪些？<br>6、Redis 是单进程单线程的？<br>7、一个字符串类型的值能存储最大容量是多少？<br>8、Redis 的持久化机制是什么？各自的优缺点？<br>9、Redis 常见性能问题和解决方案：<br>10、redis 过期键的删除策略？<br>11、Redis 的回收策略（淘汰策略）?<br>12、为什么 edis 需要把所有数据放到内存中？<br>13、Redis 的同步机制了解么？<br>14、Pipeline 有什么好处，为什么要用 pipeline？<br>15、是否使用过 Redis 集群，集群的原理是什么？<br>16、Redis 集群方案什么情况下会导致整个集群不可用？<br>17、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？<br>18、Jedis 与 Redisson 对比有什么优缺点？<br>19、Redis 如何设置密码及验证密码？<br>20、说说 Redis 哈希槽的概念？</p><p>(文末附面试答案)</p><p>2.Dubbo 面试题</p><p>1、Dubbo是什么？<br>2、为什么要用Dubbo？<br>3、Dubbo 和 Spring Cloud 有什么区别？<br>4、dubbo都支持什么协议，推荐用哪种？<br>5、Dubbo需要 Web 容器吗？<br>6、Dubbo内置了哪几种服务容器？<br>7、Dubbo里面有哪几种节点角色？<br>8、画一画服务注册与发现的流程图<br>9、Dubbo默认使用什么注册中心，还有别的选择吗？<br>10、Dubbo有哪几种配置方式？<br>11、Dubbo 核心的配置有哪些？<br>12、在 Provider 上可以配置的 Consumer 端的属性有哪些？<br>13、Dubbo启动时如果依赖的服务不可用会怎样？<br>14、Dubbo推荐使用什么序列化框架，你知道的还有哪些？<br>15、Dubbo默认使用的是什么通信框架，还有别的选择吗？<br>16、Dubbo有哪几种集群容错方案，默认是哪种？<br>17、Dubbo有哪几种负载均衡策略，默认是哪种？<br>18、注册了多个同一样的服务，如果测试指定的某一个服务呢？<br>19、Dubbo支持服务多协议吗？<br>20、当一个服务接口有多种实现时怎么做？</p><p>(文末附面试答案)</p><p>3.Spring Boot 面试题<br>1、什么是 Spring Boot？<br>2、Spring Boot 有哪些优点？<br>3、什么是 JavaConfig？<br>4、如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？<br>5、Spring Boot 中的监视器是什么？<br>6、如何在 Spring Boot 中禁用 Actuator 端点安全性？<br>7、如何在自定义端口上运行 Spring Boot 应用程序？<br>8、什么是 YAML？<br>9、如何实现 Spring Boot 应用程序的安全性？<br>10、如何集成 Spring Boot 和 ActiveMQ？<br>11、如何使用 Spring Boot 实现分页和排序？<br>12、什么是 Swagger？你用 Spring Boot 实现了它吗？<br>13、什么是 Spring Profiles？<br>14、什么是 Spring Batch？<br>15、什么是 FreeMarker 模板？<br>16、如何使用 Spring Boot 实现异常处理？<br>17、您使用了哪些 starter maven 依赖项？<br>18、什么是 CSRF 攻击？<br>19、什么是 WebSockets？<br>20、什么是 AOP？<br>21、什么是 Apache Kafka？<br>22、我们如何监视所有 Spring Boot 微服务？</p><p>4.Spring Cloud 面试题</p><p>1、什么是Spring Cloud？<br>2、使用Spring Cloud有什么优势？<br>3、服务注册和发现是什么意思？Spring Cloud如何实现？<br>4、负载平衡的意义什么？<br>5、什么是Hystrix？它如何实现容错？<br>6、什么是Hystrix断路器？我们需要它吗？<br>7、什么是Netflix Feign？它的优点是什么？<br>8、什么是Spring Cloud Bus？我们需要它吗？</p><p>5.JVM面试题<br>1、JVM三大性能调优参数，JVM 几个重要的参数<br>2、JVM调优<br>3、JVM内存管理，JVM的常见的垃圾收集器，Ｇ１垃圾收集器。GC调优，Minor GC ，Full GC 触发条件<br>4、java内存模型<br>5、Java垃圾回收机制<br>6、jvm怎样 判断一个对象是否可回收，怎样的对象才能作为GC root<br>7、OOM说一下？怎么排查？哪些会导致OOM? OOM出现在什么时候<br>8、什么是Full GC？GC? major GC? stop the world<br>9、描述JVM中一次full gc过程。<br>10、JVM中类加载机制，类加载过程，什么是双亲委派模型？，类加载器有哪些<br>11、如何判断是否有内存泄露？定位 Full GC 发生的原因，有哪些方式？<br>12、Java 中都有哪些引用类型？</p><p>(文末附面试答案)</p><p>6.Java 并发编程<br>1、在 java 中守护线程和本地线程区别？<br>2、线程与进程的区别？<br>3、什么是多线程中的上下文切换？<br>4、死锁与活锁的区别，死锁与饥饿的区别？<br>5、Java 中用到的线程调度算法是什么？<br>6、什么是线程组，为什么在 Java 中不推荐使用？<br>7、为什么使用 Executor 框架？<br>8、在 Java 中 Executor 和 Executors 的区别？<br>9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？<br>10、什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？<br>11、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？<br>12、什么是 Executors 框架？<br>13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？<br>14、什么是 Callable 和 Future?<br>15、什么是 FutureTask?使用 ExecutorService 启动任务。<br>16、什么是并发容器的实现？<br>17、多线程同步和互斥有几种实现方法，都是什么？<br>18、什么是竞争条件？你怎样发现和解决竞争？<br>19、你将如何使用 thread dump？你将如何分析 Thread dump？165<br>20、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/forezp/p/10136433.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/forezp/p/10136433.html&lt;/a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Disconf</title>
    <link href="http://gottaboy.cn/2020/01/11/Disconf/"/>
    <id>http://gottaboy.cn/2020/01/11/Disconf/</id>
    <published>2020-01-11T08:44:43.000Z</published>
    <updated>2020-01-11T08:44:53.435Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zlslch/category/1177655.html" target="_blank" rel="noopener">https://www.cnblogs.com/zlslch/category/1177655.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zlslch/category/1177655.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zlslch/category/117
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringSecurity</title>
    <link href="http://gottaboy.cn/2020/01/11/SpringSecurity/"/>
    <id>http://gottaboy.cn/2020/01/11/SpringSecurity/</id>
    <published>2020-01-11T05:31:01.000Z</published>
    <updated>2020-02-25T13:56:59.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OAuth2-0-技术"><a href="#OAuth2-0-技术" class="headerlink" title="OAuth2.0 技术"></a>OAuth2.0 技术</h2><ul><li>Spring Security OAuth2</li><li>keycloak</li><li>Nimbus OAuth</li><li>Apache Oltu</li><li>vertx-auth-oauth2</li></ul><h2 id="https-www-felord-cn-categories-spring-security"><a href="#https-www-felord-cn-categories-spring-security" class="headerlink" title="https://www.felord.cn/categories/spring-security/"></a><a href="https://www.felord.cn/categories/spring-security/" target="_blank" rel="noopener">https://www.felord.cn/categories/spring-security/</a></h2><p><a href="https://mp.weixin.qq.com/s/dywak06zI4d_LU0s9haVLg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dywak06zI4d_LU0s9haVLg</a><br><a href="https://mp.weixin.qq.com/s/2i7K9hq7LCytlzOjCl1bXA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2i7K9hq7LCytlzOjCl1bXA</a><br><a href="https://github.com/linlinjava/litemall" target="_blank" rel="noopener">https://github.com/linlinjava/litemall</a><br><a href="https://github.com/shenzhuan/zscat-me" target="_blank" rel="noopener">https://github.com/shenzhuan/zscat-me</a><br><a href="https://github.com/Mynameisfwk/vivo-shop" target="_blank" rel="noopener">https://github.com/Mynameisfwk/vivo-shop</a><br><a href="https://github.com/paascloud" target="_blank" rel="noopener">https://github.com/paascloud</a><br><a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">https://github.com/paascloud/paascloud-master</a><br><a href="https://gitee.com/owenwangwen/open-capacity-platform" target="_blank" rel="noopener">https://gitee.com/owenwangwen/open-capacity-platform</a><br><a href="https://gitee.com/zlt2000/microservices-platform" target="_blank" rel="noopener">https://gitee.com/zlt2000/microservices-platform</a><br><a href="https://github.com/Ewall1106/mall" target="_blank" rel="noopener">https://github.com/Ewall1106/mall</a><br><a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener">https://github.com/newbee-ltd/newbee-mall</a><br><a href="https://github.com/macrozheng/mall-admin-web" target="_blank" rel="noopener">https://github.com/macrozheng/mall-admin-web</a><br><a href="https://github.com/macrozheng/mall-swarm" target="_blank" rel="noopener">https://github.com/macrozheng/mall-swarm</a><br><a href="https://github.com/macrozheng/mall-learning" target="_blank" rel="noopener">https://github.com/macrozheng/mall-learning</a><br><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a><br><a href="https://github.com/YunaiV/onemall" target="_blank" rel="noopener">https://github.com/YunaiV/onemall</a><br><a href="https://niocoder.com/" target="_blank" rel="noopener">https://niocoder.com/</a><br><a href="https://niocoder.com/2017/02/17/Spring-atomikos/" target="_blank" rel="noopener">https://niocoder.com/2017/02/17/Spring-atomikos/</a><br><a href="https://niocoder.com/categories/#Security" target="_blank" rel="noopener">https://niocoder.com/categories/#Security</a><br>kubernetes<br><a href="https://github.com/gottaBoy/sealos" target="_blank" rel="noopener">https://github.com/gottaBoy/sealos</a><br><a href="https://sealyun.com/github/" target="_blank" rel="noopener">https://sealyun.com/github/</a><br>Apache<br> Kylin<br><a href="https://mp.weixin.qq.com/s/1tlytTG63xDyZyrlyM_zpA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1tlytTG63xDyZyrlyM_zpA</a><br><a href="https://mp.weixin.qq.com/s/EgZSEpc7SHl5kg6WLSQdPQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EgZSEpc7SHl5kg6WLSQdPQ</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java web领域经常提及的两大开源框架主要有两种选择Spring Security和Apache Shiro</p><h3 id="Spring-Security-和-Apache-Shiro"><a href="#Spring-Security-和-Apache-Shiro" class="headerlink" title="Spring Security 和 Apache Shiro"></a>Spring Security 和 Apache Shiro</h3><p>相对于Apache Shiro，Spring Security提供了更多的诸如LDAP、OAuth2.0、ACL、Kerberos、SAML、SSO、OpenID等诸多的安全认证、鉴权协议，可以按需引用。对认证/鉴权更加灵活，粒度更细。可以结合你自己的业务场景进行更加合理的定制化开发。在最新的Spring Security 5.x中更是提供了响应式应用（reactive application）提供了安全控制支持。从语言上来讲，支持使用kotlin、groovy进行开发。</p><p>Spring Security因为是利用了Spring IOC 和AOP的特性而无法脱离Spring独立存在。而Apache Shiro可以独立存在。但是Java Web领域Spring可以说是事实上的J2EE规范。使用Java技术栈很少能脱离Spring。也因为功能强大Spring Security被认为非常重，这是不对的。认真学习之后会发现其实也就是那么回事。两种框架都是非常优秀的安全框架，根据实际需要做技术选型。如果你要学习这两种安全框架就必须熟悉一下一些相对专业的概念。</p><h3 id="认证-鉴权"><a href="#认证-鉴权" class="headerlink" title="认证/鉴权"></a>认证/鉴权</h3><p>这两个概念英文分别为authentication/authorization 。是不是特别容易混淆。无论你选择Apache Shiro 或者 Spring Security 都需要熟悉这两个概念。其实简单来说认证（authentication）就是为了证明你是谁，比如你输入账号密码证明你是用户名为iching的用户。而授权（authorization）是通过认证后的用户所绑定的角色等凭证来证明你可以做什么 。打一个现实中的例子。十一长假大家远行都要乘坐交通工具，现在坐车实名制，也就是说你坐车需要两件东西：身份证和车票 。身份证是为了证明你确实是你，这就是 authentication；而车票是为了证明你张三确实买了票可以上车，这就是 authorization。这个例子从另一方面也证明了。如果只有认证没有授权，认证就没有意义。如果没有认证，授权就无法赋予真正的可信任的用户。两者是同时存在的。</p><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>对于servlet web应用来说，想要通用的安全控制最好莫过于使用Servlet Filter 。 过滤器责任链来组成一系列的过滤策略，不同的条件的请求进入不同的过滤器进行各自的处理逻辑。我们可以对这些Filter 进行排列组合以满足我们的实际业务需要。</p><h3 id="RBAC模型"><a href="#RBAC模型" class="headerlink" title="RBAC模型"></a>RBAC模型</h3><p>RBAC 是基于角色的访问控制（Role-Based Access Control ）的简称。在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。当你拥有某个角色以后，你自然继承了该角色的所有功能。对你的一些操作限制不需要直接与你进行沟通，只需要操作你拥有的角色。比如你在公司既是一个java程序员又是一个前端程序员，那么你不但要当sqlboy还要当页面仔。如果有一天经理说了前端负责测试工作，好了你又承担了测试任务。</p><h3 id="其他一些概念"><a href="#其他一些概念" class="headerlink" title="其他一些概念"></a>其他一些概念</h3><p>比如其它一些常见的安全策略、攻击方式。比如 反向代理、网关、壁垒机这种偏运维的知识；CSRF（Cross-site request forgery）跨站请求伪造 、XSS（跨站脚本攻击）也需要了解一些。对于一些上面提到的什么OAuth2.0之类的协议也最好研究一下。当然这些不是必须的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文粗略的简述了Spring Security 和Apache Shiro的一些异同。以及学习它们的一些前置条件。如果你不满足这些条件学习起来可能比较吃力。所以本文的作用是为你学习预热，做一些准备工作，避免新入门的同学陷入迷途。也希望大家多多支持，多多关注。</p><hr><h2 id="用户信息UserDetails相关入门"><a href="#用户信息UserDetails相关入门" class="headerlink" title="用户信息UserDetails相关入门"></a>用户信息UserDetails相关入门</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>前一篇介绍了 Spring Security 入门的基础准备。从今天开始我们来一步步窥探它是如何工作的。我们又该如何驾驭它。请多多关注公众号： iching 。本篇将通过 Spring Boot 2.x 来讲解 Spring Security 中的用户主体UserDetails。以及从中找点乐子。</p><h3 id="2-Spring-Boot-集成-Spring-Security"><a href="#2-Spring-Boot-集成-Spring-Security" class="headerlink" title="2. Spring Boot 集成 Spring Security"></a>2. Spring Boot 集成 Spring Security</h3><p>这个简直老生常谈了。不过为了照顾大多数还是说一下。集成 Spring Security 只需要引入其对应的 Starter 组件。Spring Security 不仅仅能保护Servlet Web 应用，也可以保护Reactive Web应用，本文我们讲前者。我们只需要在 Spring Security 项目引入以下依赖即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--  actuator 指标监控  非必须 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--  spring security starter 必须  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- spring mvc  servlet web  必须  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--   lombok 插件 非必须       --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- 测试   --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="3-UserDetailsServiceAutoConfiguration"><a href="#3-UserDetailsServiceAutoConfiguration" class="headerlink" title="3. UserDetailsServiceAutoConfiguration"></a>3. UserDetailsServiceAutoConfiguration</h3><p>启动项目，访问Actuator端点<a href="http://localhost:8080/actuator会跳转到一个登录页面http://localhost:8080/login如下：" target="_blank" rel="noopener">http://localhost:8080/actuator会跳转到一个登录页面http://localhost:8080/login如下：</a><br>#TODO</p><p>要求你输入用户名 Username （默认值为user）和密码 Password 。密码在springboot控制台会打印出类似 Using generated security password: e1f163be-ad18-4be1-977c-88a6bcee0d37 的字样，后面的长串就是密码，当然这不是生产可用的。如果你足够细心会从控制台打印日志发现该随机密码是由UserDetailsServiceAutoConfiguration 配置类生成的，我们就从它开始顺藤摸瓜来一探究竟。</p><h4 id="3-1-UserDetailsService"><a href="#3-1-UserDetailsService" class="headerlink" title="3.1 UserDetailsService"></a>3.1 UserDetailsService</h4><p>UserDetailsService接口。该接口只提供了一个方法：</p><p>  UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;<br>该方法很容易理解：通过用户名来加载用户 。这个方法主要用于从系统数据中查询并加载具体的用户到Spring Security中。</p><h4 id="3-2-UserDetails"><a href="#3-2-UserDetails" class="headerlink" title="3.2 UserDetails"></a>3.2 UserDetails</h4><p>从上面UserDetailsService 可以知道最终交给Spring Security的是UserDetails 。该接口是提供用户信息的核心接口。该接口实现仅仅存储用户的信息。后续会将该接口提供的用户信息封装到认证对象Authentication中去。UserDetails 默认提供了：</p><p>用户的权限集， 默认需要添加ROLE_ 前缀<br>用户的加密后的密码， 不加密会使用{noop}前缀<br>应用内唯一的用户名<br>账户是否过期<br>账户是否锁定<br>凭证是否过期<br>用户是否可用<br>如果以上的信息满足不了你使用，你可以自行实现扩展以存储更多的用户信息。比如用户的邮箱、手机号等等。通常我们使用其实现类：</p><p>org.springframework.security.core.userdetails.User<br>该类内置一个建造器UserBuilder 会很方便地帮助我们构建UserDetails 对象，后面我们会用到它。</p><h4 id="3-3-UserDetailsServiceAutoConfiguration"><a href="#3-3-UserDetailsServiceAutoConfiguration" class="headerlink" title="3.3 UserDetailsServiceAutoConfiguration"></a>3.3 UserDetailsServiceAutoConfiguration</h4><p>UserDetailsServiceAutoConfiguration 全限定名为:</p><p>org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration<br>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(AuthenticationManager.class)</span><br><span class="line">@ConditionalOnBean(ObjectPostProcessor.class)</span><br><span class="line">@ConditionalOnMissingBean(&#123; AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class &#125;)</span><br><span class="line">public class UserDetailsServiceAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private static final String NOOP_PASSWORD_PREFIX &#x3D; &quot;&#123;noop&#125;&quot;;</span><br><span class="line"></span><br><span class="line">    private static final Pattern PASSWORD_ALGORITHM_PATTERN &#x3D; Pattern.compile(&quot;^\\&#123;.+&#125;.*$&quot;);</span><br><span class="line"></span><br><span class="line">    private static final Log logger &#x3D; LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">            type &#x3D; &quot;org.springframework.security.oauth2.client.registration.ClientRegistrationRepository&quot;)</span><br><span class="line">    @Lazy</span><br><span class="line">    public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,</span><br><span class="line">            ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder) &#123;</span><br><span class="line">        SecurityProperties.User user &#x3D; properties.getUser();</span><br><span class="line">        List&lt;String&gt; roles &#x3D; user.getRoles();</span><br><span class="line">        return new InMemoryUserDetailsManager(</span><br><span class="line">                User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))</span><br><span class="line">                        .roles(StringUtils.toStringArray(roles)).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) &#123;</span><br><span class="line">        String password &#x3D; user.getPassword();</span><br><span class="line">        if (user.isPasswordGenerated()) &#123;</span><br><span class="line">            logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (encoder !&#x3D; null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) &#123;</span><br><span class="line">            return password;</span><br><span class="line">        &#125;</span><br><span class="line">        return NOOP_PASSWORD_PREFIX + password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来简单解读一下该类，从@Conditional系列注解我们知道该类在类路径下存在AuthenticationManager、在Spring 容器中存在Bean ObjectPostProcessor并且不存在Bean AuthenticationManager, AuthenticationProvider, UserDetailsService的情况下生效。千万不要纠结这些类干嘛用的! 该类只初始化了一个UserDetailsManager 类型的Bean。UserDetailsManager 类型负责对安全用户实体抽象UserDetails的增删查改操作。同时还继承了UserDetailsService接口。</p><p>明白了上面这些让我们把目光再回到UserDetailsServiceAutoConfiguration 上来。该类初始化了一个名为InMemoryUserDetailsManager 的内存用户管理器。该管理器通过配置注入了一个默认的UserDetails存在内存中，就是我们上面用的那个user ，每次启动user都是动态生成的。那么问题来了如果我们定义自己的UserDetailsManager Bean是不是就可以实现我们需要的用户管理逻辑呢？</p><h4 id="3-4-自定义UserDetailsManager"><a href="#3-4-自定义UserDetailsManager" class="headerlink" title="3.4 自定义UserDetailsManager"></a>3.4 自定义UserDetailsManager</h4><p>我们来自定义一个UserDetailsManager 来看看能不能达到自定义用户管理的效果。首先我们针对UserDetailsManager 的所有方法进行一个代理的实现，我们依然将用户存在内存中，区别就是这是我们自定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public class UserDetailsRepository &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 替换为 抽象DAO接口可进行用户持久化操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Map&lt;String, UserDetails&gt; users &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create user.</span><br><span class="line">     *</span><br><span class="line">     * @param user the user</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void createUser(UserDetails user) &#123;</span><br><span class="line">        users.putIfAbsent(user.getUsername(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Update user.</span><br><span class="line">     *</span><br><span class="line">     * @param user the user</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void updateUser(UserDetails user) &#123;</span><br><span class="line">        users.put(user.getUsername(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Delete user.</span><br><span class="line">     *</span><br><span class="line">     * @param username the username</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void deleteUser(String username) &#123;</span><br><span class="line">        users.remove(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Change password.</span><br><span class="line">     *</span><br><span class="line">     * @param oldPassword the old password</span><br><span class="line">     * @param newPassword the new password</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void changePassword(String oldPassword, String newPassword) &#123;</span><br><span class="line">        Authentication currentUser &#x3D; SecurityContextHolder.getContext()</span><br><span class="line">                .getAuthentication();</span><br><span class="line"></span><br><span class="line">        if (currentUser &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; This would indicate bad coding somewhere</span><br><span class="line">            throw new AccessDeniedException(</span><br><span class="line">                    &quot;Can&#39;t change password as no Authentication object found in context &quot;</span><br><span class="line">                            + &quot;for current user.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String username &#x3D; currentUser.getName();</span><br><span class="line"></span><br><span class="line">        UserDetails user &#x3D; users.get(username);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Current user doesn&#39;t exist in database.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 实现具体的更新密码逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * User exists boolean.</span><br><span class="line">     *</span><br><span class="line">     * @param username the username</span><br><span class="line">     * @return the boolean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean userExists(String username) &#123;</span><br><span class="line"></span><br><span class="line">        return users.containsKey(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Load user by username user details.</span><br><span class="line">     *</span><br><span class="line">     * @param username the username</span><br><span class="line">     * @return the user details</span><br><span class="line">     * @throws UsernameNotFoundException the username not found exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">        return users.get(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类负责具体对UserDetails 的增删改查操作。我们将其注入Spring 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public UserDetailsRepository userDetailsRepository() &#123;</span><br><span class="line">    UserDetailsRepository userDetailsRepository &#x3D; new UserDetailsRepository();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 为了让我们的登录能够运行 这里我们初始化一个用户iching 密码采用明文 当你在密码12345上使用了前缀&#123;noop&#125; 意味着你的密码不使用加密，authorities 一定不能为空 这代表用户的角色权限集合</span><br><span class="line">    UserDetails iching &#x3D; User.withUsername(&quot;iching&quot;).password(&quot;&#123;noop&#125;123456&quot;).authorities(AuthorityUtils.NO_AUTHORITIES).build();</span><br><span class="line">    userDetailsRepository.createUser(iching);</span><br><span class="line">    return userDetailsRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便测试 我们也内置一个名称为iching 密码为12345的UserDetails用户，密码采用明文 当你在密码123456上使用了前缀{noop} 意味着你的密码不使用加密，这里我们并没有指定密码加密方式你可以使用PasswordEncoder 来指定一种加密方式。通常推荐使用Bcrypt作为加密方式。默认Spring Security使用的也是此方式。authorities 一定不能为null 这代表用户的角色权限集合。接下来我们实现一个UserDetailsManager 并注入Spring 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public UserDetailsManager userDetailsManager(UserDetailsRepository userDetailsRepository) &#123;</span><br><span class="line">    return new UserDetailsManager() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void createUser(UserDetails user) &#123;</span><br><span class="line">            userDetailsRepository.createUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void updateUser(UserDetails user) &#123;</span><br><span class="line">            userDetailsRepository.updateUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void deleteUser(String username) &#123;</span><br><span class="line">            userDetailsRepository.deleteUser(username);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void changePassword(String oldPassword, String newPassword) &#123;</span><br><span class="line">            userDetailsRepository.changePassword(oldPassword, newPassword);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean userExists(String username) &#123;</span><br><span class="line">            return userDetailsRepository.userExists(username);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">            return userDetailsRepository.loadUserByUsername(username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实际执行委托给了UserDetailsRepository 来做。我们重复 章节3. 的动作进入登陆页面分别输入iching和123456 成功进入。</p><h4 id="3-5-数据库管理用户"><a href="#3-5-数据库管理用户" class="headerlink" title="3.5 数据库管理用户"></a>3.5 数据库管理用户</h4><p>经过以上的配置，相信聪明的你已经知道如何使用数据库来管理用户了 。只需要将 UserDetailsRepository 中的 users 属性替代为抽象的Dao接口就行了，无论你使用Jpa还是Mybatis来实现。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>今天我们对Spring Security 中的用户信息 UserDetails 相关进行的一些解读。并自定义了用户信息处理服务。相信你已经对在Spring Security中如何加载用户信息，如何扩展用户信息有所掌握了。后面我们会由浅入深慢慢解读Spring Security。</p><hr><h2 id="Spring-Boot-中的-Spring-Security-自动配置初探"><a href="#Spring-Boot-中的-Spring-Security-自动配置初探" class="headerlink" title="Spring Boot 中的 Spring Security 自动配置初探"></a>Spring Boot 中的 Spring Security 自动配置初探</h2><ol><li><p>前言<br>我们在前几篇对 Spring Security 的用户信息管理机制，密码机制进行了探讨。我们发现 Spring Security Starter相关的 Servlet 自动配置都在spring-boot-autoconfigure-2.1.9.RELEASE（当前 Spring Boot 版本为2.1.9.RELEASE） 模块的路径org.springframework.boot.autoconfigure.security.servlet 之下。其实官方提供的Starter组件的自动配置你都能在spring-boot-autoconfigure-2.1.9.RELEASE下找到。今天我们进一步来解密 Spring Security 在 Spring Boot 的配置和使用。</p></li><li><p>Spring Boot 下 Spring Security 的自动配置<br>我们可以通过 org.springframework.boot.autoconfigure.security.servlet 路径下找到 Spring Security 关于Servlet的自动配置类。我们来大致了解一下。</p></li></ol><p>2.1 SecurityAutoConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure.security.servlet;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.SecurityDataConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.SecurityProperties;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.context.ApplicationEventPublisher;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.Import;</span><br><span class="line">import org.springframework.security.authentication.AuthenticationEventPublisher;</span><br><span class="line">import org.springframework.security.authentication.DefaultAuthenticationEventPublisher;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* &#123;@link EnableAutoConfiguration Auto-configuration&#125; for Spring Security.</span><br><span class="line">*</span><br><span class="line">* @author Dave Syer</span><br><span class="line">* @author Andy Wilkinson</span><br><span class="line">* @author Madhura Bhave</span><br><span class="line">* @since 1.0.0</span><br><span class="line">*&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(DefaultAuthenticationEventPublisher.class)</span><br><span class="line">@EnableConfigurationProperties(SecurityProperties.class)</span><br><span class="line">@Import(&#123; SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class,</span><br><span class="line">        SecurityDataConfiguration.class &#125;)</span><br><span class="line">public class SecurityAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(AuthenticationEventPublisher.class)</span><br><span class="line">    public DefaultAuthenticationEventPublisher authenticationEventPublisher(ApplicationEventPublisher publisher) &#123;</span><br><span class="line">        return new DefaultAuthenticationEventPublisher(publisher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityAutoConfiguration 顾名思义安全配置类。该类引入（@import）了 SpringBootWebSecurityConfiguration、WebSecurityEnablerConfiguration 和 SecurityDataConfiguration 三个配置类。 让这三个模块的类生效。是一个复合配置，是 Spring Security 自动配置最重要的一个类之一。 Spring Boot 自动配置经常使用这种方式以达到灵活配置的目的，这也是我们研究 Spring Security 自动配置的一个重要入口 同时 SecurityAutoConfiguration 还将 DefaultAuthenticationEventPublisher 作为默认的 AuthenticationEventPublisher 注入 Spring IoC 容器。如果你熟悉 Spring 中的事件机制你就会知道该类是一个 Spring 事件发布器。该类内置了一个HashMap&lt;String, Constructor&lt;? extends AbstractAuthenticationEvent&gt;&gt;维护了认证异常处理和对应异常事件处理逻辑的映射关系，比如账户过期异常 AccountExpiredException 对应认证过期事件AuthenticationFailureExpiredEvent ，也就是说发生不同认证的异常使用不同处理策略。</p><p>2.2 SpringBootWebSecurityConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnMissingBean(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)</span><br><span class="line">public class SpringBootWebSecurityConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @Order(SecurityProperties.BASIC_AUTH_ORDER)</span><br><span class="line">    static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是Spring Security 对 Spring Boot Servlet Web 应用的默认配置。核心在于WebSecurityConfigurerAdapter 适配器。从 @ConditionalOnMissingBean(WebSecurityConfigurerAdapter.class) 我们就能看出 WebSecurityConfigurerAdapter 是安全配置的核心。 默认情况下 DefaultConfigurerAdapter 将以SecurityProperties.BASIC_AUTH_ORDER（-5） 的顺序注入 Spring IoC 容器，这是个空实现。如果我们需要个性化可以通过继承 WebSecurityConfigurerAdapter 来实现。我们会在以后的博文重点介绍该类。</p><p>2.3 WebSecurityEnablerConfiguration</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnBean(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnMissingBean(name &#x3D; BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityEnablerConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置类会在SpringBootWebSecurityConfiguration 注入 Spring IoC 容器后启用 @EnableWebSecurity 注解。也就是说 WebSecurityEnablerConfiguration 目的仅仅就是在某些条件下激活 @EnableWebSecurity 注解。那么这个注解都有什么呢？</p><ol start="3"><li>@EnableWebSecurity 注解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Retention(value &#x3D; java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value &#x3D; &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123; WebSecurityConfiguration.class,</span><br><span class="line">        SpringWebMvcImportSelector.class,</span><br><span class="line">        OAuth2ImportSelector.class &#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Controls debugging support for Spring Security. Default is false.</span><br><span class="line">    * @return if true, enables debug support with Spring Security</span><br><span class="line">    *&#x2F;</span><br><span class="line">    boolean debug() default false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>@Enable* 这类注解都是带配置导入的注解。通过导入一些配置来启用一些特定功能。 @EnableWebSecurity 导入了 WebSecurityConfiguration 、SpringWebMvcImportSelector 、OAuth2ImportSelector 以及启用了 @EnableGlobalAuthentication注解。</p><p>3.1 WebSecurityConfiguration<br>该配置类WebSecurityConfiguration使用一个WebSecurity对象基于用户指定的或者默认的安全配置，你可以通过继承 WebSecurityConfigurerAdapter 或者实现 WebSecurityConfigurer 来定制 WebSecurity 创建一个FilterChainProxy Bean来对用户请求进行安全过滤。这个FilterChainProxy的名称就是 WebSecurityEnablerConfiguration上的 BeanIds.SPRING_SECURITY_FILTER_CHAIN 也就是 springSecurityFilterChain,它是一个Filter，最终会被作为Servlet过滤器链中的一个Filter应用到Servlet容器中。安全处理的策略主要是过滤器的调用顺序。WebSecurityConfiguration 最终会通过 @EnableWebSecurity 应用到系统。</p><p>源码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.security.config.annotation.web.configuration;</span><br><span class="line"></span><br><span class="line">  import java.util.Collections;</span><br><span class="line">  import java.util.List;</span><br><span class="line">  import java.util.Map;</span><br><span class="line"></span><br><span class="line">  import javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line">  import org.springframework.beans.factory.BeanClassLoaderAware;</span><br><span class="line">  import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">  import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">  import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line">  import org.springframework.context.annotation.Bean;</span><br><span class="line">  import org.springframework.context.annotation.Configuration;</span><br><span class="line">  import org.springframework.context.annotation.DependsOn;</span><br><span class="line">  import org.springframework.context.annotation.ImportAware;</span><br><span class="line">  import org.springframework.core.OrderComparator;</span><br><span class="line">  import org.springframework.core.Ordered;</span><br><span class="line">  import org.springframework.core.annotation.AnnotationAttributes;</span><br><span class="line">  import org.springframework.core.annotation.AnnotationUtils;</span><br><span class="line">  import org.springframework.core.annotation.Order;</span><br><span class="line">  import org.springframework.core.type.AnnotationMetadata;</span><br><span class="line">  import org.springframework.security.access.expression.SecurityExpressionHandler;</span><br><span class="line">  import org.springframework.security.config.annotation.ObjectPostProcessor;</span><br><span class="line">  import org.springframework.security.config.annotation.SecurityConfigurer;</span><br><span class="line">  import org.springframework.security.config.annotation.web.WebSecurityConfigurer;</span><br><span class="line">  import org.springframework.security.config.annotation.web.builders.WebSecurity;</span><br><span class="line">  import org.springframework.security.context.DelegatingApplicationListener;</span><br><span class="line">  import org.springframework.security.web.FilterChainProxy;</span><br><span class="line">  import org.springframework.security.web.FilterInvocation;</span><br><span class="line">  import org.springframework.security.web.access.WebInvocationPrivilegeEvaluator;</span><br><span class="line">  import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Spring Web Security 的配置类 : </span><br><span class="line">   *  1. 使用一个 WebSecurity 对象基于安全配置创建一个 FilterChainProxy 对象来对用户请求进行安全过滤。 </span><br><span class="line">   *  2. 也会暴露诸如 安全SpEL表达式处理器 SecurityExpressionHandler 等一些类。</span><br><span class="line">   *   </span><br><span class="line">   * @see EnableWebSecurity</span><br><span class="line">   * @see WebSecurity</span><br><span class="line">   *</span><br><span class="line">   * @author Rob Winch</span><br><span class="line">   * @author Keesun Baik</span><br><span class="line">   * @since 3.2</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Configuration</span><br><span class="line">  public class WebSecurityConfiguration implements ImportAware, BeanClassLoaderAware &#123;</span><br><span class="line">      private WebSecurity webSecurity;</span><br><span class="line">   &#x2F;&#x2F; 是否启用了调试模式，来自注解 @EnableWebSecurity 的属性 debug，缺省值 false</span><br><span class="line">      private Boolean debugEnabled;</span><br><span class="line"></span><br><span class="line">      private List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers;</span><br><span class="line"></span><br><span class="line">      private ClassLoader beanClassLoader;</span><br><span class="line"></span><br><span class="line">      @Autowired(required &#x3D; false)</span><br><span class="line">      private ObjectPostProcessor&lt;Object&gt; objectObjectPostProcessor;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 代理监听器 应该时监听 DefaultAuthenticationEventPublisher 的一些处理策略</span><br><span class="line">     *&#x2F;   </span><br><span class="line">      @Bean</span><br><span class="line">      public static DelegatingApplicationListener delegatingApplicationListener() &#123;</span><br><span class="line">          return new DelegatingApplicationListener();</span><br><span class="line">      &#125;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      *</span><br><span class="line">      * 安全SpEL表达式处理器 SecurityExpressionHandler 缺省为一个 DefaultWebSecurityExpressionHandler</span><br><span class="line">      *&#x2F;   </span><br><span class="line">      @Bean</span><br><span class="line">      @DependsOn(AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line">      public SecurityExpressionHandler&lt;FilterInvocation&gt; webSecurityExpressionHandler() &#123;</span><br><span class="line">          return webSecurity.getExpressionHandler();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">       *  Spring Security 核心过滤器  Spring Security Filter Chain  , Bean ID 为 springSecurityFilterChain</span><br><span class="line">       * @return the &#123;@link Filter&#125; that represents the security filter chain</span><br><span class="line">       * @throws Exception</span><br><span class="line">       *&#x2F;</span><br><span class="line">      @Bean(name &#x3D; AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line">      public Filter springSecurityFilterChain() throws Exception &#123;</span><br><span class="line">          boolean hasConfigurers &#x3D; webSecurityConfigurers !&#x3D; null</span><br><span class="line">                  &amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class="line">          if (!hasConfigurers) &#123;</span><br><span class="line">              WebSecurityConfigurerAdapter adapter &#x3D; objectObjectPostProcessor</span><br><span class="line">                      .postProcess(new WebSecurityConfigurerAdapter() &#123;</span><br><span class="line">                      &#125;);</span><br><span class="line">              webSecurity.apply(adapter);</span><br><span class="line">          &#125;</span><br><span class="line">          return webSecurity.build();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 用于模板 如JSP Freemarker 的一些页面标签按钮控制支持</span><br><span class="line">       * Creates the &#123;@link WebInvocationPrivilegeEvaluator&#125; that is necessary for the JSP</span><br><span class="line">       * tag support.</span><br><span class="line">       * @return the &#123;@link WebInvocationPrivilegeEvaluator&#125;</span><br><span class="line">       * @throws Exception</span><br><span class="line">       *&#x2F;</span><br><span class="line">      @Bean</span><br><span class="line">      @DependsOn(AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line">      public WebInvocationPrivilegeEvaluator privilegeEvaluator() throws Exception &#123;</span><br><span class="line">          return webSecurity.getPrivilegeEvaluator();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 用于创建web configuration的SecurityConfigurer实例，</span><br><span class="line">     * 注意该参数通过@Value(...)方式注入，对应的bean autowiredWebSecurityConfigurersIgnoreParents</span><br><span class="line">     * 也在该类中定义</span><br><span class="line">     *</span><br><span class="line">       * @param objectPostProcessor the &#123;@link ObjectPostProcessor&#125; used to create a</span><br><span class="line">       * &#123;@link WebSecurity&#125; instance</span><br><span class="line">       * @param webSecurityConfigurers the</span><br><span class="line">       * &#123;@code &lt;SecurityConfigurer&lt;FilterChainProxy, WebSecurityBuilder&gt;&#125; instances used to</span><br><span class="line">       * create the web configuration</span><br><span class="line">       * @throws Exception</span><br><span class="line">       *&#x2F;</span><br><span class="line">      @Autowired(required &#x3D; false)</span><br><span class="line">      public void setFilterChainProxySecurityConfigurer(</span><br><span class="line">              ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span><br><span class="line">              @Value(&quot;#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;&quot;) List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span><br><span class="line">              throws Exception &#123;</span><br><span class="line">          webSecurity &#x3D; objectPostProcessor</span><br><span class="line">                  .postProcess(new WebSecurity(objectPostProcessor));</span><br><span class="line">          if (debugEnabled !&#x3D; null) &#123;</span><br><span class="line">              webSecurity.debug(debugEnabled);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Collections.sort(webSecurityConfigurers, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line"></span><br><span class="line">          Integer previousOrder &#x3D; null;</span><br><span class="line">          Object previousConfig &#x3D; null;</span><br><span class="line">          for (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class="line">              Integer order &#x3D; AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class="line">              if (previousOrder !&#x3D; null &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class="line">                  throw new IllegalStateException(</span><br><span class="line">                          &quot;@Order on WebSecurityConfigurers must be unique. Order of &quot;</span><br><span class="line">                                  + order + &quot; was already used on &quot; + previousConfig + &quot;, so it cannot be used on &quot;</span><br><span class="line">                                  + config + &quot; too.&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              previousOrder &#x3D; order;</span><br><span class="line">              previousConfig &#x3D; config;</span><br><span class="line">          &#125;</span><br><span class="line">          for (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class="line">              webSecurity.apply(webSecurityConfigurer);</span><br><span class="line">          &#125;</span><br><span class="line">          this.webSecurityConfigurers &#x3D; webSecurityConfigurers;</span><br><span class="line">      &#125;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * 从当前bean容器中获取所有的WebSecurityConfigurer bean。</span><br><span class="line">      * 这些WebSecurityConfigurer通常是由开发人员实现的配置类，并且继承自WebSecurityConfigurerAdapter</span><br><span class="line">      *  </span><br><span class="line">      *&#x2F;   </span><br><span class="line">      @Bean</span><br><span class="line">      public static AutowiredWebSecurityConfigurersIgnoreParents autowiredWebSecurityConfigurersIgnoreParents(</span><br><span class="line">              ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">          return new AutowiredWebSecurityConfigurersIgnoreParents(beanFactory);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;**</span><br><span class="line">       * A custom verision of the Spring provided AnnotationAwareOrderComparator that uses</span><br><span class="line">       * &#123;@link AnnotationUtils#findAnnotation(Class, Class)&#125; to look on super class</span><br><span class="line">       * instances for the &#123;@link Order&#125; annotation.</span><br><span class="line">       *</span><br><span class="line">       * @author Rob Winch</span><br><span class="line">       * @since 3.2</span><br><span class="line">       *&#x2F;</span><br><span class="line">      private static class AnnotationAwareOrderComparator extends OrderComparator &#123;</span><br><span class="line">          private static final AnnotationAwareOrderComparator INSTANCE &#x3D; new AnnotationAwareOrderComparator();</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          protected int getOrder(Object obj) &#123;</span><br><span class="line">              return lookupOrder(obj);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          private static int lookupOrder(Object obj) &#123;</span><br><span class="line">              if (obj instanceof Ordered) &#123;</span><br><span class="line">                  return ((Ordered) obj).getOrder();</span><br><span class="line">              &#125;</span><br><span class="line">              if (obj !&#x3D; null) &#123;</span><br><span class="line">                  Class&lt;?&gt; clazz &#x3D; (obj instanceof Class ? (Class&lt;?&gt;) obj : obj.getClass());</span><br><span class="line">                  Order order &#x3D; AnnotationUtils.findAnnotation(clazz, Order.class);</span><br><span class="line">                  if (order !&#x3D; null) &#123;</span><br><span class="line">                      return order.value();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">       * 要是为了获取注解 @EnableWebSecurity 的属性 debugEnabled</span><br><span class="line">       *</span><br><span class="line">       * @see org.springframework.context.annotation.ImportAware#setImportMetadata(org.</span><br><span class="line">       * springframework.core.type.AnnotationMetadata)</span><br><span class="line">       *&#x2F;</span><br><span class="line">      public void setImportMetadata(AnnotationMetadata importMetadata) &#123;</span><br><span class="line">          Map&lt;String, Object&gt; enableWebSecurityAttrMap &#x3D; importMetadata</span><br><span class="line">                  .getAnnotationAttributes(EnableWebSecurity.class.getName());</span><br><span class="line">          AnnotationAttributes enableWebSecurityAttrs &#x3D; AnnotationAttributes</span><br><span class="line">                  .fromMap(enableWebSecurityAttrMap);</span><br><span class="line">          debugEnabled &#x3D; enableWebSecurityAttrs.getBoolean(&quot;debug&quot;);</span><br><span class="line">          if (webSecurity !&#x3D; null) &#123;</span><br><span class="line">              webSecurity.debug(debugEnabled);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">       * (non-Javadoc)</span><br><span class="line">       *</span><br><span class="line">       * @see</span><br><span class="line">       * org.springframework.beans.factory.BeanClassLoaderAware#setBeanClassLoader(java.</span><br><span class="line">       * lang.ClassLoader)</span><br><span class="line">       *&#x2F;</span><br><span class="line">      public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">          this.beanClassLoader &#x3D; classLoader;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3.2 SpringWebMvcImportSelector<br>该类是为了对 Spring Mvc 进行支持的。一旦发现应用使用 Spring Mvc 的核心前置控制器 DispatcherServlet 就会引入 WebMvcSecurityConfiguration 。主要是为了适配 Spring Mvc 。</p><p>3.3 OAuth2ImportSelector<br>该类是为了对 OAuth2.0 开放授权协议进行支持。ClientRegistration 如果被引用，具体点也就是 spring-security-oauth2 模块被启用（引入依赖jar）时。会启用 OAuth2 客户端配置 OAuth2ClientConfiguration 。</p><p>3.4 @EnableGlobalAuthentication<br>这个类主要引入了 AuthenticationConfiguration 目的主要为了构造 认证管理器 AuthenticationManager 。AuthenticationManager 十分重要后面我们会进行专门的分析。</p><ol start="4"><li>SecurityFilterAutoConfiguration<br>我们在 org.springframework.boot.autoconfigure.security.servlet 路径下还发现了一个配置类 SecurityFilterAutoConfiguration 。该类用于向Servlet容器注册一个名称为securityFilterChainRegistration的bean, 实现类是DelegatingFilterProxyRegistrationBean。该 bean 的目的是注册另外一个 Servlet Filter Bean 到 Servlet 容器,实现类为 DelegatingFilterProxy 。DelegatingFilterProxy 其实是一个代理过滤器，它被 Servlet 容器用于处理请求时，会将任务委托给指定给自己另外一个Filter bean。对于 SecurityFilterAutoConfiguration,来讲，这个被代理的Filter bean的名字为 springSecurityFilterChain , 也就是我们上面提到过的 Spring Security Web提供的用于请求安全处理的Filter bean，其实现类是 FilterChainProxy。</li></ol><p>相关的源码分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure.security.servlet;</span><br><span class="line"></span><br><span class="line">import java.util.EnumSet;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">import javax.servlet.DispatcherType;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.AutoConfigureAfter;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;</span><br><span class="line">import org.springframework.boot.autoconfigure.security.SecurityProperties;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.boot.web.servlet.DelegatingFilterProxyRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;</span><br><span class="line">import org.springframework.security.config.http.SessionCreationPolicy;</span><br><span class="line">import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">&#x2F;&#x2F; 仅在 Servlet 环境下生效</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)</span><br><span class="line">&#x2F;&#x2F; 确保安全属性配置信息被加载并以bean形式被注册到容器</span><br><span class="line">@EnableConfigurationProperties(SecurityProperties.class)</span><br><span class="line">&#x2F;&#x2F; 仅在特定类存在于 classpath 上时才生效</span><br><span class="line">@ConditionalOnClass(&#123; AbstractSecurityWebApplicationInitializer.class,</span><br><span class="line">        SessionCreationPolicy.class &#125;)</span><br><span class="line">&#x2F;&#x2F; 指定该配置类在  SecurityAutoConfiguration 配置类应用之后应用       </span><br><span class="line">@AutoConfigureAfter(SecurityAutoConfiguration.class)</span><br><span class="line">public class SecurityFilterAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 要注册到 Servlet 容器的 DelegatingFilterProxy Filter的 </span><br><span class="line">    &#x2F;&#x2F; 目标代理Filter bean的名称 ：springSecurityFilterChain</span><br><span class="line">    private static final String DEFAULT_FILTER_NAME &#x3D; </span><br><span class="line">            AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 定义一个 bean securityFilterChainRegistration, </span><br><span class="line">    &#x2F;&#x2F; 该 bean 的目的是注册另外一个 bean 到 Servlet 容器 : 实现类为 DelegatingFilterProxy 的一个 Servlet Filter</span><br><span class="line">    &#x2F;&#x2F; 该 DelegatingFilterProxy Filter 其实是一个代理过滤器，它被 Servlet 容器用于匹配特定URL模式的请求，</span><br><span class="line">    &#x2F;&#x2F; 而它会将任务委托给指定给自己的名字为 springSecurityFilterChain 的 Filter, 也就是 Spring Security Web</span><br><span class="line">    &#x2F;&#x2F; 提供的用于请求安全处理的一个 Filter bean，其实现类是 FilterChainProxy</span><br><span class="line">    &#x2F;&#x2F; (可以将 1 个 FilterChainProxy 理解为 1 HttpFirewall + n SecurityFilterChain)</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnBean(name &#x3D; DEFAULT_FILTER_NAME)</span><br><span class="line">    public DelegatingFilterProxyRegistrationBean securityFilterChainRegistration(</span><br><span class="line">            SecurityProperties securityProperties) &#123;</span><br><span class="line">        DelegatingFilterProxyRegistrationBean registration &#x3D; new DelegatingFilterProxyRegistrationBean(</span><br><span class="line">                DEFAULT_FILTER_NAME);</span><br><span class="line">        registration.setOrder(securityProperties.getFilter().getOrder());</span><br><span class="line">        registration.setDispatcherTypes(getDispatcherTypes(securityProperties));</span><br><span class="line">        return registration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private EnumSet&lt;DispatcherType&gt; getDispatcherTypes(</span><br><span class="line">            SecurityProperties securityProperties) &#123;</span><br><span class="line">        if (securityProperties.getFilter().getDispatcherTypes() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return securityProperties.getFilter().getDispatcherTypes().stream()</span><br><span class="line">                .map((type) -&gt; DispatcherType.valueOf(type.name())).collect(Collectors</span><br><span class="line">                        .collectingAndThen(Collectors.toSet(), EnumSet::copyOf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="路径Uri中的-Ant-风格"><a href="#路径Uri中的-Ant-风格" class="headerlink" title="路径Uri中的 Ant 风格"></a>路径Uri中的 Ant 风格</h2><ol><li><p>前言<br>我们经常在读到一些文章会遇到uri 支持 Ant 风格 ，而且这个东西在 Spring MVC 和 Spring Security 中经常被提及。这到底是什么呢？今天我们来学习了解一下。这对我们学习 Spring MVC 和 Spring Security 十分必要。</p></li><li><p>Ant 风格<br>说白了 Ant 风格就是一种路径匹配表达式。主要用来对uri的匹配。其实跟正则表达式作用是一样的，只不过正则表达式适用面更加宽泛，Ant仅仅用于路径匹配。</p></li><li><p>Ant 通配符<br>Ant 中的通配符有三种：</p></li></ol><p>? 匹配任何单字符</p><ul><li>匹配0或者任意数量的 字符</li></ul><p>** 匹配0或者更多的 目录</p><p>这里注意了单个* 是在一个目录内进行匹配。 而** 是可以匹配多个目录，一定不要迷糊。</p><p>3.1 Ant 通配符示例<br>通配符    示例    说明<br>?    /ant/p?ttern    匹配项目根路径下 /ant/pattern 和 /ant/pXttern,但是不包括/ant/pttern</p><ul><li>/ant/*.html    匹配项目根路径下所有在ant路径下的.html文件</li><li>/ant/*/path    /ant/path、/ant/a/path、/ant/bxx/path 都匹配，不匹配 /ant/axx/bxx/path</li><li><ul><li>/ant/**/path    /ant/path、/ant/a/path、/ant/bxx/path 、/ant/axx/bxx/path都匹配</li></ul></li></ul><p>3.2 最长匹配原则<br>从 3.1 可以看出 * 和 <em>* 是有冲突的情况存在的。为了解决这种冲突就规定了最长匹配原则(has more characters)。 一旦一个uri 同时符合两个Ant匹配那么走匹配规则字符最多的。为什么走最长？因为字符越长信息越多就越具体。比如 /ant/a/path 同时满足 /**/path 和 /ant/</em>/path 那么走/ant/*/path</p><ol start="4"><li>Spring MVC 和 Spring Security 中的 Ant 风格<br>接下来我们来看看 Spring MVC 和 Spring Security 下的 Ant风格。</li></ol><p>4.1 Spring MVC 中的 Ant 风格<br>这里也提一下在 Spring MVC 中 我们在控制器中写如下接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* ant style test.</span><br><span class="line">*</span><br><span class="line">* @return the string</span><br><span class="line">*&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;?ant&quot;)</span><br><span class="line">public String ant() &#123;</span><br><span class="line"></span><br><span class="line">    return &quot;ant&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你使用任意合法uri字符替代? 发现都可以匹配，比如/bant 。 还有Spring MVC 的一些 过滤器注册、格式化器注册都用到了 Ant 风格。</p><p>4.2 Spring Security 中的 Ant 风格<br>在 Spring Security 中 WebSecurityConfigurerAdapter 中的你可以通过如下配置进行路由权限访问控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void configureGlobal(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception &#123;</span><br><span class="line">        authenticationManagerBuilder.inMemoryAuthentication().withUser(&quot;admin&quot;).password(&quot;admin&quot;).roles(&quot;USER&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                &#x2F;&#x2F;放行静态资源 首页</span><br><span class="line">                .antMatchers(&quot;&#x2F;index.html&quot;,&quot;&#x2F;static&#x2F;**&quot;).permitAll()</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 Spring Security 的配置中在 antMatchers 方法中通过 Ant 通配符来控制了资源的访问权限</p><hr><h2 id="自定义配置类入口WebSecurityConfigurerAdapter"><a href="#自定义配置类入口WebSecurityConfigurerAdapter" class="headerlink" title="自定义配置类入口WebSecurityConfigurerAdapter"></a>自定义配置类入口WebSecurityConfigurerAdapter</h2><ol><li><p>前言<br>今天我们要进一步的的学习如何自定义配置 Spring Security 我们已经多次提到了 WebSecurityConfigurerAdapter ，而且我们知道 Spring Boot 中的自动配置实际上是通过自动配置包下的 SecurityAutoConfiguration 总配置类上导入的 Spring Boot Web 安全配置类 SpringBootWebSecurityConfiguration 来配置的。所以我们就拿它开刀。如果还是一头雾水建议通过 <a href="https://felord.cn" target="_blank" rel="noopener">https://felord.cn</a> 查看 Spring Security 实战 。</p></li><li><p>自定义 Spring Boot Web 安全配置类<br>我们使用我们最擅长的 Ctrl + C 、Ctrl + V 抄源码中的 SpringBootWebSecurityConfiguration ，命名为我们自定义的 CustomSpringBootWebSecurityConfiguration :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line">public class CustomSpringBootWebSecurityConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @Order(SecurityProperties.BASIC_AUTH_ORDER)</span><br><span class="line">    static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">            super.configure(auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">            super.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">            super.configure(http);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信已经有人注意到了上面 DefaultConfigurerAdapter 中我覆写（@Override）了三个方法，我们一般会通过自定义配置这三个方法来自定义我们的安全访问策略。</p></li></ol><p>2.1 认证管理器配置方法<br>void configure(AuthenticationManagerBuilder auth) 用来配置认证管理器AuthenticationManager。说白了就是所有 UserDetails 相关的它都管，包含 PasswordEncoder 密码机。如果你不清楚可以通过 Spring Security 中的 UserDetail 进行了解。本文对 AuthenticationManager 不做具体分析讲解，后面会有专门的文章来讲这个东西 。 可通过 Spring Security 实战系列 进行学习。</p><p>2.2 核心过滤器配置方法<br>void configure(WebSecurity web) 用来配置 WebSecurity 。而 WebSecurity 是基于 Servlet Filter 用来配置 springSecurityFilterChain 。而 springSecurityFilterChain 又被委托给了 Spring Security 核心过滤器 Bean DelegatingFilterProxy 。 相关逻辑你可以在 WebSecurityConfiguration 中找到。我们一般不会过多来自定义 WebSecurity , 使用较多的使其ignoring() 方法用来忽略 Spring Security 对静态资源的控制。</p><p>2.3 安全过滤器链配置方法<br>void configure(HttpSecurity http) 这个是我们使用最多的，用来配置 HttpSecurity 。 HttpSecurity 用于构建一个安全过滤器链 SecurityFilterChain 。SecurityFilterChain 最终被注入核心过滤器 。 HttpSecurity 有许多我们需要的配置。我们可以通过它来进行自定义安全访问策略。所以我们单独开一章来讲解这个东西。</p><ol start="3"><li>HttpSecurity 配置<br>HttpSecurity 是后面几篇文章的重点，我们将实际操作它来实现一些实用功能。所以本文要着重介绍它。</li></ol><p>3.1 默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    logger.debug(&quot;Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).&quot;);</span><br><span class="line"></span><br><span class="line">    http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">        .formLogin().and()</span><br><span class="line">        .httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 Spring Security 在 Spring Boot 中的默认配置。通过以上的配置，你的应用具备了一下的功能：</p><p>所有的请求访问都需要被授权。<br>使用 form 表单进行登陆(默认路径为/login)，也就是前几篇我们见到的登录页。<br>防止 CSRF 攻击、 XSS 攻击。<br>启用 HTTP Basic 认证<br>3.2 常用方法解读<br>HttpSecurity 使用了builder 的构建方式来灵活制定访问策略。最早基于 XML 标签对 HttpSecurity 进行配置。现在大部分使用 javaConfig方式。常用的方法解读如下：<br>方法    说明<br>openidLogin()    用于基于 OpenId 的验证<br>headers()    将安全标头添加到响应,比如说简单的 XSS 保护<br>cors()    配置跨域资源共享（ CORS ）<br>sessionManagement()    允许配置会话管理<br>portMapper()    允许配置一个PortMapper(HttpSecurity#(getSharedObject(class)))，其他提供SecurityConfigurer的对象使用 PortMapper 从 HTTP 重定向到 HTTPS 或者从 HTTPS 重定向到 HTTP。默认情况下，Spring Security使用一个PortMapperImpl映射 HTTP 端口8080到 HTTPS 端口8443，HTTP 端口80到 HTTPS 端口443<br>jee()    配置基于容器的预认证。 在这种情况下，认证由Servlet容器管理<br>x509()    配置基于x509的认证<br>rememberMe    允许配置“记住我”的验证<br>authorizeRequests()    允许基于使用HttpServletRequest限制访问<br>requestCache()    允许配置请求缓存<br>exceptionHandling()    允许配置错误处理<br>securityContext()    在HttpServletRequests之间的SecurityContextHolder上设置SecurityContext的管理。 当使用WebSecurityConfigurerAdapter时，这将自动应用<br>servletApi()    将HttpServletRequest方法与在其上找到的值集成到SecurityContext中。 当使用WebSecurityConfigurerAdapter时，这将自动应用<br>csrf()    添加 CSRF 支持，使用WebSecurityConfigurerAdapter时，默认启用<br>logout()    添加退出登录支持。当使用WebSecurityConfigurerAdapter时，这将自动应用。默认情况是，访问URL”/ logout”，使HTTP Session无效来清除用户，清除已配置的任何#rememberMe()身份验证，清除SecurityContextHolder，然后重定向到”/login?success”<br>anonymous()    允许配置匿名用户的表示方法。 当与WebSecurityConfigurerAdapter结合使用时，这将自动应用。 默认情况下，匿名用户将使用org.springframework.security.authentication.AnonymousAuthenticationToken表示，并包含角色 “ROLE_ANONYMOUS”<br>formLogin()    指定支持基于表单的身份验证。如果未指定FormLoginConfigurer#loginPage(String)，则将生成默认登录页面<br>oauth2Login()    根据外部OAuth 2.0或OpenID Connect 1.0提供程序配置身份验证<br>requiresChannel()    配置通道安全。为了使该配置有用，必须提供至少一个到所需信道的映射<br>httpBasic()    配置 Http Basic 验证<br>addFilterBefore()    在指定的Filter类之前添加过滤器<br>addFilterAt()    在指定的Filter类的位置添加过滤器<br>addFilterAfter()    在指定的Filter类的之后添加过滤器<br>and()    连接以上策略的连接器，用来组合安全策略。实际上就是”而且”的意思</p><hr><h2 id="玩转自定义登录"><a href="#玩转自定义登录" class="headerlink" title="玩转自定义登录"></a>玩转自定义登录</h2><ol><li><p>前言<br>前面的关于 Spring Security 相关的文章只是一个预热。为了接下来更好的实战，如果你错过了请从 Spring Security 实战系列 开始。安全访问的第一步就是认证（Authentication），认证的第一步就是登录。今天我们要通过对 Spring Security 的自定义，来设计一个可扩展，可伸缩的 form 登录功能。</p></li><li><p>form 登录的流程<br>下面是 form 登录的基本流程：<br>客户端发起请求，服务器端返回成功信息或返回失败信息<br>只要是 form 登录基本都能转化为上面的流程。接下来我们看看 Spring Security 是如何处理的。</p></li><li><p>Spring Security 中的登录<br>昨天 Spring Security 实战干货：自定义配置类入口WebSecurityConfigurerAdapter 中已经讲到了我们通常的自定义访问控制主要是通过 HttpSecurity 来构建的。默认它提供了三种登录方式：</p></li></ol><p>formLogin() 普通表单登录<br>oauth2Login() 基于 OAuth2.0 认证/授权协议<br>openidLogin() 基于 OpenID 身份认证规范<br>以上三种方式统统是 AbstractAuthenticationFilterConfigurer 实现的，</p><ol start="4"><li>HttpSecurity 中的 form 表单登录<br>启用表单登录通过两种方式一种是通过 HttpSecurity 的 apply(C configurer) 方法自己构造一个 AbstractAuthenticationFilterConfigurer 的实现，这种是比较高级的玩法。 另一种是我们常见的使用 HttpSecurity 的 formLogin() 方法来自定义 FormLoginConfigurer 。我们先搞一下比较常规的第二种。</li></ol><p>4.1 FormLoginConfigurer<br>该类是 form 表单登录的配置类。它提供了一些我们常用的配置方法：</p><p>loginPage(String loginPage) : 登录 页面而并不是接口，对于前后分离模式需要我们进行改造 默认为 /login。<br>loginProcessingUrl(String loginProcessingUrl) 实际表单向后台提交用户信息的 Action，再由过滤器UsernamePasswordAuthenticationFilter 拦截处理，该 Action 其实不会处理任何逻辑。<br>usernameParameter(String usernameParameter) 用来自定义用户参数名，默认 username 。<br>passwordParameter(String passwordParameter) 用来自定义用户密码名，默认 password<br>failureUrl(String authenticationFailureUrl) 登录失败后会重定向到此路径， 一般前后分离不会使用它。<br>failureForwardUrl(String forwardUrl) 登录失败会转发到此， 一般前后分离用到它。 可定义一个 Controller （控制器）来处理返回值,但是要注意 RequestMethod。<br>defaultSuccessUrl(String defaultSuccessUrl, boolean alwaysUse) 默认登陆成功后跳转到此 ，如果 alwaysUse 为 true 只要进行认证流程而且成功，会一直跳转到此。一般推荐默认值 false<br>successForwardUrl(String forwardUrl) 效果等同于上面 defaultSuccessUrl 的 alwaysUse 为 true 但是要注意 RequestMethod。<br>successHandler(AuthenticationSuccessHandler successHandler) 自定义认证成功处理器，可替代上面所有的 success 方式<br>failureHandler(AuthenticationFailureHandler authenticationFailureHandler) 自定义失败处理器，可替代上面所有的 failure 方式<br>permitAll(boolean permitAll) form 表单登录是否放开<br>知道了这些我们就能来搞个定制化的登录了。</p><ol start="5"><li>Spring Security 聚合登录 实战<br>接下来是我们最激动人心的实战登录操作。 有疑问的可认真阅读 Spring 实战 的一系列预热文章。</li></ol><p>5.1 简单需求<br>我们的接口访问都要通过认证，登陆错误后返回错误信息（json），成功后前台可以获取到对应数据库用户信息（json）（实战中记得脱敏）。</p><p>我们定义处理成功失败的控制器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">public class LoginController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private SysUserService sysUserService;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 登录失败返回 401 以及提示信息.</span><br><span class="line">    *</span><br><span class="line">    * @return the rest</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @PostMapping(&quot;&#x2F;failure&quot;)</span><br><span class="line">    public Rest loginFailure() &#123;</span><br><span class="line"></span><br><span class="line">        return RestBody.failure(HttpStatus.UNAUTHORIZED.value(), &quot;登录失败了，老哥&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 登录成功后拿到个人信息.</span><br><span class="line">    *</span><br><span class="line">    * @return the rest</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @PostMapping(&quot;&#x2F;success&quot;)</span><br><span class="line">    public Rest loginSuccess() &#123;</span><br><span class="line">        &#x2F;&#x2F; 登录成功后用户的认证信息 UserDetails会存在 安全上下文寄存器 SecurityContextHolder 中</span><br><span class="line">        User principal &#x3D; (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        String username &#x3D; principal.getUsername();</span><br><span class="line">        SysUser sysUser &#x3D; sysUserService.queryByUsername(username);</span><br><span class="line">        &#x2F;&#x2F; 脱敏</span><br><span class="line">        sysUser.setEncodePassword(&quot;[PROTECT]&quot;);</span><br><span class="line">        return RestBody.okData(sysUser,&quot;登录成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 我们自定义配置覆写 void configure(HttpSecurity http) 方法进行如下配置（这里需要禁用crsf）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span><br><span class="line">@ConditionalOnWebApplication(type &#x3D; ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line">public class CustomSpringBootWebSecurityConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    @Order(SecurityProperties.BASIC_AUTH_ORDER)</span><br><span class="line">    static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">            super.configure(auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">            super.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">            http.csrf().disable()</span><br><span class="line">                    .cors()</span><br><span class="line">                    .and()</span><br><span class="line">                    .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(&quot;&#x2F;process&quot;)</span><br><span class="line">                    .successForwardUrl(&quot;&#x2F;login&#x2F;success&quot;).</span><br><span class="line">                    failureForwardUrl(&quot;&#x2F;login&#x2F;failure&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Postman 或者其它工具进行 Post 方式的表单提交 <a href="http://localhost:8080/process?username=iching&amp;password=123456" target="_blank" rel="noopener">http://localhost:8080/process?username=iching&amp;password=123456</a> 会返回用户信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;httpStatus&quot;: 200,</span><br><span class="line">      &quot;data&quot;: &#123;</span><br><span class="line">          &quot;userId&quot;: 1,</span><br><span class="line">          &quot;username&quot;: &quot;iching&quot;,</span><br><span class="line">          &quot;encodePassword&quot;: &quot;[PROTECT]&quot;,</span><br><span class="line">          &quot;age&quot;: 18</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;msg&quot;: &quot;登录成功&quot;,</span><br><span class="line">      &quot;identifier&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>把密码修改为其它值再次请求认证失败后 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;httpStatus&quot;: 401,</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;msg&quot;: &quot;登录失败了&quot;,</span><br><span class="line">    &quot;identifier&quot;: &quot;-9999&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>多种登录方式并存的实现<br>就这么完了了么？现在登录的花样繁多。常规的就有短信、邮箱、扫码 ，第三方是以后我要讲的不在今天范围之内。 如何应对想法多的产品经理？ 我们来搞一个可扩展各种姿势的登录方式。我们在上面 2. form 登录的流程 中的 用户 和 判定 之间增加一个适配器来适配即可。 我们知道这个所谓的 判定就是 UsernamePasswordAuthenticationFilter 。</li></ol><p>我们只需要保证 uri 为上面配置的/process 并且能够通过 getParameter(String name) 获取用户名和密码即可 。</p><p>我突然觉得可以模仿 DelegatingPasswordEncoder 的搞法， 维护一个注册表执行不同的处理策略。当然我们要实现一个 GenericFilterBean 在 UsernamePasswordAuthenticationFilter 之前执行。同时制定登录的策略。</p><p>6.1 登录方式定义<br>定义登录方式枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum LoginTypeEnum &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 原始登录方式.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    FORM,</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Json 提交.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    JSON,</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 验证码.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    CAPTCHA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.2 定义前置处理器接口<br>定义前置处理器接口用来处理接收的各种特色的登录参数 并处理具体的逻辑。这个借口其实有点随意 ，重要的是你要学会思路。我实现了一个 默认的 form’ 表单登录 和 通过RequestBody放入json` 的两种方式，篇幅限制这里就不展示了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface LoginPostProcessor &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 获取 登录类型</span><br><span class="line">    *</span><br><span class="line">    * @return the type</span><br><span class="line">    *&#x2F;</span><br><span class="line">    LoginTypeEnum getLoginTypeEnum();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 获取用户名</span><br><span class="line">    *</span><br><span class="line">    * @param request the request</span><br><span class="line">    * @return the string</span><br><span class="line">    *&#x2F;</span><br><span class="line">    String obtainUsername(ServletRequest request);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 获取密码</span><br><span class="line">    *</span><br><span class="line">    * @param request the request</span><br><span class="line">    * @return the string</span><br><span class="line">    *&#x2F;</span><br><span class="line">    String obtainPassword(ServletRequest request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.3 实现登录前置处理过滤器<br>该过滤器维护了 LoginPostProcessor 映射表。 通过前端来判定登录方式进行策略上的预处理，最终还是会交给 UsernamePasswordAuthenticationFilter 。通过 HttpSecurity 的 addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)方法进行前置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 预登录控制器</span><br><span class="line">*&#x2F;</span><br><span class="line">public class PreLoginFilter extends GenericFilterBean &#123;</span><br><span class="line">    private static final String LOGIN_TYPE_KEY &#x3D; &quot;login_type&quot;;</span><br><span class="line"></span><br><span class="line">    private RequestMatcher requiresAuthenticationRequestMatcher;</span><br><span class="line">    private Map&lt;LoginTypeEnum, LoginPostProcessor&gt; processors &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public PreLoginFilter(String loginProcessingUrl, Collection&lt;LoginPostProcessor&gt; loginPostProcessors) &#123;</span><br><span class="line">        Assert.notNull(loginProcessingUrl, &quot;loginProcessingUrl must not be null&quot;);</span><br><span class="line">        requiresAuthenticationRequestMatcher &#x3D; new AntPathRequestMatcher(loginProcessingUrl, &quot;POST&quot;);</span><br><span class="line">        LoginPostProcessor loginPostProcessor &#x3D; defaultLoginPostProcessor();</span><br><span class="line">        processors.put(loginPostProcessor.getLoginTypeEnum(), loginPostProcessor);</span><br><span class="line"></span><br><span class="line">        if (!CollectionUtils.isEmpty(loginPostProcessors)) &#123;</span><br><span class="line">            loginPostProcessors.forEach(element -&gt; processors.put(element.getLoginTypeEnum(), element));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LoginTypeEnum getTypeFromReq(ServletRequest request) &#123;</span><br><span class="line">        String parameter &#x3D; request.getParameter(LOGIN_TYPE_KEY);</span><br><span class="line"></span><br><span class="line">        int i &#x3D; Integer.parseInt(parameter);</span><br><span class="line">        LoginTypeEnum[] values &#x3D; LoginTypeEnum.values();</span><br><span class="line">        return values[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 默认还是Form .</span><br><span class="line">    *</span><br><span class="line">    * @return the login post processor</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private LoginPostProcessor defaultLoginPostProcessor() &#123;</span><br><span class="line">        return new LoginPostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public LoginTypeEnum getLoginTypeEnum() &#123;</span><br><span class="line"></span><br><span class="line">                return LoginTypeEnum.FORM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public String obtainUsername(ServletRequest request) &#123;</span><br><span class="line">                return request.getParameter(SPRING_SECURITY_FORM_USERNAME_KEY);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public String obtainPassword(ServletRequest request) &#123;</span><br><span class="line">                return request.getParameter(SPRING_SECURITY_FORM_PASSWORD_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        ParameterRequestWrapper parameterRequestWrapper &#x3D; new ParameterRequestWrapper((HttpServletRequest) request);</span><br><span class="line">        if (requiresAuthenticationRequestMatcher.matches((HttpServletRequest) request)) &#123;</span><br><span class="line"></span><br><span class="line">            LoginTypeEnum typeFromReq &#x3D; getTypeFromReq(request);</span><br><span class="line"></span><br><span class="line">            LoginPostProcessor loginPostProcessor &#x3D; processors.get(typeFromReq);</span><br><span class="line"></span><br><span class="line">            String username &#x3D; loginPostProcessor.obtainUsername(request);</span><br><span class="line">            String password &#x3D; loginPostProcessor.obtainPassword(request);</span><br><span class="line"></span><br><span class="line">            parameterRequestWrapper.setAttribute(SPRING_SECURITY_FORM_USERNAME_KEY, username);</span><br><span class="line">            parameterRequestWrapper.setAttribute(SPRING_SECURITY_FORM_PASSWORD_KEY, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chain.doFilter(parameterRequestWrapper, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.4 验证<br>通过 POST 表单提交方式 <a href="http://localhost:8080/process?username=Felordcn&amp;password=12345&amp;login_type=0" target="_blank" rel="noopener">http://localhost:8080/process?username=Felordcn&amp;password=12345&amp;login_type=0</a> 可以请求成功<br>更多的方式 只需要实现接口 LoginPostProcessor 注入 PreLoginFilter</p><hr><h2 id="内置-Filter-全解析"><a href="#内置-Filter-全解析" class="headerlink" title="内置 Filter 全解析"></a>内置 Filter 全解析</h2><ol><li>前言<br>上一文我们使用 Spring Security 实现了各种登录聚合的场面。其中我们是通过在 UsernamePasswordAuthenticationFilter 之前一个自定义的过滤器实现的。我怎么知道自定义过滤器要加在 UsernamePasswordAuthenticationFilter 之前。我在这个系列开篇说了 Spring Security 权限控制的一个核心关键就是 过滤器链 ，这些过滤器如下图进行过滤传递，甚至比这个更复杂！这只是一个最小单元。<br>request handlerchain handler result</li></ol><p>Spring Security 内置了一些过滤器，他们各有各的本事。如果你掌握了这些过滤器，很多实际开发中的需求和问题都很容易解决。今天我们来见识一下这些内置的过滤器。</p><ol start="2"><li>内置过滤器初始化<br>在 Spring Security 初始化核心过滤器时 HttpSecurity 会通过将 Spring Security 内置的一些过滤器以 FilterComparator 提供的规则进行比较按照比较结果进行排序注册。</li></ol><p>2.1 排序规则<br>FilterComparator 维护了一个顺序的注册表 filterToOrder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">FilterComparator() &#123;</span><br><span class="line">    Step order &#x3D; new Step(INITIAL_ORDER, ORDER_STEP);</span><br><span class="line">    put(ChannelProcessingFilter.class, order.next());</span><br><span class="line">    put(ConcurrentSessionFilter.class, order.next());</span><br><span class="line">    put(WebAsyncManagerIntegrationFilter.class, order.next());</span><br><span class="line">    put(SecurityContextPersistenceFilter.class, order.next());</span><br><span class="line">    put(HeaderWriterFilter.class, order.next());</span><br><span class="line">    put(CorsFilter.class, order.next());</span><br><span class="line">    put(CsrfFilter.class, order.next());</span><br><span class="line">    put(LogoutFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">        &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.saml2.provider.service.servlet.filter.Saml2WebSsoAuthenticationRequestFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    put(X509AuthenticationFilter.class, order.next());</span><br><span class="line">    put(AbstractPreAuthenticatedProcessingFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">        &quot;org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.saml2.provider.service.servlet.filter.Saml2WebSsoAuthenticationFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    put(UsernamePasswordAuthenticationFilter.class, order.next());</span><br><span class="line">    put(ConcurrentSessionFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.openid.OpenIDAuthenticationFilter&quot;, order.next());</span><br><span class="line">    put(DefaultLoginPageGeneratingFilter.class, order.next());</span><br><span class="line">    put(DefaultLogoutPageGeneratingFilter.class, order.next());</span><br><span class="line">    put(ConcurrentSessionFilter.class, order.next());</span><br><span class="line">    put(DigestAuthenticationFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">            &quot;org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter&quot;, order.next());</span><br><span class="line">    put(BasicAuthenticationFilter.class, order.next());</span><br><span class="line">    put(RequestCacheAwareFilter.class, order.next());</span><br><span class="line">    put(SecurityContextHolderAwareRequestFilter.class, order.next());</span><br><span class="line">    put(JaasApiIntegrationFilter.class, order.next());</span><br><span class="line">    put(RememberMeAuthenticationFilter.class, order.next());</span><br><span class="line">    put(AnonymousAuthenticationFilter.class, order.next());</span><br><span class="line">    filterToOrder.put(</span><br><span class="line">        &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationCodeGrantFilter&quot;,</span><br><span class="line">            order.next());</span><br><span class="line">    put(SessionManagementFilter.class, order.next());</span><br><span class="line">    put(ExceptionTranslationFilter.class, order.next());</span><br><span class="line">    put(FilterSecurityInterceptor.class, order.next());</span><br><span class="line">    put(SwitchUserFilter.class, order.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些就是所有内置的过滤器。 他们是通过下面的方法获取自己的序号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Integer getOrder(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">    while (clazz !&#x3D; null) &#123;</span><br><span class="line">        Integer result &#x3D; filterToOrder.get(clazz.getName());</span><br><span class="line">        if (result !&#x3D; null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        clazz &#x3D; clazz.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过过滤器的类全限定名从注册表 filterToOrder 中获取自己的序号，如果没有直接获取到序号通过递归获取父类在注册表中的序号作为自己的序号，序号越小优先级越高。上面的过滤器并非全部会被初始化。有的需要额外引入一些功能包，有的看 HttpSecurity 的配置情况。 在上一篇文章中。我们禁用了 CSRF 功能，就意味着 CsrfFilter 不会被注册。</p><ol start="3"><li>内置过滤器讲解<br>接下来我们就对这些内置过滤器进行一个系统的认识。我们将按照默认顺序进行讲解。</li></ol><p>3.1 ChannelProcessingFilter<br>ChannelProcessingFilter 通常是用来过滤哪些请求必须用 https 协议， 哪些请求必须用 http 协议， 哪些请求随便用哪个协议都行。它主要有两个属性：</p><p>ChannelDecisionManager 用来判断请求是否符合既定的协议规则。它维护了一个 ChannelProcessor 列表 这些ChannelProcessor 是具体用来执行 ANY_CHANNEL 策略 （任何通道都可以）, REQUIRES_SECURE_CHANNEL 策略 （只能通过https 通道）, REQUIRES_INSECURE_CHANNEL 策略 （只能通过 http 通道）。</p><p>FilterInvocationSecurityMetadataSource 用来存储 url 与 对应的ANY_CHANNEL、REQUIRES_SECURE_CHANNEL、REQUIRES_INSECURE_CHANNEL 的映射关系。</p><p>ChannelProcessingFilter 通过 HttpScurity#requiresChannel() 等相关方法引入其配置对象 ChannelSecurityConfigurer 来进行配置。</p><p>3.2 ConcurrentSessionFilter<br>ConcurrentSessionFilter 主要用来判断session是否过期以及更新最新的访问时间。其流程为：</p><p>session 检测，如果不存在直接放行去执行下一个过滤器。存在则进行下一步。<br>根据sessionid从SessionRegistry中获取SessionInformation，从SessionInformation中获取session是否过期；没有过期则更新SessionInformation中的访问日期；<br>如果过期，则执行doLogout()方法，这个方法会将session无效，并将 SecurityContext 中的Authentication中的权限置空，同时在SecurityContenxtHoloder中清除SecurityContext然后查看是否有跳转的 expiredUrl，如果有就跳转，没有就输出提示信息。<br>ConcurrentSessionFilter 通过SessionManagementConfigurer 来进行配置。</p><p>3.3 WebAsyncManagerIntegrationFilter<br>WebAsyncManagerIntegrationFilter用于集成SecurityContext到Spring异步执行机制中的WebAsyncManager。用来处理异步请求的安全上下文。具体逻辑为：</p><p>从请求属性上获取所绑定的WebAsyncManager，如果尚未绑定，先做绑定。<br>从asyncManager 中获取 key 为 CALLABLE_INTERCEPTOR_KEY 的安全上下文多线程处理器 SecurityContextCallableProcessingInterceptor, 如果获取到的为 null，<br>新建一个 SecurityContextCallableProcessingInterceptor 并绑定 CALLABLE_INTERCEPTOR_KEY 注册到 asyncManager 中。<br>这里简单说一下 SecurityContextCallableProcessingInterceptor 。它实现了接口 CallableProcessingInterceptor，<br>当它被应用于一次异步执行时，beforeConcurrentHandling() 方法会在调用者线程执行，该方法会相应地从当前线程获取SecurityContext,然后被调用者线程中执行逻辑时，会使用这个 SecurityContext，从而实现安全上下文从调用者线程到被调用者线程的传输。</p><p>WebAsyncManagerIntegrationFilter 通过 WebSecurityConfigurerAdapter#getHttp()方法添加到 HttpSecurity 中成为 DefaultSecurityFilterChain 的一个链节。</p><p>3.4 SecurityContextPersistenceFilter<br>SecurityContextPersistenceFilter 主要控制 SecurityContext 的在一次请求中的生命周期 。 请求来临时，创建SecurityContext 安全上下文信息，请求结束时清空 SecurityContextHolder。</p><p>SecurityContextPersistenceFilter 通过 HttpScurity#securityContext() 及相关方法引入其配置对象 SecurityContextConfigurer 来进行配置。</p><p>3.5 HeaderWriterFilter<br>HeaderWriterFilter 用来给 http 响应添加一些 Header,比如 X-Frame-Options, X-XSS-Protection ，X-Content-Type-Options。</p><p>你可以通过 HttpScurity#headers() 来定制请求Header 。</p><p>3.6 CorsFilter<br>跨域相关的过滤器。这是Spring MVC Java配置和XML 命名空间 CORS 配置的替代方法， 仅对依赖于spring-web的应用程序有用（不适用于spring-webmvc）或 要求在javax.servlet.Filter 级别进行CORS检查的安全约束链接。这个是目前官方的一些解读，但是我还是不太清楚实际机制。</p><p>你可以通过 HttpSecurity#cors() 来定制。</p><p>3.7 CsrfFilter<br>CsrfFilter 用于防止csrf攻击，前后端使用json交互需要注意的一个问题。</p><p>你可以通过 HttpSecurity.csrf() 来开启或者关闭它。在你使用 jwt 等 token 技术时，是不需要这个的。</p><p>3.8 LogoutFilter<br>LogoutFilter 很明显这是处理注销的过滤器。</p><p>你可以通过 HttpSecurity.logout() 来定制注销逻辑，非常有用。</p><p>3.9 OAuth2AuthorizationRequestRedirectFilter<br>和上面的有所不同，这个需要依赖 spring-scurity-oauth2 相关的模块。该过滤器是处理 OAuth2 请求首选重定向相关逻辑的。以后会我会带你们认识它，请多多关注公众号：Felordcn 。</p><p>3.10 Saml2WebSsoAuthenticationRequestFilter<br>这个需要用到 Spring Security SAML 模块，这是一个基于 SMAL 的 SSO 单点登录请求认证过滤器。</p><p>关于SAML<br>SAML 即安全断言标记语言，英文全称是 Security Assertion Markup Language。它是一个基于 XML 的标准，用于在不同的安全域（security domain）之间交换认证和授权数据。在 SAML 标准定义了身份提供者 (identity provider) 和服务提供者 (service provider)，这两者构成了前面所说的不同的安全域。 SAML 是 OASIS 组织安全服务技术委员会(Security Services Technical Committee) 的产品。</p><p>SAML（Security Assertion Markup Language）是一个 XML 框架，也就是一组协议，可以用来传输安全声明。比如，两台远程机器之间要通讯，为了保证安全，我们可以采用加密等措施，也可以采用 SAML 来传输，传输的数据以 XML 形式，符合 SAML 规范，这样我们就可以不要求两台机器采用什么样的系统，只要求能理解 SAML 规范即可，显然比传统的方式更好。SAML 规范是一组 Schema 定义。</p><p>可以这么说，在Web Service 领域，schema 就是规范，在 Java 领域，API 就是规范</p><p>3.11 X509AuthenticationFilter<br>X509 认证过滤器。你可以通过 HttpSecurity#X509() 来启用和配置相关功能。</p><p>3.12 AbstractPreAuthenticatedProcessingFilter<br>AbstractPreAuthenticatedProcessingFilter 处理处理经过预先认证的身份验证请求的过滤器的基类，其中认证主体已经由外部系统进行了身份验证。 目的只是从传入请求中提取主体上的必要信息，而不是对它们进行身份验证。</p><p>你可以继承该类进行具体实现并通过 HttpSecurity#addFilter 方法来添加个性化的AbstractPreAuthenticatedProcessingFilter 。</p><p>3.13 CasAuthenticationFilter<br>CAS 单点登录认证过滤器 。依赖 Spring Security CAS 模块</p><p>3.14 OAuth2LoginAuthenticationFilter<br>这个需要依赖 spring-scurity-oauth2 相关的模块。OAuth2 登录认证过滤器。处理通过 OAuth2 进行认证登录的逻辑。</p><p>3.15 Saml2WebSsoAuthenticationFilter<br>这个需要用到 Spring Security SAML 模块，这是一个基于 SMAL 的 SSO 单点登录认证过滤器。关于SAML</p><p>3.16 UsernamePasswordAuthenticationFilter<br>这个看过我相关文章的应该不陌生了。处理用户以及密码认证的核心过滤器。认证请求提交的username和 password，被封装成token进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</p><p>你可以通过 HttpSecurity#formLogin() 及相关方法引入其配置对象 FormLoginConfigurer 来进行配置。 我们在 Spring Security 实战干货： 玩转自定义登录 已经对其进行过个性化的配置和魔改。</p><p>3.17 ConcurrentSessionFilter<br>参见 3.2 ConcurrentSessionFilter。 该过滤器可能会被多次执行。</p><p>3.18 OpenIDAuthenticationFilter<br>基于OpenID 认证协议的认证过滤器。 你需要在依赖中依赖额外的相关模块才能启用它。</p><p>3.19 DefaultLoginPageGeneratingFilter<br>生成默认的登录页。默认 /login 。</p><p>3.20 DefaultLogoutPageGeneratingFilter<br>生成默认的退出页。 默认 /logout 。</p><p>3.21 ConcurrentSessionFilter<br>参见 3.2 ConcurrentSessionFilter 。 该过滤器可能会被多次执行。</p><p>3.23 DigestAuthenticationFilter<br>Digest身份验证是 Web 应用程序中流行的可选的身份验证机制 。DigestAuthenticationFilter 能够处理 HTTP 头中显示的摘要式身份验证凭据。你可以通过 HttpSecurity#addFilter() 来启用和配置相关功能。</p><p>3.24 BasicAuthenticationFilter<br>和Digest身份验证一样都是Web 应用程序中流行的可选的身份验证机制 。 BasicAuthenticationFilter 负责处理 HTTP 头中显示的基本身份验证凭据。这个 Spring Security 的 Spring Boot 自动配置默认是启用的 。</p><p>BasicAuthenticationFilter 通过 HttpSecurity#httpBasic() 及相关方法引入其配置对象 HttpBasicConfigurer 来进行配置。</p><p>3.25 RequestCacheAwareFilter<br>用于用户认证成功后，重新恢复因为登录被打断的请求。当匿名访问一个需要授权的资源时。会跳转到认证处理逻辑，此时请求被缓存。在认证逻辑处理完毕后，从缓存中获取最开始的资源请求进行再次请求。</p><p>RequestCacheAwareFilter 通过 HttpScurity#requestCache() 及相关方法引入其配置对象 RequestCacheConfigurer 来进行配置。</p><p>3.26 SecurityContextHolderAwareRequestFilter<br>用来 实现j2ee中 Servlet Api 一些接口方法, 比如 getRemoteUser 方法、isUserInRole 方法，在使用 Spring Security 时其实就是通过这个过滤器来实现的。</p><p>SecurityContextHolderAwareRequestFilter 通过 HttpSecurity.servletApi() 及相关方法引入其配置对象 ServletApiConfigurer 来进行配置。</p><p>3.27 JaasApiIntegrationFilter<br>适用于JAAS （Java 认证授权服务）。 如果 SecurityContextHolder 中拥有的 Authentication 是一个 JaasAuthenticationToken，那么该 JaasApiIntegrationFilter 将使用包含在 JaasAuthenticationToken 中的 Subject 继续执行 FilterChain。</p><p>3.28 RememberMeAuthenticationFilter<br>处理 记住我 功能的过滤器。</p><p>RememberMeAuthenticationFilter 通过 HttpSecurity.rememberMe() 及相关方法引入其配置对象 RememberMeConfigurer 来进行配置。</p><p>3.29 AnonymousAuthenticationFilter<br>匿名认证过滤器。对于 Spring Security 来说，所有对资源的访问都是有 Authentication 的。对于无需登录（UsernamePasswordAuthenticationFilter ）直接可以访问的资源，会授予其匿名用户身份。</p><p>AnonymousAuthenticationFilter 通过 HttpSecurity.anonymous() 及相关方法引入其配置对象 AnonymousConfigurer 来进行配置。</p><p>3.30 SessionManagementFilter<br>Session 管理器过滤器，内部维护了一个 SessionAuthenticationStrategy 用于管理 Session 。</p><p>SessionManagementFilter 通过 HttpScurity#sessionManagement() 及相关方法引入其配置对象 SessionManagementConfigurer 来进行配置。</p><p>3.31 ExceptionTranslationFilter<br>主要来传输异常事件，还记得之前我们见过的 DefaultAuthenticationEventPublisher 吗？</p><p>3.32 FilterSecurityInterceptor<br>这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。如果你要实现动态权限控制就必须研究该类 。</p><p>3.33 SwitchUserFilter<br>SwitchUserFilter 是用来做账户切换的。默认的切换账号的url为/login/impersonate，默认注销切换账号的url为/logout/impersonate，默认的账号参数为username 。</p><p>你可以通过此类实现自定义的账户切换。</p><ol start="4"><li>总结<br>所有内置的 31个过滤器作用都讲解完了，有一些默认已经启用。有一些需要引入特定的包并且对 HttpSecurity 进行配置才会生效,而且它们的顺序是既定的。 只有你了解这些过滤器你才能基于业务深度定制 Spring Security 。</li></ol><hr><h2 id="实现自定义退出登录"><a href="#实现自定义退出登录" class="headerlink" title="实现自定义退出登录"></a>实现自定义退出登录</h2><ol><li><p>前言<br>上一篇对 Spring Security 所有内置的 Filter 进行了介绍。今天我们来实战如何安全退出应用程序。</p></li><li><p>我们使用 Spring Security 登录后都做了什么<br>这个问题我们必须搞清楚！一般登录后，服务端会给用户发一个凭证。常见有以下的两种：</p></li></ol><p>基于 Session 客户端会存 cookie 来保存一个 sessionId ，服务端存一个 Session 。</p><p>基于 token 客户端存一个 token 串，服务端会在缓存中存一个用来校验此 token 的信息。</p><ol start="2"><li>退出登录需要我们做什么<br>当前的用户登录状态失效。这就需要我们清除服务端的用户状态。<br>退出登录接口并不是 permitAll， 只有携带对应用户的凭证才退出。<br>将退出结果返回给请求方。<br>退出登录后用户可以通过重新登录来认证该用户。</li><li>Spring Security 中的退出登录<br>接下来我们来分析并实战 如何定制退出登录逻辑。首先我们要了解 LogoutFilter 。</li></ol><p>3.1 LogoutFilter<br>通过 Spring Security 实战干货：内置 Filter 全解析 我们知道退出登录逻辑是由过滤器 LogoutFilter 来执行的。 它持有三个接口类型的属性：</p><p>RequestMatcher logoutRequestMatcher 这个用来拦截退出请求的 URL<br>LogoutHandler handler 用来处理退出的具体逻辑<br>LogoutSuccessHandler logoutSuccessHandler 退出成功后执行的逻辑<br>我们通过对以上三个接口的实现就能实现我们自定义的退出逻辑。</p><p>3.2 LogoutConfigurer<br>我们一般不会直接操作 LogoutFilter ，而是通过 LogoutConfigurer 来配置 LogoutFilter。 你可以通过 HttpSecurity#logout() 方法来初始化一个 LogoutConfigurer 。 接下来我们来实战操作一下。</p><p>3.2.1 实现自定义退出登录请求URL<br>LogoutConfigurer 提供了 logoutRequestMatcher(RequestMatcher logoutRequestMatcher)、logoutUrl(Sring logoutUrl) 两种方式来定义退出登录请求的 URL 。它们作用是相同的，你选择其中一种方式即可。</p><p>3.2.2 处理具体的逻辑<br>默认情况下 Spring Security 是基于 Session 的。LogoutConfigurer 提供了一些直接配置来满足你的需要。如下：</p><p>clearAuthentication(boolean clearAuthentication) 是否在退出时清除当前用户的认证信息<br>deleteCookies(String… cookieNamesToClear) 删除指定的 cookies<br>invalidateHttpSession(boolean invalidateHttpSession) 是否移除 HttpSession<br>如果上面满足不了你的需要就需要你来定制 LogoutHandler 了。</p><p>3.2.3 退出成功逻辑<br>logoutSuccessUrl(String logoutSuccessUrl) 退出成功后会被重定向到此 URL ，你可以写一个Controller 来完成最终返回，但是需要支持 GET 请求和 匿名访问 。 通过 setDefaultTargetUrl 方法注入到 LogoutSuccessHandler<br>defaultLogoutSuccessHandlerFor(LogoutSuccessHandler handler, RequestMatcher preferredMatcher) 用来构造默认的 LogoutSuccessHandler 我们可以通过添加多个来实现从不同 URL 退出执行不同的逻辑。<br>LogoutSuccessHandler logoutSuccessHandler 退出成功后执行的逻辑的抽象根本接口。<br>3.3 Spring Security 退出登录实战<br>现在前后端分离比较多，退出后返回json。 而且只有用户在线才能退出登录。否则不能进行退出操作。我们采用实现 LogoutHandler 和 LogoutSuccessHandler 接口这种编程的方式来配置 。退出请求的 url 依然通过 LogoutConfigurer#logoutUrl(String logoutUrl)来定义。</p><p>3.3.1 自定义 LogoutHandler<br>默认情况下清除认证信息 （invalidateHttpSession），和Session 失效（invalidateHttpSession） 已经由内置的SecurityContextLogoutHandler 来完成。我们自定义的 LogoutHandler 会在SecurityContextLogoutHandler 来执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">  public class CustomLogoutHandler implements LogoutHandler &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;</span><br><span class="line">          User user &#x3D; (User) authentication.getPrincipal();</span><br><span class="line">          String username &#x3D; user.getUsername();</span><br><span class="line">          log.info(&quot;username: &#123;&#125;  is offline now&quot;, username);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上是我们实现的 LogoutHandler 。 我们可以从 logout 方法的 authentication 变量中 获取当前用户信息。你可以通过这个来实现你具体想要的业务。比如记录用户下线退出时间、IP 等等。</p><p>3.3.2 自定义 LogoutSuccessHandler<br>如果我们实现了自定义的 LogoutSuccessHandler 就不必要设置 LogoutConfigurer#logoutSuccessUrl(String logoutSuccessUrl) 了。该处理器处理后会响应给前端。你可以转发到其它控制器。重定向到登录页面，也可以自行实现其它 MediaType ,可以是 json 或者页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class CustomLogoutSuccessHandler implements LogoutSuccessHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">        User user &#x3D; (User) authentication.getPrincipal();</span><br><span class="line">        String username &#x3D; user.getUsername();</span><br><span class="line">        log.info(&quot;username: &#123;&#125;  is offline now&quot;, username);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        responseJsonWriter(response, RestBody.ok(&quot;退出成功&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void responseJsonWriter(HttpServletResponse response, Rest rest) throws IOException &#123;</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        String resBody &#x3D; objectMapper.writeValueAsString(rest);</span><br><span class="line">        PrintWriter printWriter &#x3D; response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.3.4 自定义退出的 Spring Security 配置<br>为了方便调试我 注释掉了我们 实现的自定义登录，你可以通过 http:localhost:8080/login 来登录，然后通过 http:localhost:8080/logout 测试退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.csrf().disable()</span><br><span class="line">    .cors()</span><br><span class="line">    .and()</span><br><span class="line">    .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    &#x2F;&#x2F;.addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">    &#x2F;&#x2F; 登录</span><br><span class="line">    .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successForwardUrl(&quot;&#x2F;login&#x2F;success&quot;).failureForwardUrl(&quot;&#x2F;login&#x2F;failure&quot;)</span><br><span class="line">    .and().logout().addLogoutHandler(new CustomLogoutHandler()).logoutSuccessHandler(new CustomLogoutSuccessHandler());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手把手教你实现JWT-Token"><a href="#手把手教你实现JWT-Token" class="headerlink" title="手把手教你实现JWT Token"></a>手把手教你实现JWT Token</h2><ol><li><p>前言<br>Json Web Token （JWT） 近几年是前后端分离常用的 Token 技术，是目前最流行的跨域身份验证解决方案。你可以通过文章 一文了解web无状态会话token技术JWT 来了解 JWT。今天我们来手写一个通用的 JWT 服务。DEMO 获取方式在文末，实现在 jwt 相关包下</p></li><li><p>spring-security-jwt<br>spring-security-jwt 是 Spring Security Crypto 提供的 JWT 工具包 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-security-jwt.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>核心类只有一个: org.springframework.security.jwt.JwtHelper 。它提供了两个非常有用的静态方法。</p></li><li><p>JWT 编码<br>JwtHelper 提供的第一个静态方法就是 encode(CharSequence content, Signer signer) 这个是用来生成jwt的方法 需要指定 payload 跟 signer 签名算法。payload 存放了一些可用的不敏感信息：</p></li></ol><p>iss jwt签发者<br>sub jwt所面向的用户<br>aud 接收jwt的一方<br>iat jwt的签发时间<br>exp jwt的过期时间，这个过期时间必须要大于签发时间 iat<br>jti jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击<br>除了以上提供的基本信息外，我们可以定义一些我们需要传递的信息，比如目标用户的权限集 等等。切记不要传递密码等敏感信息 ，因为 JWT 的前两段都是用了 BASE64 编码，几乎算是明文了。</p><p>3.1 构建 JWT 中的 payload<br>我们先来构建 payload :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class JwtPayloadBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, String&gt; payload &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 附加的属性</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private Map&lt;String, String&gt; additional;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt签发者</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String iss;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt所面向的用户</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String sub;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 接收jwt的一方</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String aud;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private LocalDateTime exp;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt的签发时间</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private LocalDateTime iat &#x3D; LocalDateTime.now();</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 权限集</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private Set&lt;String&gt; roles &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</span><br><span class="line">    **&#x2F;</span><br><span class="line">    private String jti &#x3D; IdUtil.simpleUUID();</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder iss(String iss) &#123;</span><br><span class="line">        this.iss &#x3D; iss;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder sub(String sub) &#123;</span><br><span class="line">        this.sub &#x3D; sub;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder aud(String aud) &#123;</span><br><span class="line">        this.aud &#x3D; aud;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder roles(Set&lt;String&gt; roles) &#123;</span><br><span class="line">        this.roles &#x3D; roles;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder expDays(int days) &#123;</span><br><span class="line">        Assert.isTrue(days &gt; 0, &quot;jwt expireDate must after now&quot;);</span><br><span class="line">        this.exp &#x3D; this.iat.plusDays(days);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JwtPayloadBuilder additional(Map&lt;String, String&gt; additional) &#123;</span><br><span class="line">        this.additional &#x3D; additional;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String builder() &#123;</span><br><span class="line">        payload.put(&quot;iss&quot;, this.iss);</span><br><span class="line">        payload.put(&quot;sub&quot;, this.sub);</span><br><span class="line">        payload.put(&quot;aud&quot;, this.aud);</span><br><span class="line">        payload.put(&quot;exp&quot;, this.exp.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        payload.put(&quot;iat&quot;, this.iat.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        payload.put(&quot;jti&quot;, this.jti);</span><br><span class="line"></span><br><span class="line">        if (!CollectionUtils.isEmpty(additional)) &#123;</span><br><span class="line">            payload.putAll(additional);</span><br><span class="line">        &#125;</span><br><span class="line">        payload.put(&quot;roles&quot;, JSONUtil.toJsonStr(this.roles));</span><br><span class="line">        return JSONUtil.toJsonStr(JSONUtil.parse(payload));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过建造类 JwtClaimsBuilder 我们可以很方便来构建 JWT 所需要的 payload json 字符串传递给 encode(CharSequence content, Signer signer) 中的 content 。</p><p>3.2 生成 RSA 密钥并进行签名<br>为了生成 JWT Token 我们还需要使用 RSA 算法来进行签名。 这里我们使用 JDK 提供的证书管理工具 Keytool 来生成 RSA 证书 ，格式为 jks 格式。</p><p>生成证书命令参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias iching -keypass iching -keyalg RSA -storetype PKCS12 -keysize 1024 -validity 365 -keystore &#x2F;Users&#x2F;minyi&#x2F;web&#x2F;ideaSpace&#x2F;spring-boot-starter&#x2F;iching-auth-server&#x2F;src&#x2F;main&#x2F;resources&#x2F;iching.jks -storepass 123456  -dname &quot;CN&#x3D;(iching), OU&#x3D;(iching), O&#x3D;(iching), L&#x3D;(zz), ST&#x3D;(hn), C&#x3D;(cn)&quot;</span><br></pre></td></tr></table></figure><p> 其中 -alias iching -storepass 123456 我们要作为配置使用要记下来。我们要使用下面定义的这个类来读取证书<br>查看jks文件中所有证书内容<br>keytool -list -v -keystore cert_file_name<br>修改证书文文件的加密密码<br>keytool -storepasswd -keystore cert_file_name<br>输入命令，会首先提示你输入证书原始密码；之后会继续要求你输入两次新密码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class KeyPairFactory &#123;</span><br><span class="line"></span><br><span class="line">     private KeyStore store;</span><br><span class="line"></span><br><span class="line">     private final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">     &#x2F;**</span><br><span class="line">      * 获取公私钥.</span><br><span class="line">      *</span><br><span class="line">      * @param keyPath  jks 文件在 resources 下的classpath</span><br><span class="line">      * @param keyAlias  keytool 生成的 -alias 值  felordcn</span><br><span class="line">      * @param keyPass  keytool 生成的  -storepass 值  123456</span><br><span class="line">      * @return the key pair 公私钥对</span><br><span class="line">      *&#x2F;</span><br><span class="line">    KeyPair create(String keyPath, String keyAlias, String keyPass) &#123;</span><br><span class="line">         ClassPathResource resource &#x3D; new ClassPathResource(keyPath);</span><br><span class="line">         char[] pem &#x3D; keyPass.toCharArray();</span><br><span class="line">         try &#123;</span><br><span class="line">             synchronized (lock) &#123;</span><br><span class="line">                 if (store &#x3D;&#x3D; null) &#123;</span><br><span class="line">                     synchronized (lock) &#123;</span><br><span class="line">                         store &#x3D; KeyStore.getInstance(&quot;jks&quot;);</span><br><span class="line">                         store.load(resource.getInputStream(), pem);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             RSAPrivateCrtKey key &#x3D; (RSAPrivateCrtKey) store.getKey(keyAlias, pem);</span><br><span class="line">             RSAPublicKeySpec spec &#x3D; new RSAPublicKeySpec(key.getModulus(), key.getPublicExponent());</span><br><span class="line">             PublicKey publicKey &#x3D; KeyFactory.getInstance(&quot;RSA&quot;).generatePublic(spec);</span><br><span class="line">             return new KeyPair(publicKey, key);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">             throw new IllegalStateException(&quot;Cannot load keys from store: &quot; + resource, e);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 获取了 KeyPair 就能获取公私钥 生成 Jwt 的两个要素就完成了。我们可以和之前定义的 JwtPayloadBuilder 一起封装出生成 Jwt Token 的方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private String jwtToken(String aud, int exp, Set&lt;String&gt; roles, Map&lt;String, String&gt; additional) &#123;</span><br><span class="line">    String payload &#x3D; jwtPayloadBuilder</span><br><span class="line">            .iss(jwtProperties.getIss())</span><br><span class="line">            .sub(jwtProperties.getSub())</span><br><span class="line">            .aud(aud)</span><br><span class="line">            .additional(additional)</span><br><span class="line">            .roles(roles)</span><br><span class="line">            .expDays(exp)</span><br><span class="line">            .builder();</span><br><span class="line">    RSAPrivateKey privateKey &#x3D; (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">    RsaSigner signer &#x3D; new RsaSigner(privateKey);</span><br><span class="line">    return JwtHelper.encode(payload, signer).getEncoded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 通常情况下 Jwt Token 都是成对出现的，一个为平常请求携带的 accessToken， 另一个只作为刷新 accessToken 之用的 refreshToken 。而且 refreshToken 的过期时间要相对长一些。当 accessToken 失效而refreshToken 有效时，我们可以通过 refreshToken 来获取新的 Jwt Token对 ；当两个都失效就用户就必须重新登录了。</p><p>生成 Jwt Token对 的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public JwtTokenPair jwtTokenPair(String aud, Set&lt;String&gt; roles, Map&lt;String, String&gt; additional) &#123;</span><br><span class="line">    String accessToken &#x3D; jwtToken(aud, jwtProperties.getAccessExpDays(), roles, additional);</span><br><span class="line">    String refreshToken &#x3D; jwtToken(aud, jwtProperties.getRefreshExpDays(), roles, additional);</span><br><span class="line"></span><br><span class="line">    JwtTokenPair jwtTokenPair &#x3D; new JwtTokenPair();</span><br><span class="line">    jwtTokenPair.setAccessToken(accessToken);</span><br><span class="line">    jwtTokenPair.setRefreshToken(refreshToken);</span><br><span class="line">    &#x2F;&#x2F; 放入缓存</span><br><span class="line">    jwtTokenStorage.put(jwtTokenPair, aud);</span><br><span class="line">    return jwtTokenPair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常 Jwt Token对 会在返回给前台的同时放入缓存中。过期策略你可以选择分开处理，也可以选择以refreshToken 的过期时间为准。</p><ol start="4"><li><p>JWT 解码以及验证<br>JwtHelper 提供的第二个静态方法是Jwt decodeAndVerify(String token, SignatureVerifier verifier) 用来 验证和解码 Jwt Token 。我们获取到请求中的token后会解析出用户的一些信息。通过这些信息去缓存中对应的token ，然后比对并验证是否有效（包括是否过期）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 解码 并校验签名 过期不予解析</span><br><span class="line">*</span><br><span class="line">* @param jwtToken the jwt token</span><br><span class="line">* @return the jwt claims</span><br><span class="line">*&#x2F;</span><br><span class="line">public JSONObject decodeAndVerify(String jwtToken) &#123;</span><br><span class="line">    Assert.hasText(jwtToken, &quot;jwt token must not be bank&quot;);</span><br><span class="line">    RSAPublicKey rsaPublicKey &#x3D; (RSAPublicKey) this.keyPair.getPublic();</span><br><span class="line">    SignatureVerifier rsaVerifier &#x3D; new RsaVerifier(rsaPublicKey);</span><br><span class="line">    Jwt jwt &#x3D; JwtHelper.decodeAndVerify(jwtToken, rsaVerifier);</span><br><span class="line">    String claims &#x3D; jwt.getClaims();</span><br><span class="line">    JSONObject jsonObject &#x3D; JSONUtil.parseObj(claims);</span><br><span class="line">    String exp &#x3D; jsonObject.getStr(JWT_EXP_KEY);</span><br><span class="line">    &#x2F;&#x2F; 是否过期</span><br><span class="line">    if (isExpired(exp)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;jwt token is expired&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们将有效的 Jwt Token 中的 payload 解析为 JSON对象 ，方便后续的操作。</p></li><li><p>配置<br>我们将 JWT 的可配置项抽出来放入 JwtProperties 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Jwt 在 springboot application.yml 中的配置文件</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Data</span><br><span class="line"> @ConfigurationProperties(prefix&#x3D;JWT_PREFIX)</span><br><span class="line"> public class JwtProperties &#123;</span><br><span class="line">     static final String JWT_PREFIX&#x3D; &quot;jwt.config&quot;;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * 是否可用</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private boolean enabled;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * jks 路径</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private String keyLocation;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * key alias</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private String keyAlias;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * key store pass</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private String keyPass;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * jwt签发者</span><br><span class="line">      **&#x2F;</span><br><span class="line">     private String iss;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * jwt所面向的用户</span><br><span class="line">      **&#x2F;</span><br><span class="line">     private String sub;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * access jwt token 有效天数</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private int accessExpDays;</span><br><span class="line">     &#x2F;**</span><br><span class="line">      * refresh jwt token 有效天数</span><br><span class="line">      *&#x2F;</span><br><span class="line">     private int refreshExpDays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以配置 JWT 的 javaConfig 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@EnableConfigurationProperties(JwtProperties.class)</span><br><span class="line">@ConditionalOnProperty(prefix &#x3D; &quot;jwt.config&quot;,name &#x3D; &quot;enabled&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class JwtConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Jwt token storage .</span><br><span class="line">    *</span><br><span class="line">    * @return the jwt token storage</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtTokenStorage jwtTokenStorage() &#123;</span><br><span class="line">        return new JwtTokenCacheStorage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Jwt token generator.</span><br><span class="line">    *</span><br><span class="line">    * @param jwtTokenStorage the jwt token storage</span><br><span class="line">    * @param jwtProperties   the jwt properties</span><br><span class="line">    * @return the jwt token generator</span><br><span class="line">    *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtTokenGenerator jwtTokenGenerator(JwtTokenStorage jwtTokenStorage, JwtProperties jwtProperties) &#123;</span><br><span class="line">        return new JwtTokenGenerator(jwtTokenStorage, jwtProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就可以通过 JwtTokenGenerator 编码/解码验证 Jwt Token 对 ，通过 JwtTokenStorage 来处理 Jwt Token 缓存。缓存这里我用了Spring Cache Ehcache 来实现,你也可以切换到 Redis 。</p></li></ol><hr><h2 id="登录后返回-JWT-Token"><a href="#登录后返回-JWT-Token" class="headerlink" title="登录后返回 JWT Token"></a>登录后返回 JWT Token</h2><ol><li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章，上一文 我们实现了 JWT 工具。本篇我们将一起探讨如何将 JWT 与 Spring Security 结合起来，在认证成功后不再跳转到指定页面而是直接返回 JWT Token 。 本文的DEMO 可通过文末的方式获取</p></li><li><p>流程<br>JWT 适用于前后端分离。我们在登录成功后不在跳转到首页，将会直接返回 JWT Token 对（DEMO中为JwtTokenPair），登录失败后返回认证失败相关的信息。</p></li><li><p>实现登录成功/失败返回逻辑<br>如果你看过 Spring Security 实战干货： 玩转自定义登录 将非常容易理解下面的做法。</p></li></ol><p>3.1 AuthenticationSuccessHandler 返回 JWT Token<br>AuthenticationSuccessHandler 用于处理登录成功后的逻辑，我们编写实现并注入 Spring IoC 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 处理登录成功后返回 JWT Token 对.</span><br><span class="line">*</span><br><span class="line">* @param jwtTokenGenerator the jwt token generator</span><br><span class="line">* @return the authentication success handler</span><br><span class="line">*&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">public AuthenticationSuccessHandler authenticationSuccessHandler(JwtTokenGenerator jwtTokenGenerator) &#123;</span><br><span class="line">    return (request, response, authentication) -&gt; &#123;</span><br><span class="line">        if (response.isCommitted()) &#123;</span><br><span class="line">            log.debug(&quot;Response has already been committed&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;(5);</span><br><span class="line">        map.put(&quot;time&quot;, LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        map.put(&quot;flag&quot;, &quot;success_login&quot;);</span><br><span class="line">        User principal &#x3D; (User) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        String username &#x3D; principal.getUsername();</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities &#x3D; principal.getAuthorities();</span><br><span class="line">        Set&lt;String&gt; roles &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        if (CollectionUtil.isNotEmpty(authorities)) &#123;</span><br><span class="line">            for (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">                String roleName &#x3D; authority.getAuthority();</span><br><span class="line">                roles.add(roleName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JwtTokenPair jwtTokenPair &#x3D; jwtTokenGenerator.jwtTokenPair(username, roles, null);</span><br><span class="line"></span><br><span class="line">        map.put(&quot;access_token&quot;, jwtTokenPair.getAccessToken());</span><br><span class="line">        map.put(&quot;refresh_token&quot;, jwtTokenPair.getRefreshToken());</span><br><span class="line"></span><br><span class="line">        ResponseUtil.responseJsonWriter(response, RestBody.okData(map, &quot;登录成功&quot;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.2 AuthenticationFailureHandler 返回认证失败信息<br>AuthenticationFailureHandler 处理认证失败后的逻辑，前端根据此返回进行跳转处理逻辑，我们也实现它并注入 Spring IoC 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 失败登录处理器 处理登录失败后的逻辑 登录失败返回信息 以此为依据跳转</span><br><span class="line">*</span><br><span class="line">* @return the authentication failure handler</span><br><span class="line">*&#x2F;</span><br><span class="line">@Bean</span><br><span class="line">public AuthenticationFailureHandler authenticationFailureHandler() &#123;</span><br><span class="line">    return (request, response, exception) -&gt; &#123;</span><br><span class="line">        if (response.isCommitted()) &#123;</span><br><span class="line">            log.debug(&quot;Response has already been committed&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line"></span><br><span class="line">        map.put(&quot;time&quot;, LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));</span><br><span class="line">        map.put(&quot;flag&quot;, &quot;failure_login&quot;);</span><br><span class="line">        ResponseUtil.responseJsonWriter(response, RestBody.build(HttpStatus.UNAUTHORIZED.value(), map, &quot;认证失败&quot;,&quot;-9999&quot;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置<br>把上面写好的两个 Handler Bean 写入 登录配置，相关片断如下，详情参见文末 DEMO：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)</span><br></pre></td></tr></table></figure></li><li>验证<br>我们依然通过 Spring Security 实战干货： 玩转自定义登录 一文中章节 6.4 测试 来运行。结果如下：</li></ol><p>5.1 登录成功结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;httpStatus&quot;:200,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhbGwiLCJhdWQiOiJpY2hpbmciLCJyb2xlcyI6IltdIiwiaXNzIjoiaWNoaW5nIiwiZXhwIjoiMjAyMC0wMi0xMyAyMTozODo0OCIsImlhdCI6IjIwMjAtMDEtMTQgMjE6Mzg6NDgiLCJqdGkiOiIxYjAzY2E5ZGZhZTA0MWQzYTliM2I4ZGNhNmI4ZGU2NSJ9.nqDqf6RipGVS10o7_KnuvHD2nWhYhilL4fV1GxSbKagbRZV_z0saYILKGe30nNJUgFY-Kgx2yQqgOGHHAaRAG_q_3qOsGEs21NTzQz0WSIDcGI-ltOAjMQvB3DPKncwWFyeOz4BQiwFBw3wo8ARWzjGL-JsnwU4AG9pgDdExZuU&quot;,&quot;refresh_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhbGwiLCJhdWQiOiJpY2hpbmciLCJyb2xlcyI6IltdIiwiaXNzIjoiaWNoaW5nIiwiZXhwIjoiMjAyMC0wNC0xMyAyMTozODo0OCIsImlhdCI6IjIwMjAtMDEtMTQgMjE6Mzg6NDgiLCJqdGkiOiIxYjAzY2E5ZGZhZTA0MWQzYTliM2I4ZGNhNmI4ZGU2NSJ9.d43vsIO0pXRCE3jytOZPP3yKegMJlYn5o4sGMuDtC_IN0uDCZMwXTSsT63XiSUqTz3gzMwxbujyX7mS-d7FDergbH617W7OTUR1idkxtX-7GLUgCYnibBG-QNEp2ljfTF9s97hX281nAcxm7sMleaRt8xt0TJBv2LO9msZbGMDY&quot;,</span><br><span class="line">        &quot;time&quot;:&quot;2020-01-14 21:43:57&quot;,&quot;flag&quot;:&quot;success_login&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;:&quot;登录成功&quot;,</span><br><span class="line">    &quot;identifier&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们取 access_token 使用官网jwt.io 提供的解码功能进行解码如下：<br>5.2 登录失败结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;httpStatus&quot;: 401,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;time&quot;: &quot;2020-01-14 21:45:57&quot;,</span><br><span class="line">        &quot;flag&quot;: &quot;failure_login&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;: &quot;认证失败&quot;,</span><br><span class="line">    &quot;identifier&quot;: &quot;-9999&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>总结<br>今天我们将 JWT 和 Spring Security 联系了起来，实现了 登录成功后返回 JWT Token 。 这仅仅是一个开始，在下一篇我们将介绍 客户端如何使用 JWT Token 、服务端如何验证 JWT Token </li></ol><hr><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://www.felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/index.html" target="_blank" rel="noopener">https://www.felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/index.html</a><br><a href="https://docs.spring.io/spring-boot/docs/current/reference/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/</a><br><a href="https://docs.spring.io/spring-boot/docs/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/</a><br><a href="http://www.what21.com/u/10004/4895501825056762414.htm" target="_blank" rel="noopener">http://www.what21.com/u/10004/4895501825056762414.htm</a></p><h2 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h2><ol><li><p>前言<br>最近实在比较忙，很难抽出时间来继续更 Spring Security 实战干货系列。今天正好项目中 Spring Security 需要对认证授权异常的处理，就分享出来吧 。</p></li><li><p>Spring Security 中的异常<br>Spring Security 中的异常主要分为两大类：一类是认证异常，另一类是授权相关的异常。</p></li></ol><p>2.1 AuthenticationException<br>AuthenticationException 是在用户认证的时候出现错误时抛出的异常。主要的子类如图：<br><img src="/2020/01/11/SpringSecurity/main_callback.png" alt="SpringSecurity"></p><p>根据该图的信息，系统用户不存在，被锁定，凭证失效，密码错误等认证过程中出现的异常都由 AuthenticationException 处理。</p><p>2.2 AccessDeniedException<br>AccessDeniedException 主要是在用户在访问受保护资源时被拒绝而抛出的异常。同 AuthenticationException 一样它也提供了一些具体的子类。如下图：<br><img src="/2020/01/11/SpringSecurity/csrf.png" alt="SpringSecurity"></p><p>AccessDeniedException 的子类比较少，主要是 CSRF 相关的异常和授权服务异常。</p><ol start="3"><li>Http 状态对认证授权的规定<br>Http 协议对认证授权的响应结果也有规定。</li></ol><p>3.1 401 未授权状态<br>HTTP 401 错误 - 未授权(Unauthorized) 一般来说该错误消息表明您首先需要登录（输入有效的用户名和密码）。 如果你刚刚输入这些信息，立刻就看到一个 401 错误，就意味着，无论出于何种原因您的用户名和密码其中之一或两者都无效（输入有误，用户名暂时停用，账户被锁定，凭证失效等） 。总之就是认证失败了。其实正好对应我们上面的 AuthenticationException 。</p><p>3.2 403 被拒绝状态<br>HTTP 403 错误 - 被禁止(Forbidden) 出现该错误表明您在访问受限资源时没有得到许可。服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。并且服务器想让客户端知道为什么没有权限访问特定的资源，服务器应该在返回的信息中描述拒绝的理由。一般实践中我们会比较模糊的表明原因。 该错误对应了我们上面的 AccessDeniedException 。</p><ol start="4"><li>Spring Security 中的异常处理<br>我们在 Spring Security 实战干货系列文章中的 自定义配置类入口 WebSecurityConfigurerAdapter 一文中提到 HttpSecurity 提供的 exceptionHandling() 方法用来提供异常处理。该方法构造出 ExceptionHandlingConfigurer 异常处理配置类。该配置类提供了两个实用接口：</li></ol><p>AuthenticationEntryPoint 该类用来统一处理 AuthenticationException 异常<br>AccessDeniedHandler 该类用来统一处理 AccessDeniedException 异常<br>我们只要实现并配置这两个异常处理类即可实现对 Spring Security 认证授权相关的异常进行统一的自定义处理。</p><p>4.1 实现 AuthenticationEntryPoint<br>以 json 信息响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;todo your business</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line">        map.put(&quot;uri&quot;, request.getRequestURI());</span><br><span class="line">        map.put(&quot;msg&quot;, &quot;认证失败&quot;);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        String resBody &#x3D; objectMapper.writeValueAsString(map);</span><br><span class="line">        PrintWriter printWriter &#x3D; response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 实现 AccessDeniedHandler<br>同样以 json 信息响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleAccessDeniedHandler implements AccessDeniedHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;todo your business</span><br><span class="line">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line">        map.put(&quot;uri&quot;, request.getRequestURI());</span><br><span class="line">        map.put(&quot;msg&quot;, &quot;认证失败&quot;);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        String resBody &#x3D; objectMapper.writeValueAsString(map);</span><br><span class="line">        PrintWriter printWriter &#x3D; response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.3 个人实践建议<br>其实我个人建议 Http 状态码 都返回 200 而将 401 状态在 元信息 Map 中返回。因为异常状态码在浏览器端会以 error 显示。我们只要能捕捉到 401 和 403 就能认定是认证问题还是授权问题。</p><p>4.4 配置<br>实现了上述两个接口后，我们只需要在 WebSecurityConfigurerAdapter 的 configure(HttpSecurity http) 方法中配置即可。相关的配置片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling().accessDeniedHandler(new SimpleAccessDeniedHandler()).authenticationEntryPoint(new SimpleAuthenticationEntryPoint())</span><br></pre></td></tr></table></figure><hr><h2 id="使用-JWT-认证访问接口"><a href="#使用-JWT-认证访问接口" class="headerlink" title="使用 JWT 认证访问接口"></a>使用 JWT 认证访问接口</h2><ol><li><p>前言<br>欢迎阅读Spring Security 实战干货系列。之前我讲解了如何编写一个自己的 Jwt 生成器以及如何在用户认证通过后返回 Json Web Token 。今天我们来看看如何在请求中使用 Jwt 访问鉴权。DEMO 获取方法在文末。</p></li><li><p>常用的 Http 认证方式<br>我们要在 Http 请求中使用 Jwt 我们就必须了解 常见的 Http 认证方式。</p></li></ol><p>2.1 HTTP Basic Authentication<br>HTTP Basic Authentication 又叫基础认证，它简单地使用 Base64 算法对用户名、密码进行加密，并将加密后的信息放在请求头 Header 中，本质上还是明文传输用户名、密码，并不安全，所以最好在 Https 环境下使用。其认证流程如下：</p><p><img src="/2020/01/11/SpringSecurity/Basic.png" alt="Basic"></p><p>客户端发起 GET 请求 服务端响应返回 401 Unauthorized， www-Authenticate 指定认证算法，realm 指定安全域。然后客户端一般会弹窗提示输入用户名称和密码，输入用户名密码后放入 Header 再次请求，服务端认证成功后以 200 状态码响应客户端。</p><p>2.2 HTTP Digest Authentication<br>为弥补 BASIC 认证存在的弱点就有了 HTTP Digest Authentication 。它又叫摘要认证。它使用随机数加上 MD5 算法来对用户名、密码进行摘要编码，流程类似 Http Basic Authentication ，但是更加复杂一些:</p><p><img src="/2020/01/11/SpringSecurity/Digest.png" alt="Digest"></p><p>步骤1：跟基础认证一样，只不过返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需要的临时咨询码（随机数，nonce）。 首部字段WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现</p><p>步骤2：接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。首部字段 Authorization 内必须包含username、realm、nonce、uri 和 response 的字段信息，其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。</p><p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则会返回包含 Request-URI 资源的响应。</p><p>并且这时会在首部字段 Authorization-Info 写入一些认证成功的相关信息。</p><p>2.3 SSL 客户端认证<br>SSL 客户端认证就是通常我们说的 HTTPS 。安全级别较高，但需要承担 CA 证书费用。SSL 认证过程中涉及到一些重要的概念，数字证书机构的公钥、证书的私钥和公钥、非对称算法（配合证书的私钥和公钥使用）、对称密钥、对称算法（配合对称密钥使用）。相对复杂一些这里不过多讲述。</p><p>2.4 Form 表单认证<br>Form 表单的认证方式并不是HTTP规范。所以实现方式也呈现多样化，其实我们平常的扫码登录，手机验证码登录都属于表单登录的范畴。表单认证一般都会配合 Cookie，Session 的使用，现在很多 Web 站点都使用此认证方式。用户在登录页中填写用户名和密码，服务端认证通过后会将 sessionId 返回给浏览器端，浏览器会保存 sessionId 到浏览器的 Cookie 中。因为 HTTP 是无状态的，所以浏览器使用 Cookie 来保存 sessionId。下次客户端会在发送的请求中会携带 sessionId 值，服务端发现 sessionId 存在并以此为索引获取用户存在服务端的认证信息进行认证操作。认证过则会提供资源访问。</p><p>我们在Spring Security 实战干货：登录后返回 JWT Token 一文其实也是通过 Form 提交来获取 Jwt 其实 Jwt 跟 sessionId 同样的作用，只不过 Jwt 天然携带了用户的一些信息，而 sessionId 需要去进一步获取用户信息。</p><p>2.5 Json Web Token 的认证方式 Bearer Authentication<br>我们通过表单认证获取 Json Web Token ，那么如何使用它呢? 通常我们会把 Jwt 作为令牌使用 Bearer Authentication 方式使用。Bearer Authentication 是一种基于令牌的 HTTP 身份验证方案，用户向服务器请求访问受限资源时，会携带一个 Token 作为凭证，检验通过则可以访问特定的资源。最初是在 RFC 6750 中作为 OAuth 2.0 的一部分，但有时也可以单独使用。<br>我们在使用 Bear Token 的方法是在请求头的 Authorization 字段中放入 Bearer <token> 的格式的加密串(Json Web Token)。请注意 Bearer 前缀与 Token 之间有一个空字符位，与基本身份验证类似，Bearer Authentication 只能在HTTPS（SSL）上使用。</p><ol start="3"><li>Spring Security 中实现接口 Jwt 认证<br>接下来我们是我们该系列的重头戏 ———— 接口的 Jwt 认证。</li></ol><p>3.1 定义 Json Web Token 过滤器<br>无论上面提到的哪种认证方式，我们都可以使用 Spring Security 中的 Filter 来处理。 Spring Security 默认的基础配置没有提供对 Bearer Authentication 处理的过滤器， 但是提供了处理 Basic Authentication 的过滤器：</p><p>org.springframework.security.web.authentication.<a href="http://www.BasicAuthenticationFilter" target="_blank" rel="noopener">www.BasicAuthenticationFilter</a></p><p>BasicAuthenticationFilter 继承了 OncePerRequestFilter 。所以我们也模仿 BasicAuthenticationFilter 来实现自己的 JwtAuthenticationFilter 。 完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * jwt 认证拦截器 用于拦截 请求 提取jwt 认证</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Slf4j</span><br><span class="line"> public class JwtAuthenticationFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    private static final String AUTHENTICATION_PREFIX &#x3D; &quot;Bearer &quot;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 认证如果失败由该端点进行响应</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private AuthenticationEntryPoint authenticationEntryPoint &#x3D; new SimpleAuthenticationEntryPoint();</span><br><span class="line">    private JwtTokenGenerator jwtTokenGenerator;</span><br><span class="line">    private JwtTokenStorage jwtTokenStorage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public JwtAuthenticationFilter(JwtTokenGenerator jwtTokenGenerator, JwtTokenStorage jwtTokenStorage) &#123;</span><br><span class="line">        this.jwtTokenGenerator &#x3D; jwtTokenGenerator;</span><br><span class="line">        this.jwtTokenStorage &#x3D; jwtTokenStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果已经通过认证</span><br><span class="line">        if (SecurityContextHolder.getContext().getAuthentication() !&#x3D; null) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 获取 header 解析出 jwt 并进行认证 无token 直接进入下一个过滤器  因为  SecurityContext 的缘故 如果无权限并不会放行</span><br><span class="line">        String header &#x3D; request.getHeader(HttpHeaders.AUTHORIZATION);</span><br><span class="line">        if (StringUtils.hasText(header) &amp;&amp; header.startsWith(AUTHENTICATION_PREFIX)) &#123;</span><br><span class="line">            String jwtToken &#x3D; header.replace(AUTHENTICATION_PREFIX, &quot;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (StringUtils.hasText(jwtToken)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    authenticationTokenHandle(jwtToken, request);</span><br><span class="line">                &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">                    authenticationEntryPoint.commence(request, response, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 带安全头 没有带token</span><br><span class="line">                authenticationEntryPoint.commence(request, response, new AuthenticationCredentialsNotFoundException(&quot;token is not found&quot;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 具体的认证方法  匿名访问不要携带token</span><br><span class="line">    * 有些逻辑自己补充 这里只做基本功能的实现</span><br><span class="line">    *</span><br><span class="line">    * @param jwtToken jwt token</span><br><span class="line">    * @param request  request</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private void authenticationTokenHandle(String jwtToken, HttpServletRequest request) throws AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 根据我的实现 有效token才会被解析出来</span><br><span class="line">        JSONObject jsonObject &#x3D; jwtTokenGenerator.decodeAndVerify(jwtToken);</span><br><span class="line"></span><br><span class="line">        if (Objects.nonNull(jsonObject)) &#123;</span><br><span class="line">            String username &#x3D; jsonObject.getStr(&quot;aud&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 从缓存获取 token</span><br><span class="line">            JwtTokenPair jwtTokenPair &#x3D; jwtTokenStorage.get(username);</span><br><span class="line">            if (Objects.isNull(jwtTokenPair)) &#123;</span><br><span class="line">                if (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(&quot;token : &#123;&#125;  is  not in cache&quot;, jwtToken);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 缓存中不存在就算 失败了</span><br><span class="line">                throw new CredentialsExpiredException(&quot;token is not in cache&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            String accessToken &#x3D; jwtTokenPair.getAccessToken();</span><br><span class="line"></span><br><span class="line">            if (jwtToken.equals(accessToken)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 解析 权限集合  这里</span><br><span class="line">                JSONArray jsonArray &#x3D; jsonObject.getJSONArray(&quot;roles&quot;);</span><br><span class="line"></span><br><span class="line">                String roles &#x3D; jsonArray.toString();</span><br><span class="line"></span><br><span class="line">                List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(roles);</span><br><span class="line">                User user &#x3D; new User(username, &quot;[PROTECTED]&quot;, authorities);</span><br><span class="line">                &#x2F;&#x2F; 构建用户认证token</span><br><span class="line">                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken &#x3D; new UsernamePasswordAuthenticationToken(user, null, authorities);</span><br><span class="line">                usernamePasswordAuthenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                &#x2F;&#x2F; 放入安全上下文中</span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; token 不匹配</span><br><span class="line">                if (log.isDebugEnabled())&#123;</span><br><span class="line">                    log.debug(&quot;token : &#123;&#125;  is  not in matched&quot;, jwtToken);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                throw new BadCredentialsException(&quot;token is not matched&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(&quot;token : &#123;&#125;  is  invalid&quot;, jwtToken);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new BadCredentialsException(&quot;token is invalid&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看代码注释部分，逻辑有些地方根据你业务进行调整。匿名访问必然是不能带 Token 的！</p><p>3.2 配置 JwtAuthenticationFilter<br>首先将过滤器 JwtAuthenticationFilter 注入 Spring IoC 容器 ，然后一定要将 JwtAuthenticationFilter 顺序置于 UsernamePasswordAuthenticationFilter 之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.csrf().disable()</span><br><span class="line">    .cors()</span><br><span class="line">    .and()</span><br><span class="line">    &#x2F;&#x2F; session 生成策略用无状态策略</span><br><span class="line">    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">    .and()</span><br><span class="line">    .exceptionHandling().accessDeniedHandler(new SimpleAccessDeniedHandler()).authenticationEntryPoint(new SimpleAuthenticationEntryPoint())</span><br><span class="line">    .and()</span><br><span class="line">    .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    .addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">    &#x2F;&#x2F; jwt 必须配置于 UsernamePasswordAuthenticationFilter 之前</span><br><span class="line">    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">    &#x2F;&#x2F; 登录  成功后返回jwt token  失败后返回 错误信息</span><br><span class="line">    .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)</span><br><span class="line">    .and().logout().addLogoutHandler(new CustomLogoutHandler()).logoutSuccessHandler(new CustomLogoutSuccessHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 Jwt 进行请求验证<br>编写一个受限接口 ，我们这里是 <a href="http://localhost:8080/foo/test" target="_blank" rel="noopener">http://localhost:8080/foo/test</a> 。直接请求会被 401 。 我们通过下图方式获取 Token :</li><li>刷新 Jwt Token<br>我们在 Spring Security 实战干货：手把手教你实现JWT Token 中已经实现了 Json Web Token 都是成对出现的逻辑。accessToken 用来接口请求， refreshToken 用来刷新 accessToken 。我们可以同样定义一个 Filter 可参照 上面的 JwtAuthenticationFilter 。只不过 这次请求携带的是 refreshToken，我们在过滤器中拦截 URI跟我们定义的刷新端点进行匹配。同样验证 Token ，通过后像登录成功一样返回 Token 对即可</li></ol><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.csdn.net/nvluco/article/details/86406324" target="_blank" rel="noopener">https://blog.csdn.net/nvluco/article/details/86406324</a><br><a href="https://blog.csdn.net/a294634473/article/details/100930212" target="_blank" rel="noopener">https://blog.csdn.net/a294634473/article/details/100930212</a><br><a href="https://blog.csdn.net/wtdemeil/article/details/98486449" target="_blank" rel="noopener">https://blog.csdn.net/wtdemeil/article/details/98486449</a><br><a href="https://blog.csdn.net/killdrsa/article/details/89147431" target="_blank" rel="noopener">https://blog.csdn.net/killdrsa/article/details/89147431</a><br><a href="https://stackoverflow.com/questions/44171633/spring-boot-oauth2-access-is-denied-user-is-anonymous-redirecting-to-authen?rq=1" target="_blank" rel="noopener">https://stackoverflow.com/questions/44171633/spring-boot-oauth2-access-is-denied-user-is-anonymous-redirecting-to-authen?rq=1</a><br><a href="https://blog.csdn.net/Amor_Leo/article/details/101751690" target="_blank" rel="noopener">https://blog.csdn.net/Amor_Leo/article/details/101751690</a><br><a href="https://github.com/SophiaLeo/sophia_scaffolding" target="_blank" rel="noopener">https://github.com/SophiaLeo/sophia_scaffolding</a></p><hr><h2 id="RBAC权限控制概念的理解"><a href="#RBAC权限控制概念的理解" class="headerlink" title="RBAC权限控制概念的理解"></a>RBAC权限控制概念的理解</h2><ol><li><p>前言<br>欢迎阅读 Spring Security 实战干货系列文章 。截止到上一篇我们已经能够简单做到用户主体认证到接口的访问控制了，但是依然满足不了实际生产的需要。 如果我们需要一个完整的权限管理系统就必须了解一下 RBAC (Role-Based Access Control基于角色的访问控制) 的权限控制模型。</p></li><li><p>为什么需要 RBAC？<br>在正式讨论 RBAC 模型之前，我们要思考一个问题，为什么我们要做角色权限系统？ 答案很明显，一个系统肯定具有不同访问权限的用户。比如付费用户和非付费用户的权限，如果你是 QQ音乐的会员那么你能听高音质的歌曲，如果不是就不能享受某些便利的、优质的服务。那么这是一成不变的吗？又时候为了流量增长或者拉新的需要，我们又可能把一些原来充钱才能享受的服务下放给免费用户。如果你有了会员等级那就更加复杂了，VIP1 跟 VIP2 具有的功能肯定又有所差别了。主流的权限管理系统都是 RBAC 模型的变形和运用，只是根据不同的业务和设计方案，呈现不同的显示效果。<br>下图展示了用户和角色以及资源的简单关系：</p></li></ol><p>rbacflow.png</p><p>那为什么不直接给用户分配权限，还多此一举的增加角色这一环节呢？当然直接给用户具体的资源访问控制权限也不是不可以。只是这样做的话就少了一层关系，扩展性弱了许多。如果你的系统足够简单就不要折腾 RBAC 了，怎么简单就怎么玩。如果你的系统需要考虑扩展性和权限控制的多样性就必须考虑 RBAC 。<br>如果你有多个具有相同权限的用户，再分配权限的时候你就需要重复为用户去 Query (查询) 和 Add (赋予) 权限，如果你要修改，比如上面的 VIP1 增加一个很 Cool 的功能,你就要遍历 VIP1 用户进行修改。有了角色后，我们只需要为该角色制定好权限后，将相同权限的用户都指定为同一个角色即可，便于权限管理。<br>对于批量的用户权限调整，只需调整该用户关联的角色权限，无需遍历，既大幅提升权限调整的效率，又降低了漏调权限的概率。这样用户和资源权限解除了耦合性，这就是 RBAC 模型的优势所在。</p><ol start="3"><li>RBAC 模型的分类<br>RBAC 模型可以分为：RBAC0、RBAC1、RBAC2、RBAC3 四种。其中 RBAC0 是基础，其它三种都是在 RBAC0 基础上的变种。大部分情况下，使用 RBAC0 模型就可以满足常规的权限管理系统设计了。不过一定不要拘泥于模型，要以业务需要为先导。接下来简单对四种模型进行简单的介绍一下。</li></ol><p>3.1 RBAC0<br>RBAC0 是基础，定义了能构成 RBAC 权限控制系统的最小的集合，RBAC0 由四部分构成：</p><p>用户（User） 权限的使用主体</p><p>角色（Role） 包含许可的集合</p><p>会话（Session）绑定用户和角色关系映射的中间通道。而且用户必须通过会话才能给用户设置角色。</p><p>许可（Pemission） 对特定资源的特定的访问许可。</p><p>rbac0.png</p><p>3.2 RBAC1<br>RBAC1 在 RBAC0 的基础之上引入了角色继承的概念，有了继承那么角色就有了上下级或者等级关系。父角色拥有其子角色所有的许可。通俗讲就是来说： 你能干的，你的领导一定能干，反过来就不一定能行。</p><p>rbac1.png</p><p>3.3 RBAC2<br>在体育比赛中，你不可能既是运动员又是裁判员！</p><p>这是很有名的一句话。反应了我们经常出现的一种职务（其实也就是角色）冲突。有些角色产生的历史原因就是为了制约另一个角色，裁判员就是为了制约运动员从而让运动员按照规范去比赛。如果一个人兼任这两个角色，比赛必然容易出现不公正的情况从而违背竞技公平性准则。还有就是我们每个人在不同的场景都会充当不同的角色，在公司你就是特定岗位的员工，在家庭中你就是一名家庭成员。随着场景的切换，我们的角色也在随之变化。<br>所以 RBAC2 在 RBAC0 的基础上引入了静态职责分离（Static Separation of Duty，简称SSD）和动态职责分离（Dynamic Separation of Duty，简称DSD）两个约束概念。他们两个作用的生命周期是不同的;</p><p>SSD 作用于约束用户和角色绑定时。 1.互斥角色：就像上面的例子你不能既是A又是B，互斥的角色只能二选一 ; 2. 数量约束：用户的角色数量是有限的不能多于某个基数； 3. 条件约束：只能达到某个条件才能拥有某个角色。经常用于用户等级体系，只有你充钱成为VIP才能一刀999。<br>DSD 作用于会话和角色交互时。当用户持有多个角色，在用户通过会话激活角色时加以条件约束，根据不同的条件执行不同的策略。<br>图就不画了就是在 RBAC0 加了上述两个约束。</p><p>3.4 RBAC3<br>我全都要!</p><p>RBAC1 和 RBAC2 各有神通。当你拿着这两个方案给产品经理看时，他给了你一个坚定的眼神：我全都要！ 于是 RBAC3 就出现了。也就是说 RBAC3 = RBAC1 + RBAC2 。</p><ol start="4"><li>RBAC 中一些概念的理解<br>四个模型说完，我们来简单对其中的一些概念进行进一步的了解。</li></ol><p>4.1 用户（User）<br>对用户的理解不应该被局限于单个用户，也可以是用户组（类似 linux 的 User Group）, 或许还有其它的名字比如部门或者公司；也可以是虚拟的账户，客户，甚至说第三方应用也可以算用户 。所以对用户的理解要宽泛一些，只要是有访问资源需求的主体都可以纳入用户范畴。</p><p>4.2 角色（Role）<br>角色是特定许可的集合以及载体。一个角色可以包含多个用户，一个用户同样的也可以属于多个角色；同样的一个角色可以包含多个用户组，一个用户组也可以具有多个角色，所以角色和用户是多对多的关系。角色是可以细分的，也就是可以继承、可以分组的。</p><p>4.3 许可（Permission）<br>许可一般称它为权限。通常我们将访问的目标统称为资源，不管是数据还是静态资源都是资源。我们访问资源基本上又通过 api 接口来访问。所以一般权限都体现在对接口的控制上。再细分的话我将其划分为菜单控制，具体数据增删改查功能控制（前台体现为按钮）。另外许可具有原子性，不可再分。我们将许可授予角色时就是粒度最小的单元。</p><ol start="5"><li>总结<br>基于角色的访问控制（RBAC）已成为高级访问控制的主要方法之一。通过RBAC，您可以控制最终用户在广义和精细级别上可以做什么。您可以指定用户是管理员，专家用户还是最终用户，并使角色和访问权限与组织中员工的职位保持一致。仅根据需要为员工完成工作的足够访问权限来分配权限。通过上面的介绍相信一定会让你有所收获。对我接下来的 Spring Security 实战干货 集成 RBAC 也是提前预一下热。其实不管你使用什么安全框架， RBAC 都是必须掌握的</li></ol><hr><h2 id="基于配置的接口角色访问控制"><a href="#基于配置的接口角色访问控制" class="headerlink" title="基于配置的接口角色访问控制"></a>基于配置的接口角色访问控制</h2><ol><li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。对于受限的访问资源，并不是对所有认证通过的用户开放的。比如 A 用户的角色是会计，那么他就可以访问财务相关的资源。B 用户是人事，那么他只能访问人事相关的资源。我们在 一文中也对基于角色的访问控制的相关概念进行了探讨。在实际开发中我们如何对资源进行角色粒度的管控呢？今天我来告诉你 Spring Security 是如何来解决这个问题的。</p></li><li><p>将角色写入 UserDetails<br>我们使用 UserDetailsService 加载 UserDetails 时也会把用户的 GrantedAuthority 权限集写入其中。你可以将角色持久化并在这个点进行注入然后配置访问策略，后续的问题交给 Spring Security 。</p></li><li><p>在 HttpSecurity 中进行配置角色访问控制<br>我们可以通过配置 WebSecurityConfigurerAdapter 中的 HttpSecurity 来控制接口的角色访问。</p></li></ol><p>3.1 通过判断用户是否持有角色来进行访问控制<br>httpSecurity.authorizeRequests().antMatchers(“/foo/test”).hasRole(“ADMIN”)</p><p>表示 持有 ROLE_ADMIN 角色的用户才能访问 /foo/test 接口。注意：hasRole(String role) 方法入参不能携带前缀 ROLE_ 。我们来查看 SecurityExpressionRoot 中相关源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasRole(String role) &#123;</span><br><span class="line">    return hasAnyRole(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显 hasRole 方法源于 hasAnyRole (持有任何其中角色之一，就能满足访问条件，用于一个接口开放给多个角色访问时) :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasAnyRole(String... roles) &#123;</span><br><span class="line">    return hasAnyAuthorityName(defaultRolePrefix, roles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个接口开放给多个角色，比如 /foo/test 开放给了 ROLE_APP 和 ROLE_ADMIN 可以这么写：</p><p>httpSecurity.authorizeRequests().antMatchers(“/foo/test”).hasAnyRole(“APP”,”ADMIN”)</p><p>hasAnyRole 方法最终的实现为 hasAnyAuthorityName(String prefix, String… roles):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private boolean hasAnyAuthorityName(String prefix, String... roles) &#123;</span><br><span class="line">    Set&lt;String&gt; roleSet &#x3D; getAuthoritySet();</span><br><span class="line"></span><br><span class="line">    for (String role : roles) &#123;</span><br><span class="line">        String defaultedRole &#x3D; getRoleWithDefaultPrefix(prefix, role);</span><br><span class="line">        if (roleSet.contains(defaultedRole)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面才是根本的实现, 需要一个 prefix 和每一个 role 进行拼接，然后用户的角色集合 roleSet 中包含了就返回true 放行，否则就 false 拒绝。默认的 prefix 为 defaultRolePrefix= ROLE_ 。</p><p>3.2 通过判断用户的 GrantedAuthority 来进行访问控制<br>我们也可以通过 hasAuthority 和 hasAnyAuthority 来判定。 其实底层实现和 hasAnyRole 方法一样，只不过 prefix 为 null 。也就是你写入的 GrantedAuthority 是什么样子的，这里传入参数的就是什么样子的，不再受 ROLE_ 前缀的制约。</p><p>2.1 章节的写法等同如下的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).hasAuthority(“ROLE_ADMIN”)</span><br><span class="line"></span><br><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).hasAnyAuthority(“ROLE_APP”,”ROLE_ADMIN”)</span><br></pre></td></tr></table></figure><ol start="4"><li>匿名访问<br>匿名身份验证的用户和未经身份验证的用户之间没有真正的概念差异。Spring Security 的匿名身份验证只是为您提供了一种更方便的方式来配置访问控制属性。所有的匿名用户都持有角色 ROLE_ANONYMOUS 。所以你可以使用 2.1 和 2.2 章节的方法来配置匿名访问:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).hasAuthority(“ROLE_ANONYMOUS”)</span><br></pre></td></tr></table></figure>你也可以通过以下方式进行配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).anonymous()</span><br></pre></td></tr></table></figure></li><li>开放请求<br>开放请求可以这么配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(“&#x2F;foo&#x2F;test”).permitAll()</span><br></pre></td></tr></table></figure></li><li>permitAll 与 anonymous 的一些探讨<br>开放请求 其实通常情况下跟 匿名请求 有交叉。它们的主要区别在于： 当前的 Authentication 为 null 时 permitAll 是放行的，而 anonymous 需要 Authentication 为 AnonymousAuthenticationToken 。这里是比较难以理解的，下面是来自 Spring 文档中的一些信息：</li></ol><p>通常，采用“默认拒绝”的做法被认为是一种良好的安全做法，在该方法中，您明确指定允许的内容，并禁止其他所有内容。定义未经身份验证的用户可以访问的内容的情况与此类似，尤其是对于Web应用程序。许多站点要求用户必须通过身份验证才能使用少数几个URL（例如，主页和登录页面）。在这种情况下，最简单的是为这些特定的URL定义访问配置属性，而不是为每个受保护的资源定义访问配置属性。换句话说，有时很高兴地说默认情况下需要ROLE_SOMETHING，并且只允许该规则的某些例外，例如应用程序的登录，注销和主页。您还可以从过滤器链中完全忽略这些页面，从而绕过访问控制检查，<br>这就是我们所说的匿名身份验证。</p><p>使用 permitAll() 将配置授权，以便在该特定路径上允许所有请求（来自匿名用户和已登录用户）,anonymous() 主要是指用户的状态（是否登录）。基本上，直到用户被“认证”为止，它就是“匿名用户”。就像每个人都有“默认角色”一样。</p><h2 id="基于注解的接口角色访问控制"><a href="#基于注解的接口角色访问控制" class="headerlink" title="基于注解的接口角色访问控制"></a>基于注解的接口角色访问控制</h2><ol><li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。在上一篇 基于配置的接口角色访问控制 我们讲解了如何通过 javaConfig 的方式配置接口的角色访问控制。其实还有一种更加灵活的配置方式 基于注解 。今天我们就来探讨一下。DEMO 获取方式在文末。</p></li><li><p>Spring Security 方法安全<br>Spring Security 基于注解的安全认证是通过在相关的方法上进行安全注解标记来实现的。</p></li></ol><p>2.1 开启全局方法安全<br>我们可以在任何 @Configuration实例上使用 @EnableGlobalMethodSecurity 注解来启用全局方法安全注解功能。该注解提供了三种不同的机制来实现同一种功能，所以我们单独开一章进行探讨。</p><ol start="3"><li><p>@EnableGlobalMethodSecurity 注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Retention(value &#x3D; java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value &#x3D; &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123; GlobalMethodSecuritySelector.class &#125;)</span><br><span class="line">@EnableGlobalAuthentication</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableGlobalMethodSecurity &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 基于表达式进行方法访问控制</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean prePostEnabled() default false;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 基于 @Secured 注解</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean securedEnabled() default false;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 基于 JSR-250 注解</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean jsr250Enabled() default false;</span><br><span class="line"></span><br><span class="line">    boolean proxyTargetClass() default false;</span><br><span class="line"></span><br><span class="line">    int order() default Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableGlobalMethodSecurity 源码中提供了 prePostEnabled 、securedEnabled 和 jsr250Enabled 三种方式。当你开启全局基于注解的方法安全功能时，也就是使用 @EnableGlobalMethodSecurity 注解时我们需要选择使用这三种的一种或者其中几种。我们接下来将分别介绍它们。</p></li><li><p>使用 prePostEnabled<br>如果你在 @EnableGlobalMethodSecurity 设置 prePostEnabled 为 true ，则开启了基于表达式的方法安全控制。通过表达式运算结果的布尔值来决定是否可以访问（true 开放， false 拒绝 ）。<br>有时您可能需要执行开启 prePostEnabled 复杂的操作。对于这些实例，您可以扩展 GlobalMethodSecurityConfiguration，确保子类上存在@EnableGlobalMethodSecurity(prePostEnabled = true) 。例如，如果要提供自定义 MethodSecurityExpressionHandler :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)</span><br><span class="line">public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected MethodSecurityExpressionHandler createExpressionHandler() &#123;</span><br><span class="line">        &#x2F;&#x2F; ... create and return custom MethodSecurityExpressionHandler ...</span><br><span class="line">        return expressionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例属于高级操作，一般没有必要。无论是否继承GlobalMethodSecurityConfiguration 都将会开启四个注解。 @PreAuthorize 和 @PostAuthorize 侧重于方法调用的控制；而 @PreFilter 和 @PostFilter 侧重于数据的控制。</p></li></ol><p>4.1 @PreAuthorize<br>在标记的方法调用之前，通过表达式来计算是否可以授权访问。接下来我来总结以下常用的表达式。</p><p>基于 SecurityExpressionOperations 接口的表达式，也就是我们在上一文的 javaConfig 配置。示例： @PreAuthorize(“hasRole(‘ADMIN’)”) 必须拥有 ROLE_ADMIN 角色。<br>基于 UserDetails 的表达式，此表达式用以对当前用户的一些额外的限定操作。示例：@PreAuthorize(“principal.username.startsWith(‘Felordcn’)”) 用户名开头为 Felordcn 的用户才能访问。<br>基于对入参的 SpEL表达式处理。关于 SpEL 表达式可参考官方文档。或者通过关注公众号：Felordcn 来获取相关资料。 示例： @PreAuthorize(“#id.equals(principal.username)”) 入参 id 必须同当前的用户名相同。<br>4.2 @PostAuthorize<br>在标记的方法调用之后，通过表达式来计算是否可以授权访问。该注解是针对 @PreAuthorize 。区别在于先执行方法。而后进行表达式判断。如果方法没有返回值实际上等于开放权限控制；如果有返回值实际的结果是用户操作成功但是得不到响应。</p><p>4.3 @PreFilter<br>基于方法入参相关的表达式，对入参进行过滤。分页慎用！该过程发生在接口接收参数之前。 入参必须为 java.util.Collection 且支持 remove(Object) 的参数。如果有多个集合需要通过 filterTarget=&lt;参数名&gt; 来指定过滤的集合。内置保留名称 filterObject 作为集合元素的操作名来进行评估过滤。</p><p>样例：</p><p>// 入参为Collection<String> ids   测试数据 [“Felordcn”,”felord”,”jetty”]</p><p>// 过滤掉  felord jetty  为  Felordcn<br>@PreFilter(value = “filterObject.startsWith(‘F’)”,filterTarget = “ids”)<br>// 如果 当前用户持有 ROLE_AD 角色  参数都符合  否则 过滤掉不是 f 开头的<br>// DEMO 用户不持有 ROLE_AD 角色  故而 集合只剩下 felord<br>@PreFilter(“hasRole(‘AD’) or filterObject.startsWith(‘f’)”)<br>4.4 @PostFilter<br>和@PreFilter 不同的是， 基于返回值相关的表达式，对返回值进行过滤。分页慎用！该过程发生接口进行数据返回之前。 相关测试与 @PreFilter 相似，参见文末提供的 DEMO。</p><ol start="5"><li>使用 securedEnabled<br>如果你在 @EnableGlobalMethodSecurity 设置 securedEnabled 为 true ，就开启了角色注解 @Secured ，该注解功能要简单的多，默认情况下只能基于角色（默认需要带前缀 ROLE_）集合来进行访问控制决策。</li></ol><p>该注解的机制是只要其声明的角色集合（value）中包含当前用户持有的任一角色就可以访问。也就是 用户的角色集合和 @Secured 注解的角色集合要存在非空的交集。 不支持使用 SpEL 表达式进行决策。</p><ol start="6"><li>使用 jsr250Enabled<br>启用 JSR-250 安全控制注解，这属于 JavaEE 的安全规范（现为 jakarta 项目）。一共有五个安全注解。如果你在 @EnableGlobalMethodSecurity 设置 jsr250Enabled 为 true ，就开启了 JavaEE 安全注解中的以下三个：</li></ol><p>@DenyAll 拒绝所有的访问<br>@PermitAll 同意所有的访问<br>@RolesAllowed 用法和 5. 中的 @Secured 一样。<br>7. 总结<br>今天讲解了 Spring Security 另一种基于注解的静态配置。相比较基于 javaConfig 的方式要灵活一些、粒度更细、基于 SpEL 表达式可以实现更加强大的功能。但是这两种的方式还是基于编程的静态方式，具有一定的局限性。更加灵活的方式应该是动态来处理用户的角色和资源的映射关系</p><hr><h2 id="SecurityContext相关的知识"><a href="#SecurityContext相关的知识" class="headerlink" title="SecurityContext相关的知识"></a>SecurityContext相关的知识</h2><ol><li><p>前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。在前两篇我们讲解了 基于配置 和 基于注解 来配置访问控制。今天我们来讲一下如何在接口访问中检索当前认证用户信息。<br>我们先讲一下具体的场景。通常我们在认证后访问需要认证的资源时需要获取当前认证用户的信息。比如 “查询我的个人信息”。如果你直接在接口访问时显式的传入你的 UserID 肯定是不合适的。因为你认证通过后访问资源，系统是知道你是谁的。而且显式的暴露用户的检索接口也不安全。所以我们需要一个业务中可以检索当前认证用户的工具。 接下来我们来看看 Spring Security 是如何解决这个痛点的。</p></li><li><p>安全上下文 SecurityContext<br>不知道你有没有留意Spring Security 实战干货：使用 JWT 认证访问接口 中是如何实现 JWT 认证拦截器 JwtAuthenticationFilter 。当服务端对 JWT Token 认证通过后，会将认证用户的信息封装到 UsernamePasswordAuthenticationToken 中 并使用工具类放入安全上下文 SecurityContext 中，当服务端响应用户后又使用同一个工具类将 UsernamePasswordAuthenticationToken 从 SecurityContext 中 clear 掉。<br>我们来简单了解 SecurityContext 具体是个什么东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.security.core.context;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import org.springframework.security.core.Authentication;</span><br><span class="line"></span><br><span class="line">public interface SecurityContext extends Serializable &#123;</span><br><span class="line">    Authentication getAuthentication();</span><br><span class="line"></span><br><span class="line">    void setAuthentication(Authentication var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码上来看很简单就是一个 存储 Authentication 的容器。而 Authentication 是一个用户凭证接口用来作为用户认证的凭证使用，通常常用的实现有 认证用户 UsernamePasswordAuthenticationToken 和 匿名用户AnonymousAuthenticationToken。其中 UsernamePasswordAuthenticationToken 包含了 UserDetails , AnonymousAuthenticationToken 只包含了一个字符串 anonymousUser 作为匿名用户的标识。我们通过 SecurityContext 获取上下文时需要来进行类型判断。接下来我们来聊聊操作 SecurityContext 的工具类。</p></li><li><p>SecurityContextHolder<br>这个工具类就是 SecurityContextHolder 。 它提供了两个有用的方法：</p></li></ol><p>setContext 设置当前的 SecurityContext<br>getContext 获取当前的 SecurityContext , 进而你可以获取到当前认证用户。<br>clearContext 清除当前的 SecurityContext<br>平常我们通过这三个方法来操作安全上下文 SecurityContext 。你可以直接在代码中使用工具类 SecurityContextHolder 获取用户信息，像下面一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> public String getCurrentUser() &#123;</span><br><span class="line">    Authentication authentication &#x3D; SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">     if (authentication instanceof AnonymousAuthenticationToken)&#123;</span><br><span class="line">         return &quot;anonymousUser&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">    UserDetails principal &#x3D; (UserDetails) authentication.getPrincipal();</span><br><span class="line">    return principal.getUsername();</span><br><span class="line"> &#125;  </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">通过上面的自定义方法就可以解析到 UserDetails 的用户信息,你可以扩展 UserDetails 使得信息符合你的业务需要。上面方法中的判断是必须的，如果是匿名用户（AnonymousAuthenticationToken）返回的 Principal 类型是一个字符串 anonymousUser 。</span><br><span class="line"></span><br><span class="line">3.1 扩展知识：SecurityContextHolder 存储策略</span><br><span class="line">这里也扩展一下知识面，简单讲一下 SecurityContextHolder 是如何存储 SecurityContext 的。SecurityContextHolder 默认有三种存储 SecurityContext 的策略：</span><br><span class="line"></span><br><span class="line">MODE_THREADLOCAL 利用ThreadLocal 机制来保存每个使用者的 SecurityContext，缺省策略，平常我们使用这个就行了。</span><br><span class="line">MODE_INHERITABLETHREADLOCAL 利用InheritableThreadLocal 机制来保存每个使用者的 SecurityContext。多用于多线程环境环境下。</span><br><span class="line">MODE_GLOBAL 静态机制，作用域为全局。目前不太常用。</span><br><span class="line">4. 总结</span><br><span class="line">SecurityContext 是 Spring Security 中的一个非常重要类，今天不但介绍 SecurityContext 是什么、有什么作用，也对以前讲过的一些知识进行回顾。</span><br><span class="line">也对如何使用 SecurityContextHolder 操作 SecurityContext 进行了讲解。最后也简单讲述了 SecurityContextHolder 三种存储 SecurityContext 的策略和使用场景 </span><br><span class="line"></span><br><span class="line">## 动态权限控制（上）思路</span><br><span class="line">1. 前言</span><br><span class="line">欢迎阅读 Spring Security 实战干货系列文章 。截止目前已经对 基于配置 和 基于注解 的角色访问控制进行了讲解。对于一些小项目来说基本是够用的。然而如果希望运营管理人员能够动态的配置和分配权限，以上两种方式显然是满足不了需求的。接下来我们来一起探讨一下思路。</span><br><span class="line"></span><br><span class="line">2. 动态的权限控制同样依赖 RBAC 模型</span><br><span class="line">我们依然应该在 RBAC 及其变种的基础上构建动态的权限控制系统。所有被访问的目标，无论是 API、静态资源都应该是关联了角色的东西统称为 资源（Resource）。我们需要建立起角色和资源之间的关系。</span><br><span class="line"></span><br><span class="line">2.1 资源映射到角色</span><br><span class="line">下面是一个资源到角色的映射关系图：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模型大致如上所示，每一个资源对应一个可能无重复的角色集（Set 集合）；你可以注意到一个细节 Role 1 既指向 Resource 1 又指向 Resource 2 中，这是可以理解的，毕竟有可能对同一资源的访问权可能分散到多个角色中去；当然也可以互斥这取决于你的业务。</span><br><span class="line">我们选择资源映射到角色是因为当请求时，资源是唯一的而角色可能是多个，如果进行反转的话解析的效率低一些。</span><br><span class="line"></span><br><span class="line">3. 请求认证过程</span><br><span class="line">这里有很多搞法，但是总体的思路是我们的请求肯定是带下面两个东西（起码在走到进行访问决策这一步是必须有的）：</span><br><span class="line"></span><br><span class="line">URI 访问资源必然要用 URI 来定位，我们同样通过 URI 来和资源接口进行匹配；最好是 Ant match，因为&#x2F;user&#x2F;1 和 &#x2F;user&#x2F;2 有可能访问的是同一个资源接口。如果你想避免这种情况，要么在开发规约中禁止这种风格，这样的好处是配置人员可以不必熟悉 Ant 风格；要么必须让配置人员掌握 Ant 风格。</span><br><span class="line">Principal ，Spring Security 中为 Authentication （认证主体），之前讲过的一个比较绕的概念，Spring Security 中的用户身份有两种 一种是 认证用户 另一种是 匿名用户 ，它们都包含角色。拿到角色到角色集进行匹配。</span><br><span class="line">然后我画了一个下面的图来更加清晰的展示一下流程：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 如何结合安全框架</span><br><span class="line">虽然本文是 Spring Security 系列的，但是我们如果使用其它安全框架或者自己研发安全框架都可以依据上面的思路。如果需要用编程语言总结一下就是我们需要两个接口来协同：</span><br><span class="line"></span><br><span class="line">获取资源角色关系这些元数据的接口 这是我们动态权限控制的基石，只有将角色和资源的映射关系接口化才能动态的进行权限控制。 这里没有唯一标准，根据你的业务来设计。</span><br><span class="line">对 Request 进行解析并和提取的元数据进行匹配的接口 这是我们动态权限控制的最终逻辑实现。 这里的规则同样也没有唯一标准</span><br><span class="line">抓住了这两点之后我们就非常了然了，无非实现一个具有这两种功能的 Filter ，注入安全框架的过滤链中的合适位置中。要么你可以自己造个轮子，要么你使用现在有的轮子。那么有没有现成的轮子呢？ 我一般建议如果你在造轮子前先看看你选型的安全框架有没有现成的轮子可用。当现成有轮子可用并且能够满足你的需要时往往能够事半功倍。如果没有合适的就造一个！</span><br><span class="line"></span><br><span class="line">5. 总结</span><br><span class="line">本篇主要理清一下动态权限所需要的一些要点，并对请求认证的过程进行了分析。最后对结合安全框架定制也提供了一些个人的见解。实现也写了大部分，之所以拆分成上下篇，因为理论和实现放在一篇的话实在有点篇幅过长，分成上篇理论、下篇实践更加合适</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 动态权限控制（下）实现</span><br><span class="line"></span><br><span class="line">1. Spring Security 提供的轮子</span><br><span class="line">Spring Security 实战干货：内置 Filter 全解析 中提到的第 32 个 Filter 不知道你是否有印象。它决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？ 它就是 FilterSecurityInterceptor ，正是我们需要的那个轮子。</span><br><span class="line"></span><br><span class="line">2. FilterSecurityInterceptor</span><br><span class="line">过滤器排行榜第 32 位！肩负对接口权限认证的重要职责。我们来看它的过滤逻辑：</span><br></pre></td></tr></table></figure><p>public void doFilter(ServletRequest request, ServletResponse response,<br>        FilterChain chain) throws IOException, ServletException {<br>    FilterInvocation fi = new FilterInvocation(request, response, chain);<br>    invoke(fi);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化了一个 FilterInvocation 然后被 invoke 方法处理：</span><br></pre></td></tr></table></figure><p>public void invoke(FilterInvocation fi) throws IOException, ServletException {<br>    if ((fi.getRequest() != null)<br>            &amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != null)<br>            &amp;&amp; observeOncePerRequest) {<br>        // filter already applied to this request and user wants us to observe<br>        // once-per-request handling, so don’t re-do security checking<br>        fi.getChain().doFilter(fi.getRequest(), fi.getResponse());<br>    }<br>    else {<br>        // first time this request being called, so perform security checking<br>        if (fi.getRequest() != null &amp;&amp; observeOncePerRequest) {<br>            fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);<br>        }</p><pre><code>    InterceptorStatusToken token = super.beforeInvocation(fi);    try {        fi.getChain().doFilter(fi.getRequest(), fi.getResponse());    }    finally {        super.finallyInvocation(token);    }    super.afterInvocation(token, null);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">每一次请求被 Filter 过滤都会被打上标记 FILTER_APPLIED，没有被打上标记的 走了父类的 beforeInvocation 方法然后再进入过滤器链，看上去是走了一个前置的处理。那么前置处理了什么呢?</span><br><span class="line">首先会通过 this.obtainSecurityMetadataSource().getAttributes(Object object) 拿受保护对象（就是当前请求的URI）所有的映射角色（ConfigAttribute 直接理解为角色的进一步抽象） 。然后使用访问决策管理器 AccessDecisionManager 进行投票决策来确定是否放行。 我们来看一下这两个接口。</span><br><span class="line"></span><br><span class="line">安全拦截器和“安全对象”模型参考：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. FilterInvocationSecurityMetadataSource</span><br><span class="line">这个接口是 FilterSecurityInterceptor 的属性，UML图如下：</span><br><span class="line"></span><br><span class="line">FilterInvocationSecurityMetadataSource 是一个标记接口，其抽象方法继承自 SecurityMetadataSource&#96;&#96;AopInfrastructureBean 。它的作用是来获取我们上一篇文章所描述的资源角色元数据。</span><br><span class="line"></span><br><span class="line">Collection getAttributes(Object object) 根据提供的受保护对象的信息，其实就是URI，获取该URI 配置的所有角色</span><br><span class="line">Collection getAllConfigAttributes() 这个就是获取全部角色</span><br><span class="line">boolean supports(Class&lt;?&gt; clazz) 对特定的安全对象是否提供 ConfigAttribute 支持</span><br><span class="line">3.1 自定义实现 FilterInvocationSecurityMetadataSource 的思路分析</span><br><span class="line">所有的思路仅供参考，实际以你的业务为准！</span><br><span class="line"></span><br><span class="line">Collection&lt;ConfigAttribute&gt; getAttributes(Object object) 方法的实现：肯定是获取请求中的 URI 来和 所有的 资源配置中的 Ant Pattern 进行匹配以获取对应的资源配置, 这里需要将资源查询接口查询的资源配置封装为 AntPathRequestMatcher以方便进行 Ant Match 。</span><br><span class="line">这里需要特别提一下如果你使用 Restful 风格，这里 增删改查 将非常方便你来对资源的管控。参考的实现：</span><br></pre></td></tr></table></figure><p> @Bean<br> public RequestMatcherCreator requestMatcherCreator() {<br>   return metaResources -&gt; metaResources.stream()<br>           .map(metaResource -&gt; new AntPathRequestMatcher(metaResource.getPattern(), metaResource.getMethod()))<br>           .collect(Collectors.toSet());<br> }<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest 匹配到对应的资源配置后就能根据资源配置去取对应的角色集合。这些角色将交给访问决策管理器 AccessDecisionManager 进行投票表决以决定是否放行。</span><br><span class="line"></span><br><span class="line">4. AccessDecisionManager</span><br><span class="line">决策管理器，用来投票决定是否放行请求。</span><br></pre></td></tr></table></figure><br>  public interface AccessDecisionManager {<br>    // 决策 主要通过其持有的 AccessDecisionVoter 来进行投票决策<br>       void decide(Authentication authentication, Object object,<br>               Collection<ConfigAttribute> configAttributes) throws AccessDeniedException,<br>               InsufficientAuthenticationException;<br>   // 以确定AccessDecisionManager是否可以处理传递的ConfigAttribute<br>       boolean supports(ConfigAttribute attribute);<br>   //以确保配置的AccessDecisionManager支持安全拦截器将呈现的安全 object 类型。<br>       boolean supports(Class&lt;?&gt; clazz);<br>   }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">AccessDecisionManager 有三个默认实现：</span><br><span class="line"></span><br><span class="line">AffirmativeBased 基于肯定的决策器。 用户持有一个同意访问的角色就能通过。</span><br><span class="line">ConsensusBased 基于共识的决策器。 用户持有同意的角色数量多于禁止的角色数。</span><br><span class="line">UnanimousBased 基于一致的决策器。 用户持有的所有角色都同意访问才能放行。</span><br><span class="line">投票决策模型参考：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.1 自定义 AccessDecisionManager</span><br><span class="line">动态控制权限就需要我们实现自己的访问决策器。我们上面说了默认有三个实现，这里我选择基于肯定的决策器 AffirmativeBased，只要用户持有一个持有一个角色包含想要访问的资源就能访问该资源。接下来就是投票器 AccessDecisionVoter 的定义了，其实我们可以选择内置的</span><br><span class="line"></span><br><span class="line">5. AccessDecisionVoter</span><br><span class="line">AccessDecisionVoter 将安全配置属性 ConfigAttribute 以特定的逻辑进行解析并基于特定的策略来进行投票，投赞成票时总票数 +1 ，反对票总票数 -1 ，弃权时总票数 +0 , 然后由 AccessDecisionManager 根据具体的计票策略来决定是否放行。</span><br><span class="line"></span><br><span class="line">5.1 角色投票器 RoleVoter</span><br><span class="line">Spring Security 提供的最常用的投票器是角色投票器 RoleVoter，它将安全配置属性 ConfigAttribute 视为简单的角色名称，并在用户被分配了该角色时授予访问权限。</span><br><span class="line">如果任何 ConfigAttribute 以前缀 ROLE_ 开头，它将投票。如果有一个 GrantedAuthority 返回一个字符串(通过 getAuthority() 方法)正好等于一个或多个从前缀 ROLE_ 开始的 ConfigAttributes，它将投票授予访问权限。如果没有任何以 ROLE_开头的 ConfigAttributes匹配，则 RoleVoter 将投票拒绝访问。如果没有 ConfigAttribute 以ROLE_为前缀，将弃权。</span><br><span class="line">这正是我们想要的投票器。</span><br><span class="line"></span><br><span class="line">5.2 角色分层投票器 RoleHierarchyVoter</span><br><span class="line">通常要求应用程序中的特定角色应自动“包含”其他角色。例如，在具有 ROLE_ADMIN 和 ROLE_USER 角色概念的应用中，您可能希望管理员能够执行普通用户可以执行的所有操作。你不得不进行各种复杂的逻辑嵌套来满足这一需求。现在幸好有了 RoleHierarchyVoter 可以帮你减少这种负担。</span><br><span class="line">它由上面的 RoleVoter 派生,通过配置了一个 RoleHierarchy就可以实现 ROLE_ADMIN ⇒ ROLE_STAFF ⇒ ROLE_USER ⇒ ROLE_GUEST 这种层次包含结构，左边的一定能访问右边可以访问的资源。具体的配置规则为：角色从左到右、从高到低以 &gt; 相连（注意两个空格），以换行符 \n 为分割线。举个例子</span><br><span class="line"></span><br><span class="line">   ROLE_ADMIN &gt; ROLE_STAFF</span><br><span class="line">   ROLE_STAFF &gt; ROLE_USER</span><br><span class="line">   ROLE_USER &gt; ROLE_GUEST</span><br><span class="line">请注意动态配置中你需要自行实现角色分层的逻辑。DEMO 中并未对该风格进行实现。</span><br><span class="line"></span><br><span class="line">6. 配置</span><br><span class="line">配置需要两个方面。</span><br><span class="line"></span><br><span class="line">6.1 自定义组件的配置</span><br><span class="line">我们需要将元数据加载器 和 访问决策器注入 Spring IoC ：</span><br></pre></td></tr></table></figure><p> /**</p><ul><li><p>动态权限组件配置</p></li><li></li><li><p>@author Felordcn</p></li><li><p>/<br>@Configuration<br>public class DynamicAccessControlConfiguration {<br>  /**</p><ul><li><p>RequestMatcher 生成器</p></li><li><p>@return RequestMatcher</p></li><li><p>/<br>@Bean<br>public RequestMatcherCreator requestMatcherCreator() {<br>  return metaResources -&gt; metaResources.stream()</p><pre><code>.map(metaResource -&gt; new AntPathRequestMatcher(metaResource.getPattern(), metaResource.getMethod())).collect(Collectors.toSet());</code></pre><p>}</p><p>/**</p></li><li><p>元数据加载器</p></li><li></li><li><p>@return dynamicFilterInvocationSecurityMetadataSource</p></li><li><p>/<br>@Bean<br>public FilterInvocationSecurityMetadataSource dynamicFilterInvocationSecurityMetadataSource() {<br>  return new DynamicFilterInvocationSecurityMetadataSource();<br>}</p><p>/**</p></li><li><p>角色投票器</p></li><li><p>@return roleVoter</p></li><li><p>/<br>@Bean<br>public RoleVoter roleVoter() {<br>  return new RoleVoter();<br>}</p><p>/**</p></li><li><p>基于肯定的访问决策器</p></li><li></li><li><p>@param decisionVoters  AccessDecisionVoter类型的 Bean 会自动注入到 decisionVoters</p></li><li><p>@return affirmativeBased</p></li><li><p>/<br>@Bean<br>public AccessDecisionManager affirmativeBased(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters) {<br>  return new AffirmativeBased(decisionVoters);<br>}</p></li></ul><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring Security 的 Java Configuration 不会公开它配置的每个 object 的每个 property。这简化了大多数用户的配置。</span><br><span class="line">虽然有充分的理由不直接公开每个 property，但用户可能仍需要像本文一样的取实现个性化需求。为了解决这个问题，Spring Security 引入了 ObjectPostProcessor 的概念，它可用于修改或替换 Java Configuration 创建的许多 Object 实例。 FilterSecurityInterceptor 的替换配置正是通过这种方式来进行：</span><br></pre></td></tr></table></figure><p>@Configuration<br>@ConditionalOnClass(WebSecurityConfigurerAdapter.class)<br>@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)<br>public class CustomSpringBootWebSecurityConfiguration {<br> private static final String LOGIN_PROCESSING_URL = “/process”;</p><p> /**</p><ul><li><p>Json login post processor json login post processor.</p></li><li></li><li><p>@return the json login post processor</p></li><li><p>/<br>@Bean<br>public JsonLoginPostProcessor jsonLoginPostProcessor() {<br>  return new JsonLoginPostProcessor();<br>}</p><p>/**</p></li><li><p>Pre login filter pre login filter.</p></li><li></li><li><p>@param loginPostProcessors the login post processors</p></li><li><p>@return the pre login filter</p></li><li><p>/<br>@Bean<br>public PreLoginFilter preLoginFilter(Collection<LoginPostProcessor> loginPostProcessors) {<br>  return new PreLoginFilter(LOGIN_PROCESSING_URL, loginPostProcessors);<br>}</p><p>/**</p></li><li><p>Jwt 认证过滤器.</p></li><li></li><li><p>@param jwtTokenGenerator jwt 工具类 负责 生成 验证 解析</p></li><li><p>@param jwtTokenStorage   jwt 缓存存储接口</p></li><li><p>@return the jwt authentication filter</p></li><li><p>/<br>@Bean<br>public JwtAuthenticationFilter jwtAuthenticationFilter(JwtTokenGenerator jwtTokenGenerator, JwtTokenStorage jwtTokenStorage) {<br>  return new JwtAuthenticationFilter(jwtTokenGenerator, jwtTokenStorage);<br>}</p><p>/**</p></li><li><p>The type Default configurer adapter.</p></li><li><p>/<br>@Configuration<br>@Order(SecurityProperties.BASIC_AUTH_ORDER)<br>static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter {</p><p>  @Autowired<br>  private JwtAuthenticationFilter jwtAuthenticationFilter;<br>  @Autowired<br>  private PreLoginFilter preLoginFilter;<br>  @Autowired<br>  private AuthenticationSuccessHandler authenticationSuccessHandler;<br>  @Autowired<br>  private AuthenticationFailureHandler authenticationFailureHandler;<br>  @Autowired<br>  private FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;<br>  @Autowired<br>  private AccessDecisionManager accessDecisionManager;</p><p>  @Override<br>  protected void configure(AuthenticationManagerBuilder auth) throws Exception {</p><pre><code>super.configure(auth);</code></pre><p>  }</p><p>  @Override<br>  public void configure(WebSecurity web) {</p><pre><code>super.configure(web);</code></pre><p>  }</p><p>  @Override<br>  protected void configure(HttpSecurity http) throws Exception {</p><pre><code>http.csrf().disable()        .cors()        .and()        // session 生成策略用无状态策略        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)        .and()        .exceptionHandling().accessDeniedHandler(new SimpleAccessDeniedHandler()).authenticationEntryPoint(new SimpleAuthenticationEntryPoint())        .and()        //   动态权限配置        .authorizeRequests().anyRequest().authenticated().withObjectPostProcessor(filterSecurityInterceptorObjectPostProcessor())        .and()        .addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)        // jwt 必须配置于 UsernamePasswordAuthenticationFilter 之前        .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)        // 登录  成功后返回jwt token  失败后返回 错误信息        .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)        .and().logout().addLogoutHandler(new CustomLogoutHandler()).logoutSuccessHandler(new CustomLogoutSuccessHandler());</code></pre><p>  }</p><p>  /**</p><ul><li>自定义 FilterSecurityInterceptor  ObjectPostProcessor 以替换默认配置达到动态权限的目的</li><li></li><li>@return ObjectPostProcessor</li><li>/<br>private ObjectPostProcessor<FilterSecurityInterceptor> filterSecurityInterceptorObjectPostProcessor() {<br>  return new ObjectPostProcessor<FilterSecurityInterceptor>() {<pre><code>@Overridepublic &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) {    object.setAccessDecisionManager(accessDecisionManager);    object.setSecurityMetadataSource(filterInvocationSecurityMetadataSource);    return object;}</code></pre>  };<br>}</li></ul><p>}<br>}</p><pre><code>然后你编写一个 Controller 方法就将其在数据库注册为一个资源进行动态的访问控制了。无须注解或者更详细的 Java Config 配置。</code></pre></li></ul></li></ul><ol start="7"><li>总结<br>从最开始到现在一共10个 DEMO 。我们循序渐进地从如何学习 Spring Security 到目前实现了基于 RBAC、动态的权限资源访问控制。如果你能坚持到现在那么已经能满足了一些基本开发定制的需要。当然 Spring Security 还有很多局部的一些概念，我也会在以后抽时间进行讲解</li></ol><h2 id="纠正对-JSON-Web-Token-认识的误区"><a href="#纠正对-JSON-Web-Token-认识的误区" class="headerlink" title="纠正对 JSON Web Token 认识的误区"></a>纠正对 JSON Web Token 认识的误区</h2><p>1.前言<br>JSON Web Token (JWT) 其实目前已经广为软件开发者所熟知了，但是 JOSE (Javascript Object Signing and Encryption) 却鲜有人知道，我第一次知道它是在 Spring Security 的官方文档中，它改变了我对 JWT 的一些认识。目前国内能找到相关中文资料不是太多。所以我觉得有必要归纳一下。</p><ol start="2"><li>JOSE 概述<br>JOSE 是一种旨在提供在各方之间安全传递声明（claims）的方法的规范集。我们常用的 JWT 就包含了允许客户端访问特定应用下特定资源的声明。JOSE 制定了一系列的规范来达到此目的。目前该规范还在不断的发展，我们常用的包含以下几个 RFC :</li></ol><p>JWS（RFC 7515） -JSON Web签名，描述生成和处理签名消息<br>JWE（RFC 7516） -JSON Web加密，描述了保护和处理加密 消息<br>JWK（RFC 7517） -JSON Web密钥，描述 Javascript 对象签名和加密中加密密钥的 格式和处理<br>JWA（RFC 7518） -JSON Web算法，描述了 Javascript 对象签名和加密中使用的 加密 算法<br>JWT（RFC 7519） -JSON Web令牌，描述以 JSON 编码并由 JWS 或 JWE 保护的声明的表示形式<br>3. 我们都看错了 JWT<br>看了对 JWT 的描述中提到 “令牌以 JWS 或者 JWE 声明表示”。莫非我之前的认知是错误的吗？ 找了一些官方的资料研究了一番后，确实我之前的认知是不够全面的。</p><p>官方定义：</p><p>JSON Web Token (JWT) is a compact URL-safe means of representing claims to be transferred between two parties</p><p>直译过来：JSON Web令牌（JWT）是一种紧凑的URL安全方法，用于表示要在两方之间转移的声明。</p><p>也就是说我们通常说的 JWT 实际上是一个对声明进行 JOSE 处理方式的统称。我们之前用的应该叫 JWS(JSON Web Signature)，是 JWT 的一种实现，除了 JWS , JWT 还有另一种实现 JWE(JSON Web Encryption) 。它们之间的关系应该是这样的：</p><ol start="4"><li>什么是 JWE<br>JWS 我们就不说了，就是通常我们所说的 JWT。包括之前我在 Spring Security 实战干货 中所涉及到的 JWT 都是 JWS。我们来说一下 JWE 。JWS 仅仅是对声明(claims)作了签名，保证了其不被篡改，但是其 payload(中段负载) 信息是暴露的。也就是 JWS 仅仅能保证数据的完整性而不能保证数据不被泄露。所以我以前也说过它不适合传递敏感数据。<br>JWE 的出现就是为了解决这个问题的。具体的可以看下图：</li></ol><p>从上面可以看出 JWE 的生成非常繁琐，作为 Token 可能比较消耗资源和耗时。用作安全的数据传输途径应该不错。</p><ol start="5"><li>Spring Security jose 相关<br>这里需要简单提一下 Spring Security 提供了 JOSE 有关的类库 spring-security-oauth2-jose ，你可以使用该类库来使用 JOSE 。如果 Java 开发者要在 Spring Security 安全框架中使用 OAuth2.0 ，这个类库也是需要研究一下的。</li></ol><h2 id="简单的认识-OAuth2-0-协议"><a href="#简单的认识-OAuth2-0-协议" class="headerlink" title="简单的认识 OAuth2.0 协议"></a>简单的认识 OAuth2.0 协议</h2><p>1.前言<br>欢迎阅读 Spring Security 实战干货 系列文章 。OAuth2.0 是近几年比较流行的授权机制，对于普通用户来说可能每天你都在用它，我们经常使用的第三方登录大都基于 OAuth2.0。随着应用的互联互通，个性化服务之间的相互调用，开放性的认证授权成为 客观的需要。</p><ol start="2"><li>OAuth2.0 的简单认识<br>OAuth定义了如下角色，并明确区分了它们各自的关注点，以确保快速构建一致性的授权服务：</li></ol><p>Resource Owner 资源拥有者，通常指的是终端用户，其作用是同意或者拒绝、甚至是选择性的给第三方应用程序的授权请求。<br>User Agent 用户代理 指的的资源拥有者授权的一些渠道。一般指的是浏览器、APP<br>Client 请求授权和请求访问受限资源的客户端程序。<br>Authorization Server 对用户授权进行鉴别并根据鉴别结果进行同意或拒绝的授权响应的服务器。<br>Resource Server 能够接受和响应受保护资源请求的服务器。<br>单纯的文字性描述是不是有些难以理解。所以我这里讲一个亲身经历的事例来情景化以上的四个概念。马上又到程序员集中面试的季节了，有一年我去面试，到了地方才发现如此的“高大上”，访客需要通过验证码才能通过闸门，于是我联系了面试公司的HR ，后面的流程大概是这样的:</p><p>我向面试公司（HR）发送了一个进门的要求。<br>HR 给了我一个可以获取进门许可请求的链接。<br>我通过链接进行进门许可请求。<br>请求得到响应，返给我一个验证码。<br>我在闸门程序中输入验证码。<br>验证通过后放行。<br>在我学习了 OAuth2.0 协议之后我发现这次经历可以体现出 OAuth2.0 的一些设计理念。访客必须通过授权才能访问大楼。这种方式避免了闲杂人等出入办公场所，而且对访客可控（从访问时间和次数上），甚至可以实现对楼层的访问可控（当然上面的例子中没有）。<br>再结合 OAuth2.0 可以知道 访客就是 Client，公司（业主）就是 Resource Owner，物业就是 Authorization Server ，那个闸机就是 Resource Server，闸机有可能也受到物业的管控。 这是那张著名的流程图：</p><p>这个例子只是为了快速的来认识 OAuth2.0 ，它是一种有效的、可靠的委托授权框架。它提供了多种授权模式在不同的场景下供你选择。</p><ol start="3"><li>授权模式<br>为了获得访问许可，客户端需要向授权服务器出示有效的授权凭证，也就是说客户端必须得到用户授权（authorization grant）OAuth2.0 提供了多种授权模式供开发者在不同的场景中使用，以下是授权模式的一些总结：</li></ol><p>授权方式    客户端类型/用例<br>Authorization code    旨在用于具有后端的传统Web应用程序以及本机（移动或桌面）应用程序，以利用通过系统浏览器的单点登录功能。<br>Implicit    适用于不带后端的基于浏览器的（JavaScript）应用程序。<br>Password    对于应用程序和授权服务器属于同一提供程序的受信任本机客户端。<br>Client credentials    客户端以自己的名义来获取许可，而不是以终端用户名义，或者可以说该用户端也是资源拥有者<br>Refresh token    令牌失效后使客户端可以刷新其访问令牌，而不必再次执行代码或 密码授予的步骤。<br>SAML 2.0 bearer    使拥有SAML 2.0断言（登录令牌）的客户端将其交换为OAuth 2.0访问令牌。<br>JWT bearer    拥有一个安全域中的JSON Web令牌断言的客户端将其交换为另一域中的OAuth 2.0访问令牌。<br>Device code    设备的唯一编码，一般该编码不可更改，多用于一些智能设备<br>Token exchange    使用代理模拟的方式获取令牌<br>其中前五种为我们所熟知。我们后续会详细介绍它们。</p><ol start="4"><li>OAuth 2.0 的一些要点<br>摘自《OAuth 2 实战》：</li></ol><p>由于 OAuth2.0 被定义为一个框架，对于 OAuth2.0 是什么和不是什么，一直未明确。我们所说的 OAuth2.0 是指 OAuth2.0 核心规范中定义的协议，RFC 6749 核心规范详述了一系列获取访问令牌的方法；还包括其伴随规范中定义的 bearer 令牌，RFC 6750该规范规定了这种令牌的用法。获取令牌和使用令牌这两个环节是 OAuth2.0 的基本要素。正如我们将在本节中看到的，在更广泛的 OAuth2.0 生态系统中存在很多其他技术，它们配合 OAuth2.0 核心，提供更多 OAuth2.0 本身不能提供的功能。我们认为，这样的生态系统是协议健康发展的体现，但是不应与协议本身混为一谈。</p><p>基于以上的原则 OAuth2.0 有以下一些要点需要明确被认识到：</p><p>OAuth2.0 并非身份认证协议，虽然在授权的过程中涉及到身份认证，但是 OAuth2.0 协议本身并不处理用户的信息。客户端访问受保护的资源时并不关心资源的拥有者。<br>OAuth2.0 不提供一些消息签名，为了保证安全性所以不应脱离 Https 。在使用其它协议或者系统时也应该明确一个安全机制来承担 Https 所承担的任务。<br>OAuth2.0 并没有定义加密方式，虽然目前使用的较多的是 JOSE 规范<br>OAuth2.0 虽然令牌被客户端持有并使用，但是客户端并不能解析以及处理令牌。<br>5. 总结<br>OAuth2.0 其实还有个特点，它并不是单体协议。它被分成了多个定义和流程，每个定义和流程都有各自的应用场景</p><h2 id="OAuth2-0-技术选型参考"><a href="#OAuth2-0-技术选型参考" class="headerlink" title="OAuth2.0 技术选型参考"></a>OAuth2.0 技术选型参考</h2><ol><li><p>前言<br>在使用 OAuth2.0 中 Authorization Server （授权服务器）是一个回避不了的设施，在大多数情况下我们调用的是一些知名的、可靠的、可信任的第三方平台，比如 QQ、微信、微博、github 等。我们的应用只作为 Client 进行注册接入即可。也就是说我们只需要实现 OAuth2.0 客户端的逻辑就可以了，无须关心授权服务器的实现。然而有时候我们依然希望构建自己的 Authorization Server。我们应该如何实现？今天不会讨论具体的技术细节，来谈谈 OAuth2.0 的技术选型。</p></li><li><p>Spring Security OAuth2 现状<br>在做 Spring Security 相关教程 的时候首先会考虑 Spring 提供的 OAuth2.0 功能。当我去 Spring 官网了解相关的类库时发现居然 Spring 的 OAuth2.0 类库即将过期的通知，有图有真相：</p></li></ol><p>总结以下就是 Spring Security OAuth 的模块即将过期，后续的功能已经迁移到 Spring Security 5.2.x 中，但是不会再提供 Authorization Server 的功能。 在官方声明中还提到， 当前 Spring Security OAuth 分支是 2.3.x 和 2.4.x。2.3.x版本将于2020年3月达到停产期。我们将在达到功能均等后至少一年支持2.4.x版本。因此鼓励用户开始将其旧版 OAuth 2.0 客户端和资源服务器应用程序迁移到Spring Security 5.2 中的新支持。详细参见 官方博客.</p><ol start="3"><li>对 OAuth2.0 的技术选型<br>从上面的信息看来， Spring Security 未来依然提供 OAuth2 的 客户端支持 和 资源服务器支持。授权服务器 将逐渐退出 Spring Security 的生态环境。所以如果没有授权服务器需求的情况下选择 Spring Security 依然是没有问题的，一旦有这个需求我们该如何选择？我这里调研了几个开源免费的项目。</li></ol><p>3.1 keycloak<br>keycloak是 RedHat 公司出品。是一个致力于解决应用和服务身份验证与访问管理的开源工具。可以通过简单的配置达到保护应用和服务的目的。它提供了身份和访问管理的有用功能：</p><p>单点登录（SSO），身份代理和第三方登录。</p><p>支持 OpenID Connect，OAuth 2.0 和 SAML 2.0 等标准协议。</p><p>用户集中管理。</p><p>客户端适配器，轻松保护应用程序和服务。</p><p>可视化管理控制台和帐户管理控制台。</p><p>可扩展性、高性能、快速实现落地。</p><p>文档比较完毕，而且是一个成熟的、免费的商业级产品。</p><p>3.2 Nimbus SDK<br>全称是 Nimbus OAuth 2.0 / OpenID Connect SDK，这是一个类库。Spring 官方在博客中提到可以使用该类库构建 Authorization Server，它同时支持 OAuth2.0 和 OpenID Connect，比较完整地实现了这两个协议，而且针对补充协议也在积极的跟进。缺点在于中文教程不多而且是一个类库性质的。不过官方提供了 DEMO ，有能力的同学入门也不算难事。</p><p>3.3 Apache Oltu<br>Apache Oltu 是 Apache 基金会旗下的一个毕业项目。提供了 OAuth2.0 的常用实现，根据文档提供的信息来看上手还是比较简单的，模块化的提供了对 Authorization Server、Resource Server、Client、JOSE、 的支持。中文教程网上还是有不少的，缺点在于项目维护比较滞后，最新的版本是 2016 年发布的。</p><p>3.4 Vertx-auth-oauth2<br>vertx-auth-oauth2 属于 Vert.x 生态，提供了比较完整的 OAuth2.0 实现，而且项目维护比较活跃，唯一的缺点在于有技术栈的局限性。</p><h2 id="https-gitee-com-felord"><a href="#https-gitee-com-felord" class="headerlink" title="https://gitee.com/felord"></a><a href="https://gitee.com/felord" target="_blank" rel="noopener">https://gitee.com/felord</a></h2><h2 id="https-github-com-Kong-kong"><a href="#https-github-com-Kong-kong" class="headerlink" title="https://github.com/Kong/kong"></a><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OAuth2-0-技术&quot;&gt;&lt;a href=&quot;#OAuth2-0-技术&quot; class=&quot;headerlink&quot; title=&quot;OAuth2.0 技术&quot;&gt;&lt;/a&gt;OAuth2.0 技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring Security OAuth2&lt;/li&gt;

      
    
    </summary>
    
    
    
      <category term="Spring Security" scheme="http://gottaboy.cn/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO</title>
    <link href="http://gottaboy.cn/2020/01/09/JavaIO/"/>
    <id>http://gottaboy.cn/2020/01/09/JavaIO/</id>
    <published>2020-01-09T13:02:34.000Z</published>
    <updated>2020-01-11T09:06:38.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Java 的 IO 体系中，类将近有 80 个，位于java.io包下，感觉很复杂，但是这些类大致可以分成四组：</p><p>基于字节操作的 I/O 接口：InputStream 和 OutputStream<br>基于字符操作的 I/O 接口：Writer 和 Reader<br>基于磁盘操作的 I/O 接口：File<br>基于网络操作的 I/O 接口：Socket<br>前两组主要从传输数据的数据格式不同，进行分组；后两组主要从传输数据的方式不同，进行分组。</p><p>虽然 Socket 类并不在java.io包下，但是我们仍然把它们划分在一起，因为 I/O 的核心问题，要么是数据格式影响 I/O 操作，要么是传输方式影响 I/O 操作，也就是将什么样的数据写到什么地方的问题，I/O 只是人与机器或者机器与机器交互的手段，除了在它们能够完成这个交互功能外，我们关注的就是如何提高它的运行效率了，而数据格式和传输方式是影响效率最关键的因素。</p><p>本文后面，也是基于这两个点进行深入展开分析。</p><p>二、基于字节操作的接口<br>基于字节的输入和输出操作接口分别是：InputStream 和 OutputStream 。</p><p>2.1、字节输入流<br>InputStream 输入流的类继承层次如下图所示：</p><p><img src="/2020/01/09/JavaIO/InputStream.webp" alt="InputStream"></p><p>输入流根据数据节点类型和处理方式，分别可以划分出了若干个子类，如下图：</p><p><img src="/2020/01/09/JavaIO/InputStream_2.webp" alt="InputStream"></p><p>OutputStream 输出流的类层次结构也是类似。</p><p>2.2、字节输出流<br>OutputStream 输出流的类继承层次如下图所示：</p><p><img src="/2020/01/09/JavaIO/OutputStream_1.webp" alt="OutputStream"></p><p>输出流根据数据节点类型和处理方式，也分别可以划分出了若干个子类，如下图：</p><p><img src="/2020/01/09/JavaIO/OutputStream_2.webp" alt="OutputStream"></p><p>在这里就不详细的介绍各个子类的使用方法，有兴趣的朋友可以查看 JDK 的 API 说明文档，笔者也会在后期的文章会进行详细的介绍，这里只是重点想说一下，无论是输入还是输出，操作数据的方式可以组合使用，各个处理流的类并不是只操作固定的节点流，比如如下输出方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将文件输出流包装到序列化输出流中，再将序列化输出流包装到缓冲中</span><br><span class="line">OutputStream out &#x3D; new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream(new File(&quot;fileName&quot;)))；</span><br></pre></td></tr></table></figure><p>另外，输出流最终写到什么地方必须要指定，要么是写到硬盘中，要么是写到网络中，从图中可以发现，写网络实际上也是写文件，只不过写到网络中，需要经过底层操作系统将数据发送到其他的计算机中，而不是写入到本地硬盘中。</p><p>三、基于字符操作的接口<br>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是为什么要有操作字符的 I/O 接口呢？</p><p>这是因为我们的程序中通常操作的数据都是以字符形式，为了程序操作更方便而提供一个直接写字符的 I/O 接口，仅此而已。</p><p>基于字符的输入和输出操作接口分别是：Reader 和 Writer ，下图是字符的 I/O 操作接口涉及到的类结构图。</p><p>3.1、字符输入流<br>Reader 输入流的类继承层次如下图所示：</p><p><img src="/2020/01/09/JavaIO/Reader_1.webp" alt="Reader"></p><p>同样的，输入流根据数据节点类型和处理方式，分别可以划分出了若干个子类，如下图：</p><p><img src="/2020/01/09/JavaIO/Reader_2.webp" alt="Reader"></p><p>3.2、字符输出流<br>Writer 输出流的类继承层次如下图所示：</p><p><img src="/2020/01/09/JavaIO/Writer_1.webp" alt="Writer"></p><p>同样的，输出流根据数据节点类型和处理方式分类，分别可以划分出了若干个子类，如下图：</p><p><img src="/2020/01/09/JavaIO/Writer_2.webp" alt="Writer"></p><p>不管是 Reader 还是 Writer 类，它们都只定义了读取或写入数据字符的方式，也就是说要么是读要么是写，但是并没有规定数据要写到哪去，写到哪去就是我们后面要讨论的基于磁盘或网络的工作机制。</p><p>四、字节与字符的转化<br>刚刚我们说到，不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，设计字符的原因是为了程序操作更方便，那么怎么将字符转化成字节或者将字节转化成字符呢？</p><p>InputStreamReader 和 OutputStreamWriter 就是转化桥梁。</p><p>4.1、输入流转化过程<br>输入流字符解码相关类结构的转化过程如下图所示：</p><p><img src="/2020/01/09/JavaIO/InputStreamReader_1.webp" alt="InputStreamReader"></p><p>从图上可以看到，InputStreamReader 类是字节到字符的转化桥梁， 其中StreamDecoder指的是一个解码操作类，Charset指的是字符集。</p><p>InputStream 到 Reader 的过程需要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题，StreamDecoder 则是完成字节到字符的解码的实现类。</p><p>打开源码部分，InputStream 到 Reader 转化过程，如下图：</p><p><img src="/2020/01/09/JavaIO/InputStreamReader_2.webp" alt="InputStreamReader"></p><p>4.1、输出流转化过程<br>输出流转化过程也是类似，如下图所示：</p><p><img src="/2020/01/09/JavaIO/OutputStreamWriter_1.webp" alt="OutputStreamWriter"></p><p>通过 OutputStreamWriter 类完成字符到字节的编码过程，由 StreamEncoder 完成编码过程。</p><p>源码部分，Writer 到 OutputStream 转化过程，如下图：</p><p><img src="/2020/01/09/JavaIO/OutputStreamWriter_2.webp" alt="OutputStreamWriter"></p><p>五、基于磁盘操作的接口<br>前面介绍了 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作数据格式的方式：字节流和字符流。</p><p>还有一个关键问题就是数据写到何处，其中一个主要的处理方式就是将数据持久化到物理磁盘。</p><p>我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。<br><img src="/2020/01/09/JavaIO/File_IO.webp" alt="File_IO"></p><p>在 Java I/O 体系中，File 类是唯一代表磁盘文件本身的对象。</p><p>File 类定义了一些与平台无关的方法来操作文件，包括检查一个文件是否存在、创建、删除文件、重命名文件、判断文件的读写权限是否存在、设置和查询文件的最近修改时间等等操作。</p><p>值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。</p><p>例如，读取一个文件内容，程序如下：<br><img src="/2020/01/09/JavaIO/File_IO_1.webp" alt="File_IO"></p><p>以上面的程序为例，从硬盘中读取一段文本字符，操作流程如下图：<br><img src="/2020/01/09/JavaIO/File_IO_2.webp" alt="File_IO"></p><p>我们再来看看源码执行流程。</p><p>当我们传入一个指定的文件名来创建 File 对象，通过 FileReader 来读取文件内容时，会自动创建一个FileInputStream对象来读取文件内容，也就是我们上文中所说的字节流来读取文件。<br><img src="/2020/01/09/JavaIO/FileReader.webp" alt="FileReader"></p><p>紧接着，会创建一个FileDescriptor的对象，其实这个对象就是真正代表一个存在的文件对象的描述。可以通过FileInputStream对象调用getFD()方法获取真正与底层操作系统关联的文件描述。<br><img src="/2020/01/09/JavaIO/FileInputStream.webp" alt="FileInputStream"></p><p>由于我们需要读取的是字符格式，所以需要 StreamDecoder 类将byte解码为char格式，至于如何从磁盘驱动器上读取一段数据，由操作系统帮我们完成。</p><p>六、基于网络操作的接口<br>继续来说说数据写到何处的另一种处理方式：将数据写入互联网中以供其他电脑能访问。</p><p>6.1、Socket 简介<br>在现实中，Socket 这个概念没有一个具体的实体，它是描述计算机之间完成相互通信一种抽象定义。</p><p>打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。并且，交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。</p><p>典型的基于 Socket 通信的应用程序场景，如下图：<br><img src="/2020/01/09/JavaIO/Socket.webp" alt="Socket"></p><p>主机 A 的应用程序要想和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。</p><p>6.2、建立通信链路<br>我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例代表唯一一个主机上的一个应用程序的通信链路了。</p><p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略，如下图：<br><img src="/2020/01/09/JavaIO/TCP.webp" alt="TCP"></p><p>其中，SYN 全称为 Synchronize Sequence Numbers，表示同步序列编号，是 TCP/IP 建立连接时使用的握手信号。</p><p>ACK 全称为 Acknowledge character，即确认字符，表示发来的数据已确认接收无误。</p><p>在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN + ACK 应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。</p><p>这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p><p>简单流程如下：</p><p>发送端 –（发送带有 SYN 标志的数据包 ）–&gt; 接受端（第一次握手）；<br>接受端 –（发送带有 SYN + ACK 标志的数据包）–&gt; 发送端（第二次握手）；<br>发送端 –（发送带有 ACK 标志的数据包） –&gt; 接受端（第三次握手）；<br>完成三次握手之后，客户端应用程序与服务器应用程序就可以开始传送数据了。</p><p>传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据呢？</p><p>6.3、传输数据<br>当客户端要与服务端通信时，客户端首先要创建一个 Socket 实例，默认操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地、远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。<br><img src="/2020/01/09/JavaIO/Socket_Client_1.webp" alt="Socket"></p><p>与之对应的服务端，也将创建一个 ServerSocket 实例，ServerSocket 创建比较简单，只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是*即监听所有地址。</p><p>之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。<br><img src="/2020/01/09/JavaIO/Socket_Server_1.webp" alt="Socket"></p><p>我们先启动服务端程序，再运行客户端，服务端收到客户端发送的信息，服务端打印结果如下：</p><p>注意，客户端只有与服务端建立三次握手成功之后，才会发送数据，而 TCP/IP 握手过程，底层操作系统已经帮我们实现了！</p><p>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正如我们前面所说的，网络 I/O 都是以字节流传输的，Socket 正是通过这两个对象来交换数据。</p><p>当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。</p><p>写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。</p><p>值得特别注意的是，缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁的问题。</p><p>如何提高网络 IO 传输效率、保证数据传输的可靠，已经成了工程师们急需解决的问题。</p><p>6.4、IO 工作方式<br>在计算机中，IO 传输数据有三种工作方式，分别是 BIO、NIO、AIO。</p><p>在讲解 BIO、NIO、AIO 之前，我们先来回顾一下这几个概念：同步与异步，阻塞与非阻塞。</p><p>同步与异步的区别</p><p>同步就是发起一个请求后，接受者未处理完请求之前，不返回结果。<br>异步就是发起一个请求后，立刻得到接受者的回应表示已接收到请求，但是接受者并没有处理完，接受者通常依靠事件回调等机制来通知请求者其处理结果。<br>阻塞和非阻塞的区别</p><p>阻塞就是请求者发起一个请求，一直等待其请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。<br>非阻塞就是请求者发起一个请求，不用一直等着结果返回，可以先去干其他事情，当条件就绪的时候，就自动回来。<br>而我们要讲的 BIO、NIO、AIO 就是同步与异步、阻塞与非阻塞的组合。</p><p>BIO：同步阻塞 IO；<br>NIO：同步非阻塞 IO；<br>AIO：异步非阻塞 IO;<br>6.4.1、BIO<br>BIO 俗称同步阻塞 IO，一种非常传统的 IO 模型，比如我们上面所举的那个程序例子，就是一个典型的*<em>同步阻塞 IO *</em>的工作方式。<br><img src="/2020/01/09/JavaIO/BIO.webp" alt="BIO"></p><p>采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。</p><p>我们一般在服务端通过while(true)循环中会调用accept()方法等待监听客户端的连接，一旦接收到一个连接请求，就可以建立通信套接字进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接。</p><p>客户端多线程操作，程序如下：<br><img src="/2020/01/09/JavaIO/BIO_Client_1.webp" alt="BIO"></p><p>服务端多线程操作，程序如下：<br><img src="/2020/01/09/JavaIO/BIO_Server_1.webp" alt="BIO"></p><p>服务端运行结果，如下：</p><p>如果要让 BIO 通信模型能够同时处理多个客户端请求，就必须使用多线程，也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。</p><p>这就是典型的一请求一应答通信模型 。</p><p>如果出现 100、1000、甚至 10000 个用户同时访问服务器，这个时候，如果使用这种模型，那么服务端也会创建与之相同的线程数量，线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p><p>当然，我们可以通过使用 Java 中 ThreadPoolExecutor 线程池机制来改善，让线程的创建和回收成本相对较低，保证了系统有限的资源的控制，实现了 N （客户端请求数量）大于 M （处理客户端请求的线程数量）的伪异步 I/O 模型。</p><p>6.4.2、伪异步 BIO<br>为了解决同步阻塞 I/O 面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化，后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数 M：线程池最大线程数 N 的比例关系，其中 M 可以远远大于 N，通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致资源耗尽。</p><h3 id="伪异步-IO-模型图，如下图："><a href="#伪异步-IO-模型图，如下图：" class="headerlink" title="伪异步 IO 模型图，如下图："></a>伪异步 IO 模型图，如下图：</h3><p>采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，当有新的客户端接入时，将客户端的 Socket 封装成一个 Task 投递到后端的线程池中进行处理。<br><img src="/2020/01/09/JavaIO/BIO_2.webp" alt="BIO"></p><p>Java 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。</p><p>客户端，程序如下：<br><img src="/2020/01/09/JavaIO/BIO_Client_2.webp" alt="BIO"></p><p>服务端，程序如下：<br><img src="/2020/01/09/JavaIO/BIO_Server_2.webp" alt="BIO"></p><p>先启动服务端程序，再启动客户端程序，看看运行结果！</p><p>服务端，运行结果如下：<br><img src="/2020/01/09/JavaIO/BIO_Client_3.webp" alt="BIO"></p><p>客户端，运行结果如下：</p><p>本例中测试的客户端数量是 30，服务端使用 java 线程池来处理任务，线程数量为 5 个，服务端不用为每个客户端都创建一个线程，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p>在活动连接数不是特别高的情况下，这种模型是还不错，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。</p><p>但是，它的底层仍然是同步阻塞的 BIO 模型，当面对十万甚至百万级连接的时候，传统的 BIO 模型真的是无能为力的，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h3 id="6-4-3、NIO"><a href="#6-4-3、NIO" class="headerlink" title="6.4.3、NIO"></a>6.4.3、NIO</h3><p>NIO 中的 N 可以理解为 Non-blocking，一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入，对应的在java.nio包下。</p><p>NIO 新增了 Channel、Selector、Buffer 等抽象概念，支持面向缓冲、基于通道的 I/O 操作方法。</p><p>NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现。</p><p>NIO 这两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</p><p>对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发效率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p><p>我们先看一下 NIO 涉及到的核心关联类图，如下：<br><img src="/2020/01/09/JavaIO/NIO_1.webp" alt="NIO"></p><p>上图中有三个关键类：Channel 、Selector 和 Buffer，它们是 NIO 中的核心概念。</p><p>Channel：可以理解为通道；<br>Selector：可以理解为选择器；<br>Buffer：可以理解为数据缓冲流；<br>我们还是用前面的城市交通工具来继续形容 NIO 的工作方式，这里的 Channel 要比 Socket 更加具体，它可以比作为某种具体的交通工具，如汽车或是高铁、飞机等，而 Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出站还是在路上等等，也就是说它可以轮询每个 Channel 的状态。</p><p>还有一个 Buffer 类，你可以将它看作为 IO 中 Stream，但是它比 IO 中的 Stream 更加具体化，我们可以将它比作为车上的座位，Channel 如果是汽车的话，那么 Buffer 就是汽车上的座位，Channel 如果是高铁上，那么 Buffer 就是高铁上的座位，它始终是一个具体的概念，这一点与 Stream 不同。</p><p>Socket 中的 Stream 只能代表是一个座位，至于是什么座位由你自己去想象，也就是说你在上车之前并不知道这个车上是否还有没有座位，也不知道上的是什么车，因为你并不能选择，这些信息都已经被封装在了运输工具（Socket）里面了。</p><p>NIO 引入了 Channel、Buffer 和 Selector 就是想把 IO 传输过程中涉及到的信息具体化，让程序员有机会去控制它们。</p><p>当我们进行传统的网络 IO 操作时，比如调用 write() 往 Socket 中的 SendQ 队列写数据时，当一次写的数据超过 SendQ 长度时，操作系统会按照 SendQ 的长度进行分割的，这个过程中需要将用户空间数据和内核地址空间进行切换，而这个切换不是程序员可以控制的，由底层操作系统来帮我们处理。</p><p>而在 Buffer 中，我们可以控制 Buffer 的 capacity（容量），并且是否扩容以及如何扩容都可以控制。</p><p>理解了这些概念后我们看一下，实际上它们是如何工作的呢？</p><p>还是以上面的操作为例子，为了方便观看结果，本次的客户端线程请求数改成 15 个。</p><p>客户端，程序如下：<br><img src="/2020/01/09/JavaIO/NIO_Client_1.webp" alt="NIO"></p><p>服务端，程序如下：<br><img src="/2020/01/09/JavaIO/NIO_Server_1.webp" alt="NIO"></p><p>先启动服务端程序，再启动客户端程序，看看运行结果！</p><p>服务端，运行结果如下：</p><p>客户端，运行结果如下：</p><p>当然，客户端也不仅仅只限制于 IO 的写法，还可以使用SocketChannel来操作客户端，程序如下：<br><img src="/2020/01/09/JavaIO/NIO_Server_2.webp" alt="NIO"></p><p>一样的，先启动服务端，再启动客户端，客户端运行结果如下：</p><p>从操作上可以看到，NIO 的操作比传统的 IO 操作要复杂的多！</p><p>Selector 被称为选择器 ，当然你也可以翻译为多路复用器 。它是 Java NIO 核心组件中的一个，用于检查一个或多个 Channel（通道）的状态是否处于连接就绪、接受就绪、可读就绪、可写就绪。</p><p>如此可以实现单线程管理多个 channels，也就是可以管理多个网络连接。<br><img src="/2020/01/09/JavaIO/Selector.webp" alt="Selector"></p><p>使用 Selector 的好处在于： 相比传统方式使用多个线程来管理 IO，Selector 使用了更少的线程就可以处理通道了，并且实现网络高效传输！</p><p>虽然 java 中的 nio 传输比较快，为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？</p><p>从上面的代码中大家都可以看出来，除了编程复杂、编程模型难之外，还有几个让人诟病的问题：</p><p>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%！<br>项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高！<br>但是，Google 的 Netty 框架的出现，很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题，关于 Netty 框架，会在后期的文章里进行介绍。</p><h3 id="6-4-4、AIO"><a href="#6-4-4、AIO" class="headerlink" title="6.4.4、AIO"></a>6.4.4、AIO</h3><p>最后就是 AIO 了，全称 Asynchronous I/O，可以理解为异步 IO，也被称为 NIO 2，在 Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的 IO 模型，也就是我们现在所说的 AIO。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>客户端，程序示例：<br><img src="/2020/01/09/JavaIO/AIO_Client.webp" alt="AIO"></p><p>服务端，程序示例：<br><img src="/2020/01/09/JavaIO/AIO_Server.webp" alt="AIO"></p><p>同样的，先启动服务端程序，再启动客户端程序，看看运行结果！</p><p>服务端，运行结果如下：</p><p>客户端端，运行结果如下：</p><p>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。</p><p>Netty 之前也尝试使用过 AIO，不过又放弃了！</p><p>七、总结<br>本文阐述的内容较多，从 Java 基本 I/O 类库结构开始说起，主要介绍了 IO 的传输格式和传输方式，以及磁盘 I/O 和网络 I/O 的基本工作方式。</p><p>本篇文章主要对 Java 的 IO 体系以及计算机部分网络基础知识做了些简单的介绍，其实每一个模块涉及到的知识都非常非常多，在后期的文章中，会对各个模块进行详细的介绍，如果有理解不到的位置，欢迎指出！</p><hr><p>参考资料</p><p>[1] IBM - 许令波 -深入分析 Java I/O 的工作机制: <a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html</a></p><p>[2] Github - JavaGuide -  IO总结: <a href="https://snailclimb.gitee.io/javaguide/#/" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/</a></p><p>[3] 博客园 - 五月的仓颉 -  IO和File: <a href="https://www.cnblogs.com/xrq730/p/4886636.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4886636.html</a></p><p>[4] <a href="https://mp.weixin.qq.com/s/O07Hs0anT4cRYYx-eqIesg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/O07Hs0anT4cRYYx-eqIesg</a> JavaIO</p><p>[5] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html</a> 深入分析 Java I/O 的工作机制</p><p>[6] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/</a>  深入分析 Java 中的中文编码问题</p><p>[7] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html</a>  Tomcat 系统架构与设计模式</p><p>[8] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-servlet/</a> Servlet 工作原理解析</p><p>[9] <a href="https://www.cnblogs.com/zlslch/" target="_blank" rel="noopener">https://www.cnblogs.com/zlslch/</a> 大数据</p><hr><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File类是IO包中唯一代表磁盘文件本身的对象，File类定义了一些与平台无关的方法来操作文件。通过调用File类提供的各种方法，能够完成创建、删除文件、重命名文件、判断文件的读写权限权限是否存在、设置和查询文件的最近修改时间等操作。</p><p>File类没有无参构造方法，最常用的是使用下面的构造方法来生成File对象（注意分隔符可以使用”/“和”&quot;，但是使用”&quot;必须写”\“，因为涉及转义的问题）：</p><p>File(String pathName)</p><p>pathName指的是文件的路径名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void filePath()&#123;</span><br><span class="line">    String fileName &#x3D; &quot;D:&quot; + File.separator + &quot;Files&quot;;</span><br><span class="line">    File file &#x3D; new File(fileName);</span><br><span class="line"></span><br><span class="line">    if (file.exists() &amp;&amp; file.isDirectory())&#123; &#x2F;&#x2F; 判断路径指向的文件&#x2F;文件夹是否存在、是否目录</span><br><span class="line">        System.out.println(&quot;file是一个文件夹\n&quot;);</span><br><span class="line"></span><br><span class="line">        File[] files &#x3D; file.listFiles(); &#x2F;&#x2F; 获取目录下的所有文件&#x2F;文件夹（仅该层路径下）</span><br><span class="line">        System.out.print(&quot;路径下有文件：&quot;);</span><br><span class="line">        for (File f : files)&#123;</span><br><span class="line">            System.out.print(f + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;files[0]的文件名：&quot; + files[0].getName()); &#x2F;&#x2F; 获取文件名、文件夹名</span><br><span class="line">        System.out.println(&quot;files[0]的文件路径：&quot; + files[0].getPath()); &#x2F;&#x2F; 获取文件、文件夹路径</span><br><span class="line">        System.out.println(&quot;files[0]的绝对路径：&quot; + files[0].getAbsolutePath()); &#x2F;&#x2F; 获取文件、文件夹绝对路径</span><br><span class="line">        System.out.println(&quot;files[0]的父文件夹名：&quot; + files[0].getParent()); &#x2F;&#x2F; 获取文件父目录路径</span><br><span class="line">        System.out.println(files[0].exists() ? &quot;files[0]的存在&quot; : &quot;files[0]的不存在&quot;); &#x2F;&#x2F; 判断文件、文件夹是否存在</span><br><span class="line">        System.out.println(files[0].canWrite() ? &quot;files[0]的可写&quot; : &quot;files[0]的不可写&quot;); &#x2F;&#x2F; 判断文件是否可写</span><br><span class="line">        System.out.println(files[0].canRead() ? &quot;files[0]的可读&quot; : &quot;files[0]的不可读&quot;); &#x2F;&#x2F; 判断文件是否可读</span><br><span class="line">        System.out.println(files[0].canExecute() ? &quot;file[0]可执行&quot; : &quot;file[0]不可执行&quot;); &#x2F;&#x2F; 判断文件是否可执行</span><br><span class="line">        System.out.println(files[0].isDirectory() ? &quot;files[0]的是目录&quot; : &quot;files[0]的不是目录&quot;); &#x2F;&#x2F; 判断文件、文件夹是不是目录</span><br><span class="line">        System.out.println(files[0].isFile() ? &quot;files[0]的是文件&quot; : &quot;files[0]的不是文件&quot;); &#x2F;&#x2F; 判断拿文件、文件夹是不是标准文件</span><br><span class="line">        System.out.println(files[0].isAbsolute() ? &quot;files[0]的路径名是绝对路径&quot; : &quot;files[0]的路径名不是绝对路径&quot;); &#x2F;&#x2F; 判断路径名是不是绝对路径</span><br><span class="line">        System.out.println(&quot;files[0]的最后修改时间：&quot; + files[0].lastModified()); &#x2F;&#x2F; 获取文件、文件夹上一次修改时间</span><br><span class="line">        System.out.println(&quot;files[0]的大小：&quot; + files[0].length() + &quot; Bytes&quot;); &#x2F;&#x2F; 获取文件的字节数，如果是一个文件夹则这个值为0</span><br><span class="line">        System.out.println(&quot;files[0]的路径转换为URI：&quot; + files[0].toURI()); &#x2F;&#x2F; 获取文件路径URI后的路径名</span><br><span class="line"></span><br><span class="line">        if (files[0].exists())</span><br><span class="line">            files[0].delete(); &#x2F;&#x2F; 删除指定的文件、文件夹</span><br><span class="line">        if (files[1].exists())</span><br><span class="line">            files[1].deleteOnExit(); &#x2F;&#x2F; 当虚拟机终止时删除指定的文件、文件夹</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java文件的几种读取、输出方式"><a href="#Java文件的几种读取、输出方式" class="headerlink" title="Java文件的几种读取、输出方式"></a>Java文件的几种读取、输出方式</h3><p>1、字节流—-对文件读取（速度慢）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 字节流---文件的读取，输出(缺点：速度慢)</span><br><span class="line">* </span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testIO1() throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 输入字节流对象</span><br><span class="line">    InputStream in &#x3D; new FileInputStream(&quot;pkg&#x2F;a.txt&quot;);</span><br><span class="line">    &#x2F;&#x2F; 输出字节流对象</span><br><span class="line">    OutputStream out &#x3D; new FileOutputStream(&quot;pkg&#x2F;b.txt&quot;);</span><br><span class="line">    &#x2F;&#x2F;这里定义个字节数组，用来指定每次读取的字节数</span><br><span class="line">    byte[] b &#x3D; new byte[1024];</span><br><span class="line">    int len &#x3D; -1;</span><br><span class="line">    while ((len &#x3D; in.read(b, 0, b.length)) !&#x3D; -1) &#123;</span><br><span class="line">        String str &#x3D; new String(b, 0, len, &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        out.write(b, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;关闭对象</span><br><span class="line">    out.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、带缓存的字节流—文件读取（速度快）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 缓存字节流---文件读取，输出（推荐：速度快）</span><br><span class="line">* </span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testIO2() throws Exception &#123;</span><br><span class="line">    BufferedInputStream in &#x3D; new BufferedInputStream(new FileInputStream(&quot;pkg&#x2F;a.txt&quot;));</span><br><span class="line">    BufferedOutputStream out &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;pkg&#x2F;b.txt&quot;));</span><br><span class="line"></span><br><span class="line">    byte[] b &#x3D; new byte[1024];</span><br><span class="line">    int len &#x3D; -1;</span><br><span class="line">    while ((len &#x3D; in.read(b, 0, b.length)) !&#x3D; -1) &#123;</span><br><span class="line">        String str &#x3D; new String(b, 0, len, &quot;UTF-8&quot;);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        out.write(b, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;刷新缓冲</span><br><span class="line">    out.flush();</span><br><span class="line">    &#x2F;&#x2F;关闭流对象</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、字节流reader，这个方法不能指定读取的字节数（不推荐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 字节流reader，不能指定字节长度读取，不建议使用</span><br><span class="line">*&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testIO3() throws Exception &#123;</span><br><span class="line">    InputStreamReader in &#x3D; new InputStreamReader(new FileInputStream(&quot;pkg&#x2F;a.txt&quot;), &quot;UTF-8&quot;);</span><br><span class="line">    OutputStreamWriter out &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;pkg&#x2F;b.txt&quot;));</span><br><span class="line"></span><br><span class="line">    int len &#x3D; -1;</span><br><span class="line">    while ((len &#x3D; in.read()) !&#x3D; -1) &#123;</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        &#x2F;&#x2F; 写入文件</span><br><span class="line">        out.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">    out.flush();</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、带缓冲的字节流读取方式，readLine()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 另一种字节流读取方式----可以提供readLine()的方法，一次读取一行。</span><br><span class="line">* </span><br><span class="line">* @throws Exception</span><br><span class="line">*&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testIO4() throws Exception &#123;</span><br><span class="line">    BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(&quot;pkg&#x2F;a.txt&quot;), &quot;UTF-8&quot;));</span><br><span class="line">    BufferedWriter out &#x3D; new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;pkg&#x2F;b.txt&quot;), &quot;UTF-8&quot;));</span><br><span class="line">    String str;</span><br><span class="line">    while ((str &#x3D; in.readLine()) !&#x3D; null) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        out.write(str + &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    out.flush();</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java中字节和字符的转换"><a href="#Java中字节和字符的转换" class="headerlink" title="Java中字节和字符的转换"></a>Java中字节和字符的转换</h3><ol><li>String<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;这是一段字符串&quot;;</span><br><span class="line">byte[] bytes &#x3D; str.getBytes(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">String newStr &#x3D; new String(bytes, &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure></li><li>ByteToCharConverter &amp; CharToByteConverter<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteToCharConverter charConverter &#x3D; ByteToCharConverter.getConverter(&quot;UTF-8&quot;);</span><br><span class="line">char[] c &#x3D; charConverter.convertAll(byteArray);</span><br><span class="line"></span><br><span class="line">CharToByteConverter byteConverter &#x3D; CharToByteConverter.getConverter(&quot;UTF-8&quot;);</span><br><span class="line">byte[] b &#x3D; byteConverter.convertAll(c);</span><br></pre></td></tr></table></figure></li><li>Charset<br>方法2中的两个类已经被Charset取代，Charset提供encode以及decode方法，分别对应char[]到byte[]的编码已经byte[]到char[]的编码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;这是一段字符串&quot;;</span><br><span class="line"></span><br><span class="line">Charset charset &#x3D; Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line">ByteBuffer byteBuffer &#x3D; charset.encode(str);</span><br><span class="line">CharBuffer charBuffer &#x3D; charset.decode(byteBuffer);</span><br></pre></td></tr></table></figure></li><li>ByteBuffer<br>ByteBuffer提供char和byte之间的软转换，他们之间的转换不需要编码与解码，只是把一个16bit的char拆分成2个8bit的byte表示，他们的实际值并没有被修改，仅仅是数据的数据类型做了转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer heapByteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">ByteBuffer byteBuffer &#x3D; heapByteBuffer.putChar(c);</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串string和内存流MemoryStream及比特数组byte-互转比较"><a href="#字符串string和内存流MemoryStream及比特数组byte-互转比较" class="headerlink" title="字符串string和内存流MemoryStream及比特数组byte[]互转比较"></a>字符串string和内存流MemoryStream及比特数组byte[]互转比较</h3><p>定义string变量为str,内存流变量为ms,比特数组为bt</p><p>1.字符串转比特数组<br>(1)byte[] bt=System.Text.Encoding.Default.GetBytes(“字符串”);<br>(2)byte[] bt=Convert.FromBase64String(“字符串”);</p><p>2.字符串转流<br>(1)MemoryStream ms=new MemoryStream(System.Text.Encoding.Default.GetBytes(“字符串”));<br>(2)MemoryStream ms=new MemoryStream(Convert.FromBase64String(“字符串”));</p><p>3.流转比特数组<br>(1)byte[] bt=ms.ToArray();<br>(2)MemoryStream ms=new MemoryStream();ms.Write(bt,0,ms.Length);</p><p>4.流转字符串<br>(1)string str=Convert.ToBase64String(ms.ToArray());<br>(2)string str=System.Text.Encoding.Default.GetString(ms.ToArray());</p><p>5.比特数组转字符串<br>(1)string str=System.Text.Encoding.Default.GetString(bt);<br>(2)string str=Convert.ToBase64String(bt);</p><p>6.比特数组转流<br>(1)MemoryStream ms=new MemoryStream(bt);<br>(2)MemoryStream ms=new MemoryStream();ms.Read(bt,0,bt.Lenght);</p><p>可以看出byte[]比较活跃在string和流转化时是个重要的桥梁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在 Java 的 IO 体系中，类将近有 80 个，位于java.io包下，感觉很复杂，但是这些类大致可以分成四组：&lt;/p&gt;
&lt;p&gt;基于字节
      
    
    </summary>
    
    
    
      <category term="java" scheme="http://gottaboy.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://gottaboy.cn/2020/01/09/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://gottaboy.cn/2020/01/09/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-01-09T11:35:26.000Z</published>
    <updated>2020-02-25T14:33:20.613Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>很多框架如mybatis的插件，servlet的filter，dubbo，安全框架诸如Spring security、apache shiro都会用到设计模式中的责任链模式，所以学习责任链模式成为帮助你学习以上这些框架的一个好的手段之一。今天我们就来了解一下责任链模式。</p><p>定义<br>如果有多个对象（Handler）都有机会处理数据源（RequestSource,这里不是单纯的数据库数据源，可以是一个请求，总之是来源），责任链可以使数据的发送者和接收者解耦，数据沿着责任链传递，直到有一个对象处理了它为止。<br>上去形成了一条流水线的链条，所以称之为责任链，但是不仅仅局限于链条，还可以成树形或者环形，这取决于你的业务设计。</p><p>场景<br>插件设计、拦截器、过滤器等一些针对切入点的特定链式处理。都可以使用责任链模式。</p><p>两种实现方式<br>两种方式的不同主要是定义处理链的顺序和结构的不同，接下来我们来看看这三种方式。</p><p>通过处理器集合来定义处理顺序<br>好处在于可以集中管理处理器，指责单一。非常容易理解，容易实现。缺点是如果新增处理器（Handler）势必影响已有的处理器，只能顺序执行。处理流程是这样的:</p><p><img src="/2020/01/09/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/HandlerChain.png" alt="责任链模式"></p><p>接下来用代码来实现一下此模式：</p><p>HandlerChain 负责维护调用链条的顺序，这里默认实现用List来管理Handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerChain &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调用handler 处理 source.</span><br><span class="line">     *</span><br><span class="line">     * @param requestSource the request source</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void doChain(RequestSource requestSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">public class DefaultHandlerChain implements HandlerChain &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前handler指针的位置</span><br><span class="line">    private int pos &#x3D; 0;</span><br><span class="line">    private List&lt;Handler&gt; handlers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void addHandler(Handler handler) &#123;</span><br><span class="line">        handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doChain(RequestSource requestSource) &#123;</span><br><span class="line">        int size &#x3D; handlers.size();</span><br><span class="line">        if (pos &lt; size) &#123;</span><br><span class="line">          &#x2F;&#x2F;注意对pos的处理</span><br><span class="line">            Handler handler &#x3D; handlers.get(pos++);</span><br><span class="line">            handler.doHandler(requestSource, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler是处理链的节点抽象，是数据源（RequestSource）的具体处理者，它负责对数据的处理以及决定是否进入下一个Handler。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface Handler &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Do handler.</span><br><span class="line">     *</span><br><span class="line">     * @param requestSource  数据源</span><br><span class="line">     * @param handlerChain   传入当前的Chain进行类似递归式的调用。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void doHandler(RequestSource requestSource,HandlerChain handlerChain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其中一个实现</span><br><span class="line">public class HeaderHandler implements Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doHandler(RequestSource requestSource, HandlerChain handlerChain) &#123;</span><br><span class="line">       &#x2F;&#x2F; 处理数据</span><br><span class="line">        Integer header &#x3D; requestSource.getHeader();</span><br><span class="line">        System.out.println(&quot;header handler&#x3D; &quot; + header);</span><br><span class="line">       &#x2F;&#x2F;继续下一个 你可以根据条件来决定是否继续进行chain</span><br><span class="line">        handlerChain.doChain(requestSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用链表的指针特性<br>这里利用了链表的一部分特点，通过在当前的Handler指定下一个Handler来作为指针,相比较上面而言，Handler更自治，在节点的处理上更加灵活。</p><p><img src="/2020/01/09/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/Handler.png" alt="责任链模式"></p><p>Handler负责指针以及逻辑处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public interface Handler &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 指针指向下一个处理节点.</span><br><span class="line">     *</span><br><span class="line">     * @return the next</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Handler getNext();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理具体逻辑.</span><br><span class="line">     *</span><br><span class="line">     * @param requestSource the request source</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void doHandler(RequestSource requestSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">public class HeaderHandler implements Handler &#123;</span><br><span class="line">    private Handler next;</span><br><span class="line"></span><br><span class="line">    public HeaderHandler(Handler next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Handler getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doHandler(RequestSource requestSource) &#123;</span><br><span class="line">        Integer header &#x3D; requestSource.getHeader();</span><br><span class="line">        System.out.println(&quot;header &#x3D; &quot; + header);</span><br><span class="line">        if (next !&#x3D; null) &#123;</span><br><span class="line">            next.doHandler(requestSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结<br>责任链模式在各种常见框架中非常常见。所以建议各位在对此设计模式进行认真学习</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言&lt;br&gt;很多框架如mybatis的插件，servlet的filter，dubbo，安全框架诸如Spring security、apache shiro都会用到设计模式中的责任链模式，所以学习责任链模式成为帮助你学习以上这些框架的一个好的手段之一。今天我们就来了解一下责任
      
    
    </summary>
    
    
    
      <category term="Java设计模式" scheme="http://gottaboy.cn/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>性格测试</title>
    <link href="http://gottaboy.cn/2020/01/07/%E6%80%A7%E6%A0%BC%E6%B5%8B%E8%AF%95/"/>
    <id>http://gottaboy.cn/2020/01/07/%E6%80%A7%E6%A0%BC%E6%B5%8B%E8%AF%95/</id>
    <published>2020-01-07T10:56:02.000Z</published>
    <updated>2020-01-07T10:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>必须遵守的原则<br>1 华为喜欢喜欢加班的人，所以必须能吃苦耐劳不计较报酬；</p><p>2 华为喜欢中庸，不要表现自己的也行，有自己性格一定会被刷掉；</p><p>3 华为喜欢稳定的，稳定超过一切，包括技术、做事能力；</p><p>4 性格不能过激；</p><p>5 团队合作很重要，不要自己来往；</p><p>6 跟着感觉走，不要前后矛盾；</p><p>7 不要固执偏激、要咨询别人意见、有团队合作精神、抗压力强、不紧张、遇事乐观阳光、工作和任务保证完成；</p><p>做题小攻略<br>1 坚定</p><p>对于一些有关基本要求的问题，根据对自己的定位，大胆选择，不要犹豫；</p><p>比如，我是一个乐观的人，我是一个守时的人；</p><p>2 不要试图揣摩公司的想法</p><p>有人自作聪明，说华为崇尚狼性文化，回答问题要表现地狼性一点，极端一点。</p><p>有学生因“非常强烈地不同意”、“强烈不同意”、“强烈同意”、“非常强烈地同意”出现频率过高被刷，原因可能在于太激进；</p><p>但这种想法是不对的，一定不要揣摩公司想法，否则效果只会南辕北辙！</p><p>3 焦虑不可有</p><p>有学生因“不确定”、“轻微不同意”、“轻微同意”出现频率过高被刷，原因可能就在于这是焦虑的表现；</p><p>4 不要试图去掩饰自己的缺点</p><p>每个人都是不完美的，都有优缺点；不要试图掩盖，实事求是；</p><p>性格测试的主要测试点<br>1 地雷</p><p>比如，选择不愿意加班，直接淘汰；选择经常焦虑，你是不是sa？</p><p>2 自相矛盾/前后不一致</p><p>比如，你刚开始选择你广泛听取别人意见，后面又选择你一个人做决定等；</p><p>比如，华为性格测试题目经常重复出现，检验前后回答是否一致，答题时一定要避免对相同问题给出差距很大的答案！！！</p><p>3 不同维度的比较让你选择最合适和最不合适，这是连环题，会有3到5题形成一个连环，先后不要矛盾；比如，</p><p>题37：我做事广泛听取别人的意见、我喜欢创新、我坚持按时完成任务</p><p>题45：我喜欢创新、我做事不喜欢半途而废、我坚持按时完成任务</p><p>题59：我坚持按时完成任务、我做事不喜欢半途而废、我做事广泛听取别人的意见</p><p>可能会出现的性格<br>1 最合适的性格<br>我信守自己做出的承诺</p><p>我觉得人们信守承诺相当重要</p><p>我坚持按时完成任务</p><p>我做事广泛听取别人的意见</p><p>做事前我会征询大家的意见</p><p>我愿意花时间去帮助别人</p><p>我做事不喜欢半途而废</p><p>我必须了解底层原理才能更有效的学习</p><p>我倾向于根据客观事实做决定</p><p>我必须找到解决问题的办法</p><p>我需要了解论点背后的逻辑</p><p>我喜欢创新</p><p>做事时我喜欢有新方法、新点子</p><p>我能想出很多主意</p><p>我喜欢提出很多主意</p><p>我喜欢提出独到的见解</p><p>2 适中的性格<br>我善于和别人建立融洽关系</p><p>我喜欢有压力的环境下工作</p><p>我喜欢忙碌的生活</p><p>我需要有明确的远景计划</p><p>我喜欢思考未来</p><p>我给自己设定了长远目标</p><p>我经常展望未来</p><p>我对未来比较乐观</p><p>我相信未来的事情会是好的</p><p>我做事很有远见</p><p>做事的时候我需要有章可循</p><p>我做事井井有条</p><p>我非常注重细节</p><p>我善于同时处理多项任务</p><p>我循规蹈矩地去做事情</p><p>我喜欢对数据进行统计与分析</p><p>我喜欢讨论抽象性的问题</p><p>我善于处理数字资料</p><p>我不容易被别人激怒</p><p>不信任他人</p><p>我在陌生朋友交流时会轻松自在</p><p>我大部分时间是快乐的</p><p>我有强烈的好奇心</p><p>我喜欢有竞争的工作</p><p>我是一个竞争心很强的人</p><p>3 不适合的性格<br>我掌控着自己的未来</p><p>我在重大事情发生前会紧张</p><p>我想有人陪在我身边</p><p>我坚持自己的做事方式</p><p>我善于结交朋友</p><p>我喜欢结识陌生人</p><p>我善于谈判</p><p>我善于推销</p><p>我是个很健谈的人</p><p>我关注别人的做事目的与做事冬季</p><p>我善于理解人们背后的的动机</p><p>我善于体会他人的感受</p><p>我要超越别人</p><p>我有较大的野心</p><p>我想成为团队中的领导</p><p>我更愿意领导别人</p><p>我喜欢挑战别人的想法</p><p>我享受独自工作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;必须遵守的原则&lt;br&gt;1 华为喜欢喜欢加班的人，所以必须能吃苦耐劳不计较报酬；&lt;/p&gt;
&lt;p&gt;2 华为喜欢中庸，不要表现自己的也行，有自己性格一定会被刷掉；&lt;/p&gt;
&lt;p&gt;3 华为喜欢稳定的，稳定超过一切，包括技术、做事能力；&lt;/p&gt;
&lt;p&gt;4 性格不能过激；&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LongAdder</title>
    <link href="http://gottaboy.cn/2020/01/05/LongAdder/"/>
    <id>http://gottaboy.cn/2020/01/05/LongAdder/</id>
    <published>2020-01-05T12:04:32.000Z</published>
    <updated>2020-01-05T12:05:10.227Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）java8中为什么要新增LongAdder？</p><p>（2）LongAdder的实现方式？</p><p>（3）LongAdder与AtomicLong的对比？</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。</p><p>它是怎么实现的呢？让我们一起来学习吧。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>LongAdder的原理是，在最初无竞争时，只更新base的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的LongAdder存储的值。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder1.png" alt="LongAdder"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>LongAdder继承自Striped64抽象类，Striped64中定义了Cell内部类和各重要属性。</p><h3 id="主要内部类"><a href="#主要内部类" class="headerlink" title="主要内部类"></a>主要内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Striped64中的内部类，使用@sun.misc.Contended注解，说明里面的值消除伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储元素的值，使用volatile修饰保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// CAS更新value的值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// value字段的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cell类使用@sun.misc.Contended注解，说明是要避免伪共享的。</p><p>使用Unsafe的CAS更新value的值，其中value的值使用volatile修饰，保证可见性。</p><p>关于Unsafe的介绍请查看【<a href="https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA" target="_blank" rel="noopener">死磕 java魔法类之Unsafe解析</a>】。</p><p>关于伪共享的介绍请查看【<a href="https://mp.weixin.qq.com/s/rd13SOSxhLA6TT13N9ni8Q" target="_blank" rel="noopener">杂谈 什么是伪共享（false sharing）？</a>】。</p><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这三个属性都在Striped64中</span></span><br><span class="line"><span class="comment">// cells数组，存储各个段的值</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 最初无竞争时使用的，也算一个特殊的段</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"><span class="comment">// 标记当前是否有线程在创建或扩容cells，或者在创建Cell</span></span><br><span class="line"><span class="comment">// 通过CAS更新该值，相当于是一个锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>最初无竞争或有其它线程在创建cells数组时使用base更新值，有过竞争时使用cells更新值。</p><p>最初无竞争是指一开始没有线程之间的竞争，但也有可能是多线程在操作，只是这些线程没有同时去更新base的值。</p><p>有过竞争是指只要出现过竞争不管后面有没有竞争都使用cells更新值，规则是不同的线程hash到不同的cell上去更新，减少竞争。</p><h3 id="add-x-方法"><a href="#add-x-方法" class="headerlink" title="add(x)方法"></a>add(x)方法</h3><p>add(x)方法是LongAdder的主要方法，使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// as是Striped64中的cells属性</span></span><br><span class="line">    <span class="comment">// b是Striped64中的base属性</span></span><br><span class="line">    <span class="comment">// v是当前线程hash到的Cell中存储的值</span></span><br><span class="line">    <span class="comment">// m是cells的长度减1，hash时作为掩码使用</span></span><br><span class="line">    <span class="comment">// a是当前线程hash到的Cell</span></span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 条件1：cells不为空，说明出现过竞争，cells已经创建</span></span><br><span class="line">    <span class="comment">// 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// true表示当前竞争还不激烈</span></span><br><span class="line">        <span class="comment">// false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span></span><br><span class="line">        <span class="comment">// 条件2：应该不会出现</span></span><br><span class="line">        <span class="comment">// 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span></span><br><span class="line">        <span class="comment">// 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span></span><br><span class="line">            <span class="comment">// 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span></span><br><span class="line">            <span class="comment">// 除非刻意修改它</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">// 调用Striped64中的方法处理</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）最初无竞争时只更新base；</p><p>（2）直到更新base失败时，创建cells数组；</p><p>（3）当多个线程竞争同一个Cell比较激烈时，可能要扩容；</p><h2 id="longAccumulate-方法"><a href="#longAccumulate-方法" class="headerlink" title="longAccumulate()方法"></a>longAccumulate()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储线程的probe值</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 如果getProbe()方法返回0，说明随机数未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 强制初始化</span></span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        <span class="comment">// 重新获取probe值</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        <span class="comment">// 都未初始化，肯定还不存在竞争激烈</span></span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否发生碰撞</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">// cells已经初始化过</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前线程所在的Cell未初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前无其它线程在创建或扩容cells，也没有线程在创建Cell</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">// 新建一个Cell，值为当前需要增加的值</span></span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="comment">// 再次检测cellsBusy，并尝试更新它为1</span></span><br><span class="line">                    <span class="comment">// 相当于当前线程加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="comment">// 是否创建成功</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">// 重新获取cells，并找到当前线程hash到cells数组中的位置</span></span><br><span class="line">                            <span class="comment">// 这里一定要重新获取cells，因为as并不在锁定范围内</span></span><br><span class="line">                            <span class="comment">// 有可能已经扩容了，这里要重新获取</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 把上面新建的Cell放在cells的j位置处</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                <span class="comment">// 创建成功</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 相当于释放锁</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 创建成功了就返回</span></span><br><span class="line">                        <span class="comment">// 值已经放在新建的Cell里面了</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 标记当前未出现冲突</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前线程所在的Cell不为空，且更新失败了</span></span><br><span class="line">            <span class="comment">// 这里简单地设为true，相当于简单地自旋一次</span></span><br><span class="line">            <span class="comment">// 通过下面的语句修改线程的probe再重新尝试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">// 再次尝试CAS更新当前线程所在Cell的值，如果成功了就返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果cells数组的长度达到了CPU核心数，或者cells扩容了</span></span><br><span class="line">            <span class="comment">// 设置collide为false并通过下面的语句修改线程的probe再重新尝试</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">// 上上个elseif都更新失败了，且上个条件不成立，说明出现冲突了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 明确出现冲突了，尝试占有锁，并扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查是否有其它线程已经扩容过了</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                        <span class="comment">// 新数组为原数组的两倍</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 把旧数组元素拷贝到新数组中</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        <span class="comment">// 重新赋值cells为新数组</span></span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 已解决冲突</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 使用扩容后的新数组重新尝试</span></span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新失败或者达到了CPU核心数，重新生成probe，并重试</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未初始化过cells数组，尝试占有锁并初始化cells数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 是否初始化成功</span></span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">// 检测是否有其它线程初始化过</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    <span class="comment">// 新建一个大小为2的Cell数组</span></span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 找到当前线程hash到数组中的位置并创建其对应的Cell</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                    <span class="comment">// 赋值给cells数组</span></span><br><span class="line">                    cells = rs;</span><br><span class="line">                    <span class="comment">// 初始化成功</span></span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化成功直接返回</span></span><br><span class="line">            <span class="comment">// 因为增加的值已经同时创建到Cell中了</span></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有其它线程在初始化cells数组中，就尝试更新base</span></span><br><span class="line">        <span class="comment">// 如果成功了就返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）如果cells数组未初始化，当前线程会尝试占有cellsBusy锁并创建cells数组；</p><p>（2）如果当前线程尝试创建cells数组时，发现有其它线程已经在创建了，就尝试更新base，如果成功就返回；</p><p>（3）通过线程的probe值找到当前线程应该更新cells数组中的哪个Cell；</p><p>（4）如果当前线程所在的Cell未初始化，就占有占有cellsBusy锁并在相应的位置创建一个Cell；</p><p>（5）尝试CAS更新当前线程所在的Cell，如果成功就返回，如果失败说明出现冲突；</p><p>（5）当前线程更新Cell失败后并不是立即扩容，而是尝试更新probe值后再重试一次；</p><p>（6）如果在重试的时候还是更新失败，就扩容；</p><p>（7）扩容时当前线程占有cellsBusy锁，并把数组容量扩大到两倍，再迁移原cells数组中元素到新数组中；</p><p>（8）cellsBusy在创建cells数组、创建Cell、扩容cells数组三个地方用到；</p><h2 id="sum-方法"><a href="#sum-方法" class="headerlink" title="sum()方法"></a>sum()方法</h2><p>sum()方法是获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="comment">// sum初始等于base</span></span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="comment">// 如果cells不为空</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的Cell</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果所在的Cell不为空，就把它的value累加到sum中</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sum()方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到sum上的Cell的value有修改，不是就没法计算到了么？</p><p>答案确实如此，所以LongAdder可以说不是强一致性的，它是最终一致性的。</p><h2 id="LongAdder-VS-AtomicLong"><a href="#LongAdder-VS-AtomicLong" class="headerlink" title="LongAdder VS AtomicLong"></a>LongAdder VS AtomicLong</h2><p>直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderVSAtomicLongTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        testAtomicLongVSLongAdder(<span class="number">1</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongVSLongAdder(<span class="number">10</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongVSLongAdder(<span class="number">20</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongVSLongAdder(<span class="number">40</span>, <span class="number">10000000</span>);</span><br><span class="line">        testAtomicLongVSLongAdder(<span class="number">80</span>, <span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomicLongVSLongAdder</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> threadCount, <span class="keyword">final</span> <span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"threadCount："</span> + threadCount + <span class="string">", times："</span> + times);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            testLongAdder(threadCount, times);</span><br><span class="line">            System.out.println(<span class="string">"LongAdder elapse："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">            testAtomicLong(threadCount, times);</span><br><span class="line">            System.out.println(<span class="string">"AtomicLong elapse："</span> + (System.currentTimeMillis() - start2) + <span class="string">"ms"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAtomicLong</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> threadCount, <span class="keyword">final</span> <span class="keyword">int</span> times)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;times; j++)&#123;</span><br><span class="line">                    atomicLong.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLongAdder</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> threadCount, <span class="keyword">final</span> <span class="keyword">int</span> times)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAdder longAdder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;times; j++)&#123;</span><br><span class="line">                    longAdder.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : list)&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadCount：<span class="number">1</span>, times：<span class="number">10000000</span></span><br><span class="line">LongAdder elapse：<span class="number">158</span>ms</span><br><span class="line">AtomicLong elapse：<span class="number">64</span>ms</span><br><span class="line">threadCount：<span class="number">10</span>, times：<span class="number">10000000</span></span><br><span class="line">LongAdder elapse：<span class="number">206</span>ms</span><br><span class="line">AtomicLong elapse：<span class="number">2449</span>ms</span><br><span class="line">threadCount：<span class="number">20</span>, times：<span class="number">10000000</span></span><br><span class="line">LongAdder elapse：<span class="number">429</span>ms</span><br><span class="line">AtomicLong elapse：<span class="number">5142</span>ms</span><br><span class="line">threadCount：<span class="number">40</span>, times：<span class="number">10000000</span></span><br><span class="line">LongAdder elapse：<span class="number">840</span>ms</span><br><span class="line">AtomicLong elapse：<span class="number">10506</span>ms</span><br><span class="line">threadCount：<span class="number">80</span>, times：<span class="number">10000000</span></span><br><span class="line">LongAdder elapse：<span class="number">1369</span>ms</span><br><span class="line">AtomicLong elapse：<span class="number">20482</span>ms</span><br></pre></td></tr></table></figure><p>可以看到当只有一个线程的时候，AtomicLong反而性能更高，随着线程越来越多，AtomicLong的性能急剧下降，而LongAdder的性能影响很小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）LongAdder通过base和cells数组来存储值；</p><p>（2）不同的线程会hash到不同的cell上去更新，减少了竞争；</p><p>（3）LongAdder的性能非常高，最终会达到一种无竞争的状态；</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>在longAccumulate()方法中有个条件是<code>n &gt;= NCPU</code>就不会走到扩容逻辑了，而n是2的倍数，那是不是代表cells数组最大只能达到大于等于NCPU的最小2次方？</p><p>答案是明确的。因为同一个CPU核心同时只会运行一个线程，而更新失败了说明有两个不同的核心更新了同一个Cell，这时会重新设置更新失败的那个线程的probe值，这样下一次它所在的Cell很大概率会发生改变，如果运行的时间足够长，最终会出现同一个核心的所有线程都会hash到同一个Cell（大概率，但不一定全在一个Cell上）上去更新，所以，这里cells数组中长度并不需要太长，达到CPU核心数足够了。</p><p>比如，笔者的电脑是8核的，所以这里cells的数组最大只会到8，达到8就不会扩容了。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/LongAdder2.png" alt="LongAdder"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;（1）java8中为什么要新增LongAdder？&lt;/p&gt;
&lt;p&gt;（2）LongAdder的实现方式？&lt;/p&gt;
&lt;p&gt;（3）Lon
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AtomicStampedReference</title>
    <link href="http://gottaboy.cn/2020/01/05/AtomicStampedReference/"/>
    <id>http://gottaboy.cn/2020/01/05/AtomicStampedReference/</id>
    <published>2020-01-05T12:03:28.000Z</published>
    <updated>2020-01-05T12:03:59.453Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）什么是ABA？</p><p>（2）ABA的危害？</p><p>（3）ABA的解决方法？</p><p>（4）AtomicStampedReference是什么？</p><p>（5）AtomicStampedReference是怎么解决ABA的？</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AtomicStampedReference是java并发包下提供的一个原子类，它能解决其它原子类无法解决的ABA问题。</p><h2 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h2><p>ABA问题发生在多线程环境中，当某线程连续读取同一块内存地址两次，两次得到的值一样，它简单地认为“此内存地址的值并没有被修改过”，然而，同时可能存在另一个线程在这两次读取之间把这个内存地址的值从A修改成了B又修改回了A，这时还简单地认为“没有修改过”显然是错误的。</p><p>比如，两个线程按下面的顺序执行：</p><p>（1）线程1读取内存位置X的值为A；</p><p>（2）线程1阻塞了；</p><p>（3）线程2读取内存位置X的值为A；</p><p>（4）线程2修改内存位置X的值为B；</p><p>（5）线程2修改又内存位置X的值为A；</p><p>（6）线程1恢复，继续执行，比较发现还是A把内存位置X的值设置为C；</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%B9%B6%E5%8F%91%E5%8C%85/resource/ABA1.png" alt="ABA"></p><p>可以看到，针对线程1来说，第一次的A和第二次的A实际上并不是同一个A。</p><p>ABA问题通常发生在无锁结构中，用代码来表示上面的过程大概就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABATest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> value = atomicInteger.get();</span><br><span class="line">            System.out.println(<span class="string">"thread 1 read value: "</span> + value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞1s</span></span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000000000L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(value, <span class="number">3</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread 1 update from "</span> + value + <span class="string">" to 3"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread 1 update fail!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> value = atomicInteger.get();</span><br><span class="line">            System.out.println(<span class="string">"thread 2 read value: "</span> + value);</span><br><span class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(value, <span class="number">2</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread 2 update from "</span> + value + <span class="string">" to 2"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do sth</span></span><br><span class="line"></span><br><span class="line">                value = atomicInteger.get();</span><br><span class="line">                System.out.println(<span class="string">"thread 2 read value: "</span> + value);</span><br><span class="line">                <span class="keyword">if</span> (atomicInteger.compareAndSet(value, <span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"thread 2 update from "</span> + value + <span class="string">" to 1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="number">1</span> read value: <span class="number">1</span></span><br><span class="line">thread <span class="number">2</span> read value: <span class="number">1</span></span><br><span class="line">thread <span class="number">2</span> update from <span class="number">1</span> to <span class="number">2</span></span><br><span class="line">thread <span class="number">2</span> read value: <span class="number">2</span></span><br><span class="line">thread <span class="number">2</span> update from <span class="number">2</span> to <span class="number">1</span></span><br><span class="line">thread <span class="number">1</span> update from <span class="number">1</span> to <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="ABA的危害"><a href="#ABA的危害" class="headerlink" title="ABA的危害"></a>ABA的危害</h2><p>为了更好地理解ABA的危害，我们还是来看一个现实点的例子。</p><p>假设我们有一个无锁的栈结构，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABATest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将top放在原子类中</span></span><br><span class="line">        <span class="keyword">private</span> AtomicReference&lt;Node&gt; top = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="comment">// 栈中节点信息</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> value;</span><br><span class="line">            Node next;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈操作</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取栈顶节点</span></span><br><span class="line">                Node t = top.get();</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈顶下一个节点</span></span><br><span class="line">                Node next = t.next;</span><br><span class="line">                <span class="comment">// CAS更新top指向其next节点</span></span><br><span class="line">                <span class="keyword">if</span> (top.compareAndSet(t, next)) &#123;</span><br><span class="line">                    <span class="comment">// 把栈顶元素弹出，应该把next清空防止外面直接操作栈</span></span><br><span class="line">                    t.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入栈操作</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取栈顶节点</span></span><br><span class="line">                Node next = top.get();</span><br><span class="line">                <span class="comment">// 设置栈顶节点为新节点的next节点</span></span><br><span class="line">                node.next = next;</span><br><span class="line">                <span class="comment">// CAS更新top指向新节点</span></span><br><span class="line">                <span class="keyword">if</span> (top.compareAndSet(next, node)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咋一看，这段程序似乎没有什么问题，然而试想以下情形。</p><p>假如，我们初始化栈结构为 top-&gt;1-&gt;2-&gt;3，然后有两个线程分别做如下操作：</p><p>（1）线程1执行pop()出栈操作，但是执行到<code>if (top.compareAndSet(t, next)) {</code>这行之前暂停了，所以此时节点1并未出栈；</p><p>（2）线程2执行pop()出栈操作弹出节点1，此时栈变为 top-&gt;2-&gt;3；</p><p>（3）线程2执行pop()出栈操作弹出节点2，此时栈变为 top-&gt;3；</p><p>（4）线程2执行push()入栈操作添加节点1，此时栈变为 top-&gt;1-&gt;3；</p><p>（5）线程1恢复执行，比较节点1的引用并没有改变，执行CAS成功，此时栈变为 top-&gt;2；</p><p>What？点解变成 top-&gt;2 了？不是应该变成 top-&gt;3 吗？</p><p>那是因为线程1在第一步保存的next是节点2，所以它执行CAS成功后top节点就指向了节点2了。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化栈为 top-&gt;1-&gt;2-&gt;3</span></span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    stack.push(<span class="keyword">new</span> Stack.Node(<span class="number">3</span>));</span><br><span class="line">    stack.push(<span class="keyword">new</span> Stack.Node(<span class="number">2</span>));</span><br><span class="line">    stack.push(<span class="keyword">new</span> Stack.Node(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 线程1出栈一个元素</span></span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 线程2出栈两个元素</span></span><br><span class="line">        Stack.Node A = stack.pop();</span><br><span class="line">        Stack.Node B = stack.pop();</span><br><span class="line">        <span class="comment">// 线程2又把A入栈了</span></span><br><span class="line">        stack.push(A);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    testStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Stack的pop()方法的<code>if (top.compareAndSet(t, next)) {</code>处打个断点，线程1运行到这里时阻塞它的执行，让线程2执行完，再执行线程1这句，这句执行完可以看到栈的top对象中只有2这个节点了。</p><p><em>记得打断点的时候一定要打Thread断点，在IDEA中是右击选择Suspend为Thread。</em></p><p>通过这个例子，笔者认为你肯定很清楚ABA的危害了。</p><h2 id="ABA的解决方法"><a href="#ABA的解决方法" class="headerlink" title="ABA的解决方法"></a>ABA的解决方法</h2><p>ABA的危害我们清楚了，那么怎么解决ABA呢？</p><p>笔者总结了一下，大概有以下几种方式：</p><p>（1）版本号</p><p>比如，上面的栈结构增加一个版本号用于控制，每次CAS的同时检查版本号有没有变过。</p><p>还有一些数据结构喜欢使用高位存储一个邮戳来保证CAS的安全。</p><p>（2）不重复使用节点的引用</p><p>比如，上面的栈结构在线程2执行push()入栈操作的时候新建一个节点传入，而不是复用节点1的引用；</p><p>（3）直接操作元素而不是节点</p><p>比如，上面的栈结构push()方法不应该传入一个节点（Node），而是传入元素值（int的value）。</p><p>好了，扯了这么多，让我们来看看java中的AtomicStampedReference是怎么解决ABA的吧^^</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素值和版本号绑定在一起，存储在Pair的reference和stamp（邮票、戳的意思）中。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> pairOffset =</span><br><span class="line">    objectFieldOffset(UNSAFE, <span class="string">"pair"</span>, AtomicStampedReference<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>声明一个Pair类型的变量并使用Unsfae获取其偏移量，存储到pairOffset中。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">    pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法需要传入初始值及初始版本号。</p><h3 id="compareAndSet-方法"><a href="#compareAndSet-方法" class="headerlink" title="compareAndSet()方法"></a>compareAndSet()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前的（元素值，版本号）对</span></span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 引用没变</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        <span class="comment">// 版本号没变</span></span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        <span class="comment">// 新引用等于旧引用</span></span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">        <span class="comment">// 新版本号等于旧版本号</span></span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">          <span class="comment">// 构造新的Pair对象并CAS更新</span></span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）如果元素值和版本号都没有变化，并且和新的也相同，返回true；</p><p>（2）如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。</p><p>可以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。</p><p>首先，使用版本号控制；</p><p>其次，不重复使用节点（Pair）的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；</p><p>最后，外部传入元素值及版本号，而不是节点（Pair）的引用。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>让我们来使用AtomicStampedReference解决开篇那个AtomicInteger带来的ABA问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABATest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testStamp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span>[] stampHolder = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> value = atomicStampedReference.get(stampHolder);</span><br><span class="line">            <span class="keyword">int</span> stamp = stampHolder[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">"thread 1 read value: "</span> + value + <span class="string">", stamp: "</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞1s</span></span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000000000L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">3</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread 1 update from "</span> + value + <span class="string">" to 3"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread 1 update fail!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span>[] stampHolder = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> value = atomicStampedReference.get(stampHolder);</span><br><span class="line">            <span class="keyword">int</span> stamp = stampHolder[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">"thread 2 read value: "</span> + value + <span class="string">", stamp: "</span> + stamp);</span><br><span class="line">            <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread 2 update from "</span> + value + <span class="string">" to 2"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do sth</span></span><br><span class="line"></span><br><span class="line">                value = atomicStampedReference.get(stampHolder);</span><br><span class="line">                stamp = stampHolder[<span class="number">0</span>];</span><br><span class="line">                System.out.println(<span class="string">"thread 2 read value: "</span> + value + <span class="string">", stamp: "</span> + stamp);</span><br><span class="line">                <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">1</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"thread 2 update from "</span> + value + <span class="string">" to 1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="number">1</span> read value: <span class="number">1</span>, stamp: <span class="number">1</span></span><br><span class="line">thread <span class="number">2</span> read value: <span class="number">1</span>, stamp: <span class="number">1</span></span><br><span class="line">thread <span class="number">2</span> update from <span class="number">1</span> to <span class="number">2</span></span><br><span class="line">thread <span class="number">2</span> read value: <span class="number">2</span>, stamp: <span class="number">2</span></span><br><span class="line">thread <span class="number">2</span> update from <span class="number">2</span> to <span class="number">1</span></span><br><span class="line">thread <span class="number">1</span> update fail!</span><br></pre></td></tr></table></figure><p>可以看到线程1最后更新1到3时失败了，因为这时版本号也变了，成功解决了ABA的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）在多线程环境下使用无锁结构要注意ABA问题；</p><p>（2）ABA的解决一般使用版本号来控制，并保证数据结构使用元素值来传递，且每次添加元素都新建节点承载元素值；</p><p>（3）AtomicStampedReference内部使用Pair来存储元素值及其版本号；</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>（1）java中还有哪些类可以解决ABA的问题？</p><p>AtomicMarkableReference，它不是维护一个版本号，而是维护一个boolean类型的标记，标记值有修改，了解一下。</p><p>（2）实际工作中遇到过ABA问题吗？</p><p>笔者还真遇到过，以前做棋牌游戏的时候，ABCD四个玩家，A玩家出了一张牌，然后他这个请求迟迟没到服务器，也就是超时了，服务器就帮他自动出了一张牌。</p><p>然后，转了一圈，又轮到A玩家出牌了，说巧不巧，正好这时之前那个请求到了服务器，服务器检测到现在正好是A出牌，而且请求的也是出牌，就把这张牌打出去了。</p><p>然后呢，A玩家的牌就不对了。</p><p>最后，我们是通过给每个请求增加一个序列号来处理的，检测到过期的序列号请求直接抛弃掉。</p><p>你有没有遇到过ABA问题呢？</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;（1）什么是ABA？&lt;/p&gt;
&lt;p&gt;（2）ABA的危害？&lt;/p&gt;
&lt;p&gt;（3）ABA的解决方法？&lt;/p&gt;
&lt;p&gt;（4）Atomic
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AtomicInteger</title>
    <link href="http://gottaboy.cn/2020/01/05/AtomicInteger/"/>
    <id>http://gottaboy.cn/2020/01/05/AtomicInteger/</id>
    <published>2020-01-05T12:01:54.000Z</published>
    <updated>2020-01-05T12:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）什么是原子操作？</p><p>（2）原子操作和数据库的ACID有啥关系？</p><p>（3）AtomicInteger是怎么实现原子操作的？</p><p>（4）AtomicInteger是有什么缺点？</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AtomicInteger是java并发包下面提供的原子类，主要操作的是int类型的整型，通过调用底层Unsafe的CAS等方法实现原子操作。</p><p>还记得Unsafe吗？点击链接直达【<a href="https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA" target="_blank" rel="noopener">死磕 java魔法类之Unsafe解析</a>】</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。</p><p>原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。</p><p>我们这里说的原子操作与数据库ACID中的原子性，笔者认为最大区别在于，数据库中的原子性主要运用在事务中，一个事务之内的所有更新操作要么都成功，要么都失败，事务是有回滚机制的，而我们这里说的原子操作是没有回滚的，这是最大的区别。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Unsafe的实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">// 标识value字段的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="comment">// 静态代码块，通过unsafe获取value的偏移量</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存储int类型值的地方，使用volatile修饰</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>（1）使用int类型的value存储值，且使用volatile修饰，volatile主要是保证可见性，即一个线程修改对另一个线程立即可见，主要的实现原理是内存屏障，这里不展开来讲，有兴趣的可以自行查阅相关资料。</p><p>（2）调用Unsafe的objectFieldOffset()方法获取value字段在类中的偏移量，用于后面CAS操作时使用。</p><h3 id="compareAndSet-方法"><a href="#compareAndSet-方法" class="headerlink" title="compareAndSet()方法"></a>compareAndSet()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>调用Unsafe.compareAndSwapInt()方法实现，这个方法有四个参数：</p><p>（1）操作的对象；</p><p>（2）对象中字段的偏移量；</p><p>（3）原来的值，即期望的值；</p><p>（4）要修改的值；</p><p>可以看到，这是一个native方法，底层是使用C/C++写的，主要是调用CPU的CAS指令来实现，它能够保证只有当对应偏移量处的字段值是期望值时才更新，即类似下面这样的两步操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == expect) &#123;</span><br><span class="line">    value = newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过CPU的CAS指令可以保证这两步操作是一个整体，也就不会出现多线程环境中可能比较的时候value值是a，而到真正赋值的时候value值可能已经变成b了的问题。</p><h3 id="getAndIncrement-方法"><a href="#getAndIncrement-方法" class="headerlink" title="getAndIncrement()方法"></a>getAndIncrement()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAndIncrement()方法底层是调用的Unsafe的getAndAddInt()方法，这个方法有三个参数：</p><p>（1）操作的对象；</p><p>（2）对象中字段的偏移量；</p><p>（3）要增加的值；</p><p>查看Unsafe的getAndAddInt()方法的源码，可以看到它是先获取当前的值，然后再调用compareAndSwapInt()尝试更新对应偏移量处的值，如果成功了就跳出循环，如果不成功就再重新尝试，直到成功为止，这可不就是（CAS+自旋）的乐观锁机制么^^</p><p>AtomicInteger中的其它方法几乎都是类似的，最终会调用到Unsafe的compareAndSwapInt()来保证对value值更新的原子性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）AtomicInteger中维护了一个使用volatile修饰的变量value，保证可见性；</p><p>（2）AtomicInteger中的主要方法最终几乎都会调用到Unsafe的compareAndSwapInt()方法保证对变量修改的原子性。</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>（1）为什么需要AtomicInteger？</p><p>让我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">                .forEach(i-&gt;</span><br><span class="line">                        <span class="keyword">new</span> Thread(()-&gt;IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">                                .forEach(j-&gt;increment())).start());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用2或者1看自己的机器</span></span><br><span class="line">        <span class="comment">// 我这里是用run跑大于2才会退出循环</span></span><br><span class="line">        <span class="comment">// 但是用debug跑大于1就会退出循环了</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 让出CPU</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里起了100个线程，每个线程对count自增1000次，你会发现每次运行的结果都不一样，但它们有个共同点就是都不到100000次，所以直接使用int是有问题的。</p><p>那么，使用volatile能解决这个问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是很遗憾的，volatile无法解决这个问题，因为volatile仅有两个作用：</p><p>（1）保证可见性，即一个线程对变量的修改另一个线程立即可见；</p><p>（2）禁止指令重排序；</p><p>这里有个很重要的问题，count++实际上是两步操作，第一步是获取count的值，第二步是对它的值加1。</p><p>使用volatile是无法保证这两步不被其它线程调度打断的，所以无法保证原子性。</p><p>这就引出了我们今天讲的AtomicInteger，它的自增调用的是Unsafe的CAS并使用自旋保证一定会成功，它可以保证两步操作的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">                .forEach(i-&gt;</span><br><span class="line">                        <span class="keyword">new</span> Thread(()-&gt;IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">                                .forEach(j-&gt;increment())).start());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用2或者1看自己的机器</span></span><br><span class="line">        <span class="comment">// 我这里是用run跑大于2才会退出循环</span></span><br><span class="line">        <span class="comment">// 但是用debug跑大于1就会退出循环了</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 让出CPU</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里总是会打印出100000。</p><p>（2）说了那么多，你知道AtomicInteger有什么缺点吗？</p><p>当然就是著名的ABA问题啦，我们下章接着聊^^</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;（1）什么是原子操作？&lt;/p&gt;
&lt;p&gt;（2）原子操作和数据库的ACID有啥关系？&lt;/p&gt;
&lt;p&gt;（3）AtomicInteger是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ShardingSphere</title>
    <link href="http://gottaboy.cn/2020/01/05/ShardingSphere/"/>
    <id>http://gottaboy.cn/2020/01/05/ShardingSphere/</id>
    <published>2020-01-05T11:58:56.000Z</published>
    <updated>2020-01-05T11:59:30.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ShardingSphere"><a href="#ShardingSphere" class="headerlink" title="ShardingSphere"></a>ShardingSphere</h2><p><a href="https://shardingsphere.apache.org/document/current/en/overview/" target="_blank" rel="noopener">ShardingSphere</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ShardingSphere&quot;&gt;&lt;a href=&quot;#ShardingSphere&quot; class=&quot;headerlink&quot; title=&quot;ShardingSphere&quot;&gt;&lt;/a&gt;ShardingSphere&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://shard
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://gottaboy.cn/2020/01/05/Redis/"/>
    <id>http://gottaboy.cn/2020/01/05/Redis/</id>
    <published>2020-01-05T11:56:31.000Z</published>
    <updated>2020-01-05T11:58:19.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a href="https://www.cnblogs.com/linlinismine/p/9214299.html" target="_blank" rel="noopener">Redis</a><br><a href="https://www.jianshu.com/p/fb0645033f0f" target="_blank" rel="noopener">https://www.jianshu.com/p/fb0645033f0f</a><br><a href="https://blog.csdn.net/xiao_jun_0820/article/details/82956593" target="_blank" rel="noopener">https://blog.csdn.net/xiao_jun_0820/article/details/82956593</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linlinismine/p/9214299.ht
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://gottaboy.cn/2020/01/05/Mysql/"/>
    <id>http://gottaboy.cn/2020/01/05/Mysql/</id>
    <published>2020-01-05T11:56:24.000Z</published>
    <updated>2020-01-05T11:57:18.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p><a href="https://mp.weixin.qq.com/s/w0CxgFMpD-LSI1e33IUx7w" target="_blank" rel="noopener">Mysql</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mysql&quot;&gt;&lt;a href=&quot;#Mysql&quot; class=&quot;headerlink&quot; title=&quot;Mysql&quot;&gt;&lt;/a&gt;Mysql&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/w0CxgFMpD-LSI1e33IUx7w
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Unsafe</title>
    <link href="http://gottaboy.cn/2020/01/05/Unsafe/"/>
    <id>http://gottaboy.cn/2020/01/05/Unsafe/</id>
    <published>2020-01-05T11:49:36.000Z</published>
    <updated>2020-01-05T11:50:32.202Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>（1）Unsafe是什么？</p><p>（2）Unsafe具有哪些功能？</p><p>（3）Unsafe为什么是不安全的？</p><p>（4）怎么使用Unsafe？</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章是java并发包专题的第一章，但是第一篇写的却不是java并发包中类，而是java中的魔法类sun.misc.Unsafe。</p><p>Unsafe为我们提供了访问低层的机制，这种机制仅供java核心类库使用，而不应该被普通用户使用。</p><p>但是，为了更好地了解java的生态体系，我们应该去学习它，去了解它，不求深入到底层的C/C++代码，但求能了解它的基本功能。</p><h2 id="获取Unsafe的实例"><a href="#获取Unsafe的实例" class="headerlink" title="获取Unsafe的实例"></a>获取Unsafe的实例</h2><p>查看Unsafe的源码我们会发现它提供了一个getUnsafe()的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果直接调用这个方法会抛出一个SecurityException异常，这是因为Unsafe仅供java内部类使用，外部类不应该使用它。</p><p>那么，我们就没有方法了吗？</p><p>当然不是，我们有反射啊！查看源码，我们发现它有一个属性叫theUnsafe，我们直接通过反射拿到它即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Unsafe实例化一个类"><a href="#使用Unsafe实例化一个类" class="headerlink" title="使用Unsafe实例化一个类"></a>使用Unsafe实例化一个类</h2><p>假如我们有一个简单的类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们通过构造方法实例化这个类，age属性将会返回10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 打印10</span></span><br><span class="line">System.out.println(user1.age);</span><br></pre></td></tr></table></figure><p>如果我们调用Unsafe来实例化呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user2 = (User) unsafe.allocateInstance(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 打印0</span></span><br><span class="line">System.out.println(user2.age);</span><br></pre></td></tr></table></figure><p>age将返回0，因为<code>Unsafe.allocateInstance()</code>只会给对象分配内存，并不会调用构造方法，所以这里只会返回int类型的默认值0。</p><h2 id="修改私有字段的值"><a href="#修改私有字段的值" class="headerlink" title="修改私有字段的值"></a>修改私有字段的值</h2><p>使用Unsafe的putXXX()方法，我们可以修改任意私有字段的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Field age = user.getClass().getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        unsafe.putInt(user, unsafe.objectFieldOffset(age), <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印20</span></span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦我们通过反射调用得到字段age，我们就可以使用Unsafe将其值更改为任何其他int值。（当然，这里也可以通过反射直接修改）</p><h2 id="抛出checked异常"><a href="#抛出checked异常" class="headerlink" title="抛出checked异常"></a>抛出checked异常</h2><p>我们知道如果代码抛出了checked异常，要不就使用try…catch捕获它，要不就在方法签名上定义这个异常，但是，通过Unsafe我们可以抛出一个checked异常，同时却不用捕获或在方法签名上定义它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用正常方式抛出IOException需要定义在方法签名上往外抛</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Unsafe抛出异常不需要定义在方法签名上往外抛</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unsafe.throwException(<span class="keyword">new</span> IOException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用堆外内存"><a href="#使用堆外内存" class="headerlink" title="使用堆外内存"></a>使用堆外内存</h2><p>如果进程在运行过程中JVM上的内存不足了，会导致频繁的进行GC。理想情况下，我们可以考虑使用堆外内存，这是一块不受JVM管理的内存。</p><p>使用Unsafe的allocateMemory()我们可以直接在堆外分配内存，这可能非常有用，但我们要记住，这个内存不受JVM管理，因此我们要调用freeMemory()方法手动释放它。</p><p>假设我们要在堆外创建一个巨大的int数组，我们可以使用allocateMemory()方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OffHeapArray</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个int等于4个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，分配内存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OffHeapArray</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">// 参数字节数</span></span><br><span class="line">        address = unsafe.allocateMemory(size * INT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取指定索引处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getInt(address + i * INT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置指定索引处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> i, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        unsafe.putInt(address + i * INT, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放堆外内存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中调用allocateMemory()分配内存，在使用完成后调用freeMemory()释放内存。</p><p>使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OffHeapArray offHeapArray = <span class="keyword">new</span> OffHeapArray(<span class="number">4</span>);</span><br><span class="line">offHeapArray.set(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">offHeapArray.set(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">offHeapArray.set(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">offHeapArray.set(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">offHeapArray.set(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 在索引2的位置重复放入元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offHeapArray.size(); i++) &#123;</span><br><span class="line">    sum += offHeapArray.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印12</span></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">offHeapArray.freeMemory();</span><br></pre></td></tr></table></figure><p>最后，一定要记得调用freeMemory()将内存释放回操作系统。</p><h2 id="CompareAndSwap操作"><a href="#CompareAndSwap操作" class="headerlink" title="CompareAndSwap操作"></a>CompareAndSwap操作</h2><p>JUC下面大量使用了CAS操作，它们的底层是调用的Unsafe的CompareAndSwapXXX()方法。这种方式广泛运用于无锁算法，与java中标准的悲观锁机制相比，它可以利用CAS处理器指令提供极大的加速。</p><p>比如，我们可以基于Unsafe的compareAndSwapInt()方法构建线程安全的计数器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">            offset = unsafe.objectFieldOffset(Counter.class.getDeclaredField("count"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> before = count;</span><br><span class="line">        <span class="comment">// 失败了就重试直到成功为止</span></span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapInt(<span class="keyword">this</span>, offset, before, before + <span class="number">1</span>)) &#123;</span><br><span class="line">            before = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个volatile的字段count，以便对它的修改所有线程都可见，并在类加载的时候获取count在类中的偏移地址。</p><p>在increment()方法中，我们通过调用Unsafe的compareAndSwapInt()方法来尝试更新之前获取到的count的值，如果它没有被其它线程更新过，则更新成功，否则不断重试直到成功为止。</p><p>我们可以通过使用多个线程来测试我们的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起100个线程，每个线程自增10000次</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    .forEach(i-&gt;threadPool.submit(()-&gt;IntStream.range(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">        .forEach(j-&gt;counter.increment())));</span><br><span class="line"></span><br><span class="line">threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印1000000</span></span><br><span class="line">System.out.println(counter.getCount());</span><br></pre></td></tr></table></figure><h2 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park/unpark"></a>park/unpark</h2><p>JVM在上下文切换的时候使用了Unsafe中的两个非常牛逼的方法park()和unpark()。</p><p>当一个线程正在等待某个操作时，JVM调用Unsafe的park()方法来阻塞此线程。</p><p>当阻塞中的线程需要再次运行时，JVM调用Unsafe的unpark()方法来唤醒此线程。</p><p>我们之前在分析java中的集合时看到了大量的LockSupport.park()/unpark()，它们底层都是调用的Unsafe的这两个方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用Unsafe几乎可以操作一切：</p><p>（1）实例化一个类；</p><p>（2）修改私有字段的值；</p><p>（3）抛出checked异常；</p><p>（4）使用堆外内存；</p><p>（5）CAS操作；</p><p>（6）阻塞/唤醒线程；</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>论实例化一个类的方式？</p><p>（1）通过构造方法实例化一个类；</p><p>（2）通过Class实例化一个类；</p><p>（3）通过反射实例化一个类；</p><p>（4）通过克隆实例化一个类；</p><p>（5）通过反序列化实例化一个类；</p><p>（6）通过Unsafe实例化一个类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 构造方法</span></span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 2. Class，里面实际也是反射</span></span><br><span class="line">        User user2 = User<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">        <span class="comment">// 3. 反射</span></span><br><span class="line">        User user3 = User<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>().<span class="title">newInstance</span>()</span>;</span><br><span class="line">        <span class="comment">// 4. 克隆</span></span><br><span class="line">        User user4 = (User) user1.clone();</span><br><span class="line">        <span class="comment">// 5. 反序列化</span></span><br><span class="line">        User user5 = unserialize(user1);</span><br><span class="line">        <span class="comment">// 6. Unsafe</span></span><br><span class="line">        User user6 = (User) unsafe.allocateInstance(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(user1.age);</span><br><span class="line">        System.out.println(user2.age);</span><br><span class="line">        System.out.println(user3.age);</span><br><span class="line">        System.out.println(user4.age);</span><br><span class="line">        System.out.println(user5.age);</span><br><span class="line">        System.out.println(user6.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">unserialize</span><span class="params">(User user1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D://object.txt"</span>));</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D://object.txt"</span>));</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        User user5 = (User) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="keyword">return</span> user5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;（1）Unsafe是什么？&lt;/p&gt;
&lt;p&gt;（2）Unsafe具有哪些功能？&lt;/p&gt;
&lt;p&gt;（3）Unsafe为什么是不安全的？&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaCollection</title>
    <link href="http://gottaboy.cn/2020/01/05/JavaCollection/"/>
    <id>http://gottaboy.cn/2020/01/05/JavaCollection/</id>
    <published>2020-01-05T07:15:48.000Z</published>
    <updated>2020-01-05T07:16:24.869Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>我们先来看一看java中所有集合的类关系图。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/collection1.png" alt="qrcode"></p><p>这里面的类太多了，请放大看，如果放大还看不清，请再放大看，如果还是看不清，请放弃。</p><p>我们下面主要分成五个部分来逐个击破。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List中的元素是有序的、可重复的，主要实现方式有动态数组和链表。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/List.png" alt="qrcode"></p><p>java中提供的List的实现主要有ArrayList、LinkedList、CopyOnWriteArrayList，另外还有两个古老的类Vector和Stack。</p><p>关于List相关的问题主要有：</p><p>（1）ArrayList和LinkedList有什么区别？</p><p>（2）ArrayList是怎么扩容的？</p><p>（3）ArrayList插入、删除、查询元素的时间复杂度各是多少？</p><p>（4）怎么求两个集合的并集、交集、差集？</p><p>（5）ArrayList是怎么实现序列化和反序列化的？</p><p>（6）集合的方法toArray()有什么问题？</p><p>（7）什么是fail-fast？</p><p>（8）LinkedList是单链表还是双链表实现的？</p><p>（9）LinkedList除了作为List还有什么用处？</p><p>（10）LinkedList插入、删除、查询元素的时间复杂度各是多少？</p><p>（11）什么是随机访问？</p><p>（12）哪些集合支持随机访问？他们都有哪些共性？</p><p>（13）CopyOnWriteArrayList是怎么保证并发安全的？</p><p>（14）CopyOnWriteArrayList的实现采用了什么思想？</p><p>（15）CopyOnWriteArrayList是不是强一致性的？</p><p>（16）CopyOnWriteArrayList适用于什么样的场景？</p><p>（17）CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？</p><p>（18）CopyOnWriteArrayList为什么没有size属性？</p><p>（19）比较古老的集合Vector和Stack有什么缺陷？</p><p>关于List的问题大概就这么多，你都能回答上来吗？</p><p>点击下面链接可以直接到相应的章节查看：</p><p><a href="https://mp.weixin.qq.com/s/a0zq-q8JuSwsLYX7tJ4VxA" target="_blank" rel="noopener">死磕 Java集合之ArrayList源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/Vy83PNpXvKCM9YG6CiTwBQ" target="_blank" rel="noopener">死磕 java集合之LinkedList源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/TDmrSxwmgUS8xohWiKc3hQ" target="_blank" rel="noopener">死磕 java集合之CopyOnWriteArrayList源码分析</a></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map是一种(key/value)的映射结构，其它语言里可能称作字典（Dictionary），包括java早期也是叫做字典，Map中的元素是一个key只能对应一个value，不能存在重复的key。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/Map.png" alt="qrcode"></p><p>java中提供的Map的实现主要有HashMap、LinkedHashMap、WeakHashMap、TreeMap、ConcurrentHashMap、ConcurrentSkipListMap，另外还有两个比较古老的Map实现HashTable和Properties。</p><p>关于Map的问题主要有：</p><p>（1）什么是散列表？</p><p>（2）怎么实现一个散列表？</p><p>（3）java中HashMap实现方式的演进？</p><p>（4）HashMap的容量有什么特点？</p><p>（5）HashMap是怎么进行扩容的？</p><p>（6）HashMap中的元素是否是有序的？</p><p>（7）HashMap何时进行树化？何时进行反树化？</p><p>（8）HashMap是怎么进行缩容的？</p><p>（9）HashMap插入、删除、查询元素的时间复杂度各是多少？</p><p>（10）HashMap中的红黑树实现部分可以用其它数据结构代替吗？</p><p>（11）LinkedHashMap是怎么实现的？</p><p>（12）LinkedHashMap是有序的吗？怎么个有序法？</p><p>（13）LinkedHashMap如何实现LRU缓存淘汰策略？</p><p>（14）WeakHashMap使用的数据结构？</p><p>（15）WeakHashMap具有什么特性？</p><p>（16）WeakHashMap通常用来做什么？</p><p>（17）WeakHashMap使用String作为key是需要注意些什么？为什么？</p><p>（18）什么是弱引用？</p><p>（19）红黑树具有哪些特性？</p><p>（20）TreeMap就有序的吗？怎么个有序法？</p><p>（21）TreeMap是否需要扩容？</p><p>（22）什么是左旋？什么是右旋？</p><p>（23）红黑树怎么插入元素？</p><p>（24）红黑树怎么删除元素？</p><p>（25）为什么要进行平衡？</p><p>（26）如何实现红黑树的遍历？</p><p>（27）TreeMap中是怎么遍历的？</p><p>（28）TreeMap插入、删除、查询元素的时间复杂度各是多少？</p><p>（29）HashMap在多线程环境中什么时候会出现问题？</p><p>（30）ConcurrentHashMap的存储结构？</p><p>（31）ConcurrentHashMap是怎么保证并发安全的？</p><p>（32）ConcurrentHashMap是怎么扩容的？</p><p>（33）ConcurrentHashMap的size()方法的实现知多少？</p><p>（34）ConcurrentHashMap是强一致性的吗？</p><p>（35）ConcurrentHashMap不能解决什么问题？</p><p>（36）ConcurrentHashMap中哪些地方运用到分段锁的思想？</p><p>（37）什么是伪共享？怎么避免伪共享？</p><p>（38）什么是跳表？</p><p>（40）ConcurrentSkipList是有序的吗？</p><p>（41）ConcurrentSkipList是如何保证线程安全的？</p><p>（42）ConcurrentSkipList插入、删除、查询元素的时间复杂度各是多少？</p><p>（43）ConcurrentSkipList的索引具有什么特性？</p><p>（44）为什么Redis选择使用跳表而不是红黑树来实现有序集合？</p><p>关于Map的问题大概就这么多，你都能回答上来吗？</p><p>点击下面链接可以直接到相应的章节查看：</p><p><a href="https://mp.weixin.qq.com/s/UFeLHR4qtGYPODTiNJDmHQ" target="_blank" rel="noopener">死磕 java集合之HashMap源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/2MAZldmPL_BORxIKoPh09w" target="_blank" rel="noopener">死磕 java集合之LinkedHashMap源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/6yszPjeP1icCYz483oieFA" target="_blank" rel="noopener">死磕 java集合之WeakHashMap源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/kIQhghgHO_vjgq3dtai16Q" target="_blank" rel="noopener">死磕 java集合之TreeMap源码分析（一）</a></p><p><a href="https://mp.weixin.qq.com/s/dd4ogZsCBe9nk9KBriU8dw" target="_blank" rel="noopener">死磕 java集合之TreeMap源码分析（二）</a></p><p><a href="https://mp.weixin.qq.com/s/lUjkg1TtqnEooh6GSdOv1w" target="_blank" rel="noopener">死磕 java集合之TreeMap源码分析（三）</a></p><p><a href="https://mp.weixin.qq.com/s/hk1_-6FAgVvT9htOMdwYUA" target="_blank" rel="noopener">死磕 java集合之TreeMap源码分析（四）</a></p><p><a href="https://mp.weixin.qq.com/s/rlyoQp4ngTX8mjGDJgJIRA" target="_blank" rel="noopener">死磕 java集合之ConcurrentHashMap源码分析（一）</a></p><p><a href="https://mp.weixin.qq.com/s/_Bf6XcH51lssC0mdF_oW9A" target="_blank" rel="noopener">死磕 java集合之ConcurrentHashMap源码分析（二）</a></p><p><a href="https://mp.weixin.qq.com/s/wOT2owVBlZ6HJeKbgQ4NQQ" target="_blank" rel="noopener">死磕 java集合之ConcurrentHashMap源码分析（三）</a></p><p><a href="https://mp.weixin.qq.com/s/yd2sOhmVtZeEkJ06cTE7qA" target="_blank" rel="noopener">死磕 java集合之ConcurrentSkipListMap源码分析</a></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>java里面的Set对应于数学概念上的集合，里面的元素是不可重复的，通常使用Map或者List来实现。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/Set.png" alt="qrcode"></p><p>java中提供的Set的实现主要有HashSet、LinkedHashSet、TreeSet、CopyOnWriteArraySet、ConcurrentSkipSet。</p><p>关于Set的问题主要有：</p><p>（1）HashSet怎么保证添加元素不重复？</p><p>（2）HashSet是有序的吗？</p><p>（3）HashSet是否允许null元素？</p><p>（4）Set是否有get()方法？</p><p>（5）LinkedHashSet是有序的吗？怎么个有序法？</p><p>（6）LinkedHashSet支持按元素访问顺序排序吗？</p><p>（8）TreeSet真的是使用TreeMap来存储元素的吗？</p><p>（9）TreeSet是有序的吗？怎么个有序法？</p><p>（10）TreeSet和LinkedHashSet有何不同？</p><p>（11）TreeSet和SortedSet有什么区别和联系？</p><p>（12）CopyOnWriteArraySet是用Map实现的吗？</p><p>（13）CopyOnWriteArraySet是有序的吗？怎么个有序法？</p><p>（14）CopyOnWriteArraySet怎么保证并发安全？</p><p>（15）CopyOnWriteArraySet以何种方式保证元素不重复？</p><p>（16）如何比较两个Set中的元素是否完全一致？</p><p>（17）ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？</p><p>（18）ConcurrentSkipListSet是有序的吗？怎么个有序法？</p><p>关于Set的问题大概就这么多，你都能回答上来吗？</p><p>点击下面链接可以直接到相应的章节查看：</p><p><a href="https://mp.weixin.qq.com/s/GFF5QiAW3uHFrxqEWOjOtg" target="_blank" rel="noopener">死磕 java集合之HashSet源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/9hTXKACrw55VAJ-jJZtkxA" target="_blank" rel="noopener">死磕 java集合之LinkedHashSet源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/Hu8Y90fyuieq623m4DXRBw" target="_blank" rel="noopener">死磕 java集合之TreeSet源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/b4BGx7icAnqFaOwhoctSRg" target="_blank" rel="noopener">死磕 java集合之CopyOnWriteArraySet源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/PSgxGQJPxeQ3XbtnOG7o3A" target="_blank" rel="noopener">死磕 java集合之ConcurrentSkipListSet源码分析</a></p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue是一种叫做队列的数据结构，队列是遵循着一定原则的入队出队操作的集合，一般来说，入队是在队列尾添加元素，出队是在队列头删除元素，但是，也不一定，比如优先级队列的原则就稍微有些不同。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/Queue.png" alt="qrcode"></p><p>java中提供的Queue的实现主要有PriorityQueue、ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue、LinkedTransferQueue、DelayQueue、ConcurrentLinkedQueue。</p><p>关于Queue的问题主要有：</p><p>（1）什么是堆？什么是堆化？</p><p>（2）什么是优先级队列？</p><p>（3）PriorityQueue是怎么实现的？</p><p>（4）PriorityQueue是有序的吗？</p><p>（5）PriorityQueue入队、出队的时间复杂度各是多少？</p><p>（6）PriorityQueue是否需要扩容？扩容规则呢？</p><p>（7）ArrayBlockingQueue的实现方式？</p><p>（8）ArrayBlockingQueue是否需要扩容？</p><p>（9）ArrayBlockingQueue怎么保证线程安全？</p><p>（9）ArrayBlockingQueue有什么缺点？</p><p>（10）LinkedBlockingQueue的实现方式？</p><p>（11）LinkedBlockingQueue是有界的还是无界的队列？</p><p>（12）LinkedBlockingQueue怎么保证线程安全？</p><p>（13）LinkedBlockingQueue与ArrayBlockingQueue对比？</p><p>（14）SynchronousQueue的实现方式？</p><p>（15）SynchronousQueue真的是无缓冲的吗？</p><p>（16）SynchronousQueue怎么保证线程安全？</p><p>（17）SynchronousQueue的公平模式和非公平模式有什么区别？</p><p>（18）SynchronousQueue在高并发情景下会有什么问题？</p><p>（19）PriorityBlockingQueue的实现方式？</p><p>（20）PriorityBlockingQueue是否需要扩容？</p><p>（21）PriorityBlockingQueue怎么保证线程安全？</p><p>（22）PriorityBlockingQueue为什么不需要notFull条件？</p><p>（23）什么是双重队列？</p><p>（24）LinkedTransferQueue是怎么实现阻塞队列的？</p><p>（25）LinkedTransferQueue是怎么控制并发安全的？</p><p>（26）LinkedTransferQueue与SynchronousQueue有什么异同？</p><p>（27）ConcurrentLinkedQueue是阻塞队列吗？</p><p>（28）ConcurrentLinkedQueue如何保证并发安全？</p><p>（29）ConcurrentLinkedQueue能用于线程池吗？</p><p>（30）DelayQueue是阻塞队列吗？</p><p>（31）DelayQueue的实现方式？</p><p>（32）DelayQueue主要用于什么场景？</p><p>关于Queue的问题大概就这么多，你都能回答上来吗？</p><p>点击下面链接可以直接到相应的章节查看：</p><p><a href="https://mp.weixin.qq.com/s/kGKS7WXWbf-ME1_Hr3Fpgw" target="_blank" rel="noopener">死磕 java集合之PriorityQueue源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/EN7qY1w4e8C0ZXiP7i82TA" target="_blank" rel="noopener">死磕 java集合之ArrayBlockingQueue源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/y6PoK3UbVLwdZoauLX8nsQ" target="_blank" rel="noopener">死磕 java集合之LinkedBlockingQueue源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/dv_jT0-FuB-e2lDOXuqAwg" target="_blank" rel="noopener">死磕 java集合之SynchronousQueue源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/AfSwIRbI-YjhMegv9qHazw" target="_blank" rel="noopener">死磕 java集合之PriorityBlockingQueue源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/OZ8tbFqvD9lWEgdvtJ5wog" target="_blank" rel="noopener">死磕 java集合之LinkedTransferQueue源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/DcirxmnxtS54fNbRYoimYA" target="_blank" rel="noopener">死磕 java集合之ConcurrentLinkedQueue源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/IOTwwgaOdMpZl-6QM0HlVQ" target="_blank" rel="noopener">死磕 java集合之DelayQueue源码分析</a></p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列（Double Ended Queue）。</p><p><img src="https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/Queue.png" alt="qrcode"></p><p>java中提供的Deque的实现主要有ArrayDeque、LinkedBlockingDeque、ConcurrentLinkedDeque、LinkedList。</p><p>关于Deque的问题主要有：</p><p>（1）什么是双端队列？</p><p>（2）ArrayDeque是怎么实现双端队列的？</p><p>（3）ArrayDeque是有界的吗？</p><p>（4）LinkedList与ArrayDeque的对比？</p><p>（5）双端队列是否可以作为栈使用？</p><p>（6）LinkedBlockingDeque是怎么实现双端队列的？</p><p>（7）LinkedBlockingDeque是怎么保证并发安全的？</p><p>（8）ConcurrentLinkedDeque是怎么实现双端队列的？</p><p>（9）ConcurrentLinkedDeque是怎么保证并发安全的？</p><p>（10）LinkedList是List和Deque的集合体？</p><p>关于Deque的问题大概就这么多，你都能回答上来吗？</p><p>点击下面链接可以直接到相应的章节查看（LinkedBlockingDeque和ConcurrentLinkedDeque跟相应的Queue的实现方式基本一致，所以笔者没写这两个类的源码分析）：</p><p><a href="https://mp.weixin.qq.com/s/PG6NOMgXS6Slh0aXRv9W-g" target="_blank" rel="noopener">死磕 java集合之ArrayDeque源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/Vy83PNpXvKCM9YG6CiTwBQ" target="_blank" rel="noopener">死磕 java集合之LinkedList源码分析</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实上面的问题很多都具有共性，我觉得以下几个问题在看每个集合类的时候都要掌握清楚：</p><p>（1）使用的数据结构？</p><p>（2）添加元素、删除元素的基本逻辑？</p><p>（3）是否是fail-fast的？</p><p>（4）是否需要扩容？扩容规则？</p><p>（5）是否有序？是按插入顺序还是自然顺序还是访问顺序？</p><p>（6）是否线程安全？</p><p>（7）使用的锁？</p><p>（8）优点？缺点？</p><p>（9）适用的场景？</p><p>（10）时间复杂度？</p><p>（11）空间复杂度？</p><p>（12）还有呢？</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>到这里整个集合的内容就全部完毕了，其实看了这么多集合的源码之后，笔者发现，基本上所有集合类使用的数据结构都是数组和链表，包括树和跳表也可以看成是链表的一种方式。</p><p>对于并发安全的集合，还要再加上相应的锁策略，要不就是重入锁，要不就是CAS+自旋，偶尔也来个synchronized。</p><p>所以，掌握集合的源码不算什么，数据结构和锁才是王道。</p><p>预告：下一个专题是java并发包，也就是著名的JUC，当然这里是除了并发集合以外的内容，也就是原子类、各种锁、线程池。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;我们先来看一看java中所有集合的类关系图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-ta
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
